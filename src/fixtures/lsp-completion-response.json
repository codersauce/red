{
  "isIncomplete": true,
  "items": [
    {
      "label": "self::",
      "kind": 14,
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "self::",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "self::"
      },
      "additionalTextEdits": []
    },
    {
      "label": "crate::",
      "kind": 14,
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "crate::",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "crate::"
      },
      "additionalTextEdits": []
    },
    {
      "label": "super::",
      "kind": 14,
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "super::",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "super::"
      },
      "additionalTextEdits": []
    },
    {
      "label": "cells",
      "kind": 6,
      "detail": "Vec<Cell, Global>",
      "deprecated": false,
      "preselect": true,
      "sortText": "7ffffffe",
      "filterText": "cells",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "cells"
      },
      "additionalTextEdits": []
    },
    {
      "label": "width",
      "kind": 6,
      "detail": "usize",
      "deprecated": false,
      "preselect": true,
      "sortText": "7ffffffe",
      "filterText": "width",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "width"
      },
      "additionalTextEdits": []
    },
    {
      "label": "height",
      "kind": 6,
      "detail": "usize",
      "deprecated": false,
      "preselect": true,
      "sortText": "7ffffffe",
      "filterText": "height",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "height"
      },
      "additionalTextEdits": []
    },
    {
      "label": "style",
      "kind": 6,
      "detail": "Style",
      "deprecated": false,
      "preselect": true,
      "sortText": "7ffffffe",
      "filterText": "style",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "style"
      },
      "additionalTextEdits": []
    },
    {
      "label": "style",
      "kind": 9,
      "documentation": {
        "kind": "markdown",
        "value": "A module to apply attributes and colors on your text.\n# Style\n\nThe `style` module provides a functionality to apply attributes and colors on your text.\n\nThis documentation does not contain a lot of examples. The reason is that it's fairly\nobvious how to use this crate. Although, we do provide\n[examples](https://github.com/crossterm-rs/crossterm/tree/master/examples) repository\nto demonstrate the capabilities.\n\n## Platform-specific Notes\n\nNot all features are supported on all terminals/platforms. You should always consult\nplatform-specific notes of the following types:\n\n* [Color](enum.Color.html#platform-specific-notes)\n* [Attribute](enum.Attribute.html#platform-specific-notes)\n\n## Examples\n\nA few examples of how to use the style module.\n\n### Colors\n\nHow to change the terminal text color.\n\nCommand API:\n\nUsing the Command API to color text.\n\n```rust\nuse std::io::{self, Write};\nuse crossterm::execute;\nuse crossterm::style::{Print, SetForegroundColor, SetBackgroundColor, ResetColor, Color, Attribute};\n\nfn main() -> io::Result<()> {\n    execute!(\n        io::stdout(),\n        // Blue foreground\n        SetForegroundColor(Color::Blue),\n        // Red background\n        SetBackgroundColor(Color::Red),\n        // Print text\n        Print(\"Blue text on Red.\".to_string()),\n        // Reset to default colors\n        ResetColor\n    )\n}\n```\n\nFunctions:\n\nUsing functions from [`Stylize`](crate::style::Stylize) on a `String` or `&'static str` to color\nit.\n\n```rust\nuse crossterm::style::Stylize;\n\nprintln!(\"{}\", \"Red foreground color & blue background.\".red().on_blue());\n```\n\n### Attributes\n\nHow to apply terminal attributes to text.\n\nCommand API:\n\nUsing the Command API to set attributes.\n\n```rust\nuse std::io::{self, Write};\n\nuse crossterm::execute;\nuse crossterm::style::{Attribute, Print, SetAttribute};\n\nfn main() -> io::Result<()> {\n    execute!(\n        io::stdout(),\n        // Set to bold\n        SetAttribute(Attribute::Bold),\n        Print(\"Bold text here.\".to_string()),\n        // Reset all attributes\n        SetAttribute(Attribute::Reset)\n    )\n}\n```\n\nFunctions:\n\nUsing [`Stylize`](crate::style::Stylize) functions on a `String` or `&'static str` to set\nattributes to it.\n\n```rust\nuse crossterm::style::Stylize;\n\nprintln!(\"{}\", \"Bold\".bold());\nprintln!(\"{}\", \"Underlined\".underlined());\nprintln!(\"{}\", \"Negative\".negative());\n```\n\nDisplayable:\n\n[`Attribute`](enum.Attribute.html) implements [Display](https://doc.rust-lang.org/beta/std/fmt/trait.Display.html) and therefore it can be formatted like:\n\n```rust\nuse crossterm::style::Attribute;\n\nprintln!(\n    \"{} Underlined {} No Underline\",\n    Attribute::Underlined,\n    Attribute::NoUnderline\n);\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "style",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "style"
      },
      "additionalTextEdits": []
    },
    {
      "label": "contents",
      "kind": 6,
      "detail": "Vec<String, Global>",
      "deprecated": false,
      "preselect": true,
      "sortText": "7ffffffe",
      "filterText": "contents",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "contents"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Self",
      "kind": 12,
      "detail": "RenderBuffer",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Self",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Self"
      },
      "additionalTextEdits": []
    },
    {
      "label": "ACTION_DISPATCHER",
      "kind": 12,
      "detail": "Lazy<Dispatcher<PluginRequest, PluginResponse>, fn() -> Dispatcher<PluginRequest, PluginResponse>>",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "ACTION_DISPATCHER",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "ACTION_DISPATCHER"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Action",
      "kind": 13,
      "detail": "Action",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Action",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Action"
      },
      "additionalTextEdits": []
    },
    {
      "label": "ActionOnSelection",
      "kind": 22,
      "detail": "ActionOnSelection",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "ActionOnSelection",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "ActionOnSelection"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Buffer",
      "kind": 22,
      "detail": "Buffer",
      "documentation": {
        "kind": "markdown",
        "value": "Buffer represents an editable text buffer, which may be associated with a file.\nIt maintains the text content as a rope data structure for efficient editing operations."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Buffer",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Buffer"
      },
      "additionalTextEdits": []
    },
    {
      "label": "BufferInfo",
      "kind": 22,
      "detail": "BufferInfo",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "BufferInfo",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "BufferInfo"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Cell",
      "kind": 22,
      "detail": "Cell",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Cell",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Cell"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Change",
      "kind": 22,
      "detail": "Change<'_>",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Change",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Change"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Clear",
      "kind": 22,
      "detail": "Clear",
      "documentation": {
        "kind": "markdown",
        "value": "A command that clears the terminal screen buffer.\n\nSee the [`ClearType`](enum.ClearType.html) enum.\n\n# Notes\n\nCommands must be executed/queued for execution otherwise they do nothing."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Clear",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Clear"
      },
      "additionalTextEdits": []
    },
    {
      "label": "ClearType",
      "kind": 13,
      "detail": "ClearType",
      "documentation": {
        "kind": "markdown",
        "value": "Different ways to clear the terminal buffer."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "ClearType",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "ClearType"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Color",
      "kind": 13,
      "detail": "Color",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Color",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Color"
      },
      "additionalTextEdits": []
    },
    {
      "label": "CompletionResponse",
      "kind": 22,
      "detail": "CompletionResponse",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "CompletionResponse",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "CompletionResponse"
      },
      "additionalTextEdits": []
    },
    {
      "label": "CompletionUI",
      "kind": 22,
      "detail": "CompletionUI",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "CompletionUI",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "CompletionUI"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Component",
      "kind": 8,
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Component",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Component"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Config",
      "kind": 22,
      "detail": "Config",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Config",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Config"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Content",
      "kind": 22,
      "detail": "Content",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Content",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Content"
      },
      "additionalTextEdits": []
    },
    {
      "label": "ContentKind",
      "kind": 13,
      "detail": "ContentKind",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "ContentKind",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "ContentKind"
      },
      "additionalTextEdits": []
    },
    {
      "label": "DEFAULT_REGISTER",
      "kind": 21,
      "detail": "char",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "DEFAULT_REGISTER",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "DEFAULT_REGISTER"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Deserialize",
      "kind": 8,
      "documentation": {
        "kind": "markdown",
        "value": "A **data structure** that can be deserialized from any data format supported\nby Serde.\n\nSerde provides `Deserialize` implementations for many Rust primitive and\nstandard library types. The complete list is [here][crate::de]. All of these\ncan be deserialized using Serde out of the box.\n\nAdditionally, Serde provides a procedural macro called `serde_derive` to\nautomatically generate `Deserialize` implementations for structs and enums\nin your program. See the [derive section of the manual][derive] for how to\nuse this.\n\nIn rare cases it may be necessary to implement `Deserialize` manually for\nsome type in your program. See the [Implementing\n`Deserialize`][impl-deserialize] section of the manual for more about this.\n\nThird-party crates may provide `Deserialize` implementations for types that\nthey expose. For example the `linked-hash-map` crate provides a\n`LinkedHashMap<K, V>` type that is deserializable by Serde because the crate\nprovides an implementation of `Deserialize` for it.\n\n[derive]: https://serde.rs/derive.html\n[impl-deserialize]: https://serde.rs/impl-deserialize.html\n\n# Lifetime\n\nThe `'de` lifetime of this trait is the lifetime of data that may be\nborrowed by `Self` when deserialized. See the page [Understanding\ndeserializer lifetimes] for a more detailed explanation of these lifetimes.\n\n[Understanding deserializer lifetimes]: https://serde.rs/lifetimes.html"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Deserialize",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Deserialize"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Diagnostic",
      "kind": 22,
      "detail": "Diagnostic",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Diagnostic",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Diagnostic"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Dispatcher",
      "kind": 22,
      "detail": "Dispatcher<{unknown}, {unknown}>",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Dispatcher",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Dispatcher"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Duration",
      "kind": 22,
      "detail": "Duration",
      "documentation": {
        "kind": "markdown",
        "value": "A `Duration` type to represent a span of time, typically used for system\ntimeouts.\n\nEach `Duration` is composed of a whole number of seconds and a fractional part\nrepresented in nanoseconds. If the underlying system does not support\nnanosecond-level precision, APIs binding a system timeout will typically round up\nthe number of nanoseconds.\n\n[`Duration`]s implement many common traits, including [`Add`], [`Sub`], and other\n[`ops`] traits. It implements [`Default`] by returning a zero-length `Duration`.\n\n[`ops`]: crate::ops\n\n# Examples\n\n```rust\nuse std::time::Duration;\n\nlet five_seconds = Duration::new(5, 0);\nlet five_seconds_and_five_nanos = five_seconds + Duration::new(0, 5);\n\nassert_eq!(five_seconds_and_five_nanos.as_secs(), 5);\nassert_eq!(five_seconds_and_five_nanos.subsec_nanos(), 5);\n\nlet ten_millis = Duration::from_millis(10);\n```\n\n# Formatting `Duration` values\n\n`Duration` intentionally does not have a `Display` impl, as there are a\nvariety of ways to format spans of time for human readability. `Duration`\nprovides a `Debug` impl that shows the full precision of the value.\n\nThe `Debug` output uses the non-ASCII \"µs\" suffix for microseconds. If your\nprogram output may appear in contexts that cannot rely on full Unicode\ncompatibility, you may wish to format `Duration` objects yourself or use a\ncrate to do so."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Duration",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Duration"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Editor",
      "kind": 22,
      "detail": "Editor",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Editor",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Editor"
      },
      "additionalTextEdits": []
    },
    {
      "label": "EditorInfo",
      "kind": 22,
      "detail": "EditorInfo",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "EditorInfo",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "EditorInfo"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Event",
      "kind": 13,
      "detail": "Event",
      "documentation": {
        "kind": "markdown",
        "value": "Represents an event."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Event",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Event"
      },
      "additionalTextEdits": []
    },
    {
      "label": "EventStream",
      "kind": 22,
      "detail": "EventStream",
      "documentation": {
        "kind": "markdown",
        "value": "A stream of `Result<Event>`.\n\n**This type is not available by default. You have to use the `event-stream` feature flag\nto make it available.**\n\nIt implements the [Stream](futures_core::stream::Stream)\ntrait and allows you to receive [`Event`]s with [`async-std`](https://crates.io/crates/async-std)\nor [`tokio`](https://crates.io/crates/tokio) crates.\n\nCheck the [examples](https://github.com/crossterm-rs/crossterm/tree/master/examples) folder to see how to use\nit (`event-stream-*`)."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "EventStream",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "EventStream"
      },
      "additionalTextEdits": []
    },
    {
      "label": "ExecutableCommand",
      "kind": 8,
      "documentation": {
        "kind": "markdown",
        "value": "An interface for types that can directly execute commands."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "ExecutableCommand",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "ExecutableCommand"
      },
      "additionalTextEdits": []
    },
    {
      "label": "FilePicker",
      "kind": 22,
      "detail": "FilePicker",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "FilePicker",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "FilePicker"
      },
      "additionalTextEdits": []
    },
    {
      "label": "FutureExt",
      "kind": 8,
      "documentation": {
        "kind": "markdown",
        "value": "An extension trait for `Future`s that provides a variety of convenient\nadapters."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "FutureExt",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "FutureExt"
      },
      "additionalTextEdits": []
    },
    {
      "label": "GoToLinePosition",
      "kind": 13,
      "detail": "GoToLinePosition",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "GoToLinePosition",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "GoToLinePosition"
      },
      "additionalTextEdits": []
    },
    {
      "label": "HashMap",
      "kind": 22,
      "detail": "HashMap<{unknown}, {unknown}, {unknown}>",
      "documentation": {
        "kind": "markdown",
        "value": "A [hash map] implemented with quadratic probing and SIMD lookup.\n\nBy default, `HashMap` uses a hashing algorithm selected to provide\nresistance against HashDoS attacks. The algorithm is randomly seeded, and a\nreasonable best-effort is made to generate this seed from a high quality,\nsecure source of randomness provided by the host without blocking the\nprogram. Because of this, the randomness of the seed depends on the output\nquality of the system's random number coroutine when the seed is created.\nIn particular, seeds generated when the system's entropy pool is abnormally\nlow such as during system boot may be of a lower quality.\n\nThe default hashing algorithm is currently SipHash 1-3, though this is\nsubject to change at any point in the future. While its performance is very\ncompetitive for medium sized keys, other hashing algorithms will outperform\nit for small keys such as integers as well as large keys such as long\nstrings, though those algorithms will typically *not* protect against\nattacks such as HashDoS.\n\nThe hashing algorithm can be replaced on a per-`HashMap` basis using the\n[`default`], [`with_hasher`], and [`with_capacity_and_hasher`] methods.\nThere are many alternative [hashing algorithms available on crates.io].\n\nIt is required that the keys implement the [`Eq`] and [`Hash`] traits, although\nthis can frequently be achieved by using `#[derive(PartialEq, Eq, Hash)]`.\nIf you implement these yourself, it is important that the following\nproperty holds:\n\n```text\nk1 == k2 -> hash(k1) == hash(k2)\n```\n\nIn other words, if two keys are equal, their hashes must be equal.\nViolating this property is a logic error.\n\nIt is also a logic error for a key to be modified in such a way that the key's\nhash, as determined by the [`Hash`] trait, or its equality, as determined by\nthe [`Eq`] trait, changes while it is in the map. This is normally only\npossible through [`Cell`], [`RefCell`], global state, I/O, or unsafe code.\n\nThe behavior resulting from either logic error is not specified, but will\nbe encapsulated to the `HashMap` that observed the logic error and not\nresult in undefined behavior. This could include panics, incorrect results,\naborts, memory leaks, and non-termination.\n\nThe hash table implementation is a Rust port of Google's [SwissTable].\nThe original C++ version of SwissTable can be found [here], and this\n[CppCon talk] gives an overview of how the algorithm works.\n\n[hash map]: crate::collections#use-a-hashmap-when\n[hashing algorithms available on crates.io]: https://crates.io/keywords/hasher\n[SwissTable]: https://abseil.io/blog/20180927-swisstables\n[here]: https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h\n[CppCon talk]: https://www.youtube.com/watch?v=ncHmEUmJZf4\n\n# Examples\n\n```rust\nuse std::collections::HashMap;\n\n// Type inference lets us omit an explicit type signature (which\n// would be `HashMap<String, String>` in this example).\nlet mut book_reviews = HashMap::new();\n\n// Review some books.\nbook_reviews.insert(\n    \"Adventures of Huckleberry Finn\".to_string(),\n    \"My favorite book.\".to_string(),\n);\nbook_reviews.insert(\n    \"Grimms' Fairy Tales\".to_string(),\n    \"Masterpiece.\".to_string(),\n);\nbook_reviews.insert(\n    \"Pride and Prejudice\".to_string(),\n    \"Very enjoyable.\".to_string(),\n);\nbook_reviews.insert(\n    \"The Adventures of Sherlock Holmes\".to_string(),\n    \"Eye lyked it alot.\".to_string(),\n);\n\n// Check for a specific one.\n// When collections store owned values (String), they can still be\n// queried using references (&str).\nif !book_reviews.contains_key(\"Les Misérables\") {\n    println!(\"We've got {} reviews, but Les Misérables ain't one.\",\n             book_reviews.len());\n}\n\n// oops, this review has a lot of spelling mistakes, let's delete it.\nbook_reviews.remove(\"The Adventures of Sherlock Holmes\");\n\n// Look up the values associated with some keys.\nlet to_find = [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"];\nfor &book in &to_find {\n    match book_reviews.get(book) {\n        Some(review) => println!(\"{book}: {review}\"),\n        None => println!(\"{book} is unreviewed.\")\n    }\n}\n\n// Look up the value for a key (will panic if the key is not found).\nprintln!(\"Review for Jane: {}\", book_reviews[\"Pride and Prejudice\"]);\n\n// Iterate over everything.\nfor (book, review) in &book_reviews {\n    println!(\"{book}: \\\"{review}\\\"\");\n}\n```\n\nA `HashMap` with a known list of items can be initialized from an array:\n\n```rust\nuse std::collections::HashMap;\n\nlet solar_distance = HashMap::from([\n    (\"Mercury\", 0.4),\n    (\"Venus\", 0.7),\n    (\"Earth\", 1.0),\n    (\"Mars\", 1.5),\n]);\n```\n\n`HashMap` implements an [`Entry` API](#method.entry), which allows\nfor complex methods of getting, setting, updating and removing keys and\ntheir values:\n\n```rust\nuse std::collections::HashMap;\n\n// type inference lets us omit an explicit type signature (which\n// would be `HashMap<&str, u8>` in this example).\nlet mut player_stats = HashMap::new();\n\nfn random_stat_buff() -> u8 {\n    // could actually return some random value here - let's just return\n    // some fixed value for now\n    42\n}\n\n// insert a key only if it doesn't already exist\nplayer_stats.entry(\"health\").or_insert(100);\n\n// insert a key using a function that provides a new value only if it\n// doesn't already exist\nplayer_stats.entry(\"defence\").or_insert_with(random_stat_buff);\n\n// update a key, guarding against the key possibly not being set\nlet stat = player_stats.entry(\"attack\").or_insert(100);\n*stat += random_stat_buff();\n\n// modify an entry before an insert with in-place mutation\nplayer_stats.entry(\"mana\").and_modify(|mana| *mana += 200).or_insert(100);\n```\n\nThe easiest way to use `HashMap` with a custom key type is to derive [`Eq`] and [`Hash`].\nWe must also derive [`PartialEq`].\n\n[`RefCell`]: crate::cell::RefCell\n[`Cell`]: crate::cell::Cell\n[`default`]: Default::default\n[`with_hasher`]: Self::with_hasher\n[`with_capacity_and_hasher`]: Self::with_capacity_and_hasher\n\n```rust\nuse std::collections::HashMap;\n\n#[derive(Hash, Eq, PartialEq, Debug)]\nstruct Viking {\n    name: String,\n    country: String,\n}\n\nimpl Viking {\n    /// Creates a new Viking.\n    fn new(name: &str, country: &str) -> Viking {\n        Viking { name: name.to_string(), country: country.to_string() }\n    }\n}\n\n// Use a HashMap to store the vikings' health points.\nlet vikings = HashMap::from([\n    (Viking::new(\"Einar\", \"Norway\"), 25),\n    (Viking::new(\"Olaf\", \"Denmark\"), 24),\n    (Viking::new(\"Harald\", \"Iceland\"), 12),\n]);\n\n// Use derived implementation to print the status of the vikings.\nfor (viking, health) in &vikings {\n    println!(\"{viking:?} has {health} hp\");\n}\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "HashMap",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "HashMap"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Hide",
      "kind": 22,
      "detail": "Hide",
      "documentation": {
        "kind": "markdown",
        "value": "A command that hides the terminal cursor.\n\n# Notes\n\n- Commands must be executed/queued for execution otherwise they do nothing."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Hide",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Hide"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Highlighter",
      "kind": 22,
      "detail": "Highlighter",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Highlighter",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Highlighter"
      },
      "additionalTextEdits": []
    },
    {
      "label": "InboundMessage",
      "kind": 13,
      "detail": "InboundMessage",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "InboundMessage",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "InboundMessage"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Info",
      "kind": 22,
      "detail": "Info",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Info",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Info"
      },
      "additionalTextEdits": []
    },
    {
      "label": "KeyAction",
      "kind": 13,
      "detail": "KeyAction",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "KeyAction",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "KeyAction"
      },
      "additionalTextEdits": []
    },
    {
      "label": "KeyCode",
      "kind": 13,
      "detail": "KeyCode",
      "documentation": {
        "kind": "markdown",
        "value": "Represents a key."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "KeyCode",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "KeyCode"
      },
      "additionalTextEdits": []
    },
    {
      "label": "KeyEvent",
      "kind": 22,
      "detail": "KeyEvent",
      "documentation": {
        "kind": "markdown",
        "value": "Represents a key event."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "KeyEvent",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "KeyEvent"
      },
      "additionalTextEdits": []
    },
    {
      "label": "KeyModifiers",
      "kind": 22,
      "detail": "KeyModifiers",
      "documentation": {
        "kind": "markdown",
        "value": "Represents key modifiers (shift, control, alt, etc.).\n\n**Note:** `SUPER`, `HYPER`, and `META` can only be read if\n[`KeyboardEnhancementFlags::DISAMBIGUATE_ESCAPE_CODES`] has been enabled with\n[`PushKeyboardEnhancementFlags`]."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "KeyModifiers",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "KeyModifiers"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Lazy",
      "kind": 22,
      "detail": "Lazy<{unknown}, {unknown}>",
      "documentation": {
        "kind": "markdown",
        "value": "A value which is initialized on the first access.\n\nThis type is thread-safe and can be used in statics.\n\n# Example\n\n```rust\nuse std::collections::HashMap;\n\nuse once_cell::sync::Lazy;\n\nstatic HASHMAP: Lazy<HashMap<i32, String>> = Lazy::new(|| {\n    println!(\"initializing\");\n    let mut m = HashMap::new();\n    m.insert(13, \"Spica\".to_string());\n    m.insert(74, \"Hoyten\".to_string());\n    m\n});\n\nfn main() {\n    println!(\"ready\");\n    std::thread::spawn(|| {\n        println!(\"{:?}\", HASHMAP.get(&13));\n    }).join().unwrap();\n    println!(\"{:?}\", HASHMAP.get(&74));\n\n    // Prints:\n    //   ready\n    //   initializing\n    //   Some(\"Spica\")\n    //   Some(\"Hoyten\")\n}\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Lazy",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Lazy"
      },
      "additionalTextEdits": []
    },
    {
      "label": "LspClient",
      "kind": 8,
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "LspClient",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "LspClient"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Mode",
      "kind": 13,
      "detail": "Mode",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Mode",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Mode"
      },
      "additionalTextEdits": []
    },
    {
      "label": "MouseButton",
      "kind": 13,
      "detail": "MouseButton",
      "documentation": {
        "kind": "markdown",
        "value": "Represents a mouse button."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "MouseButton",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "MouseButton"
      },
      "additionalTextEdits": []
    },
    {
      "label": "MouseEvent",
      "kind": 22,
      "detail": "MouseEvent",
      "documentation": {
        "kind": "markdown",
        "value": "Represents a mouse event.\n\n# Platform-specific Notes\n\n## Mouse Buttons\n\nSome platforms/terminals do not report mouse button for the\n`MouseEventKind::Up` and `MouseEventKind::Drag` events. `MouseButton::Left`\nis returned if we don't know which button was used.\n\n## Key Modifiers\n\nSome platforms/terminals does not report all key modifiers\ncombinations for all mouse event types. For example - macOS reports\n`Ctrl` + left mouse button click as a right mouse button click."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "MouseEvent",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "MouseEvent"
      },
      "additionalTextEdits": []
    },
    {
      "label": "MouseEventKind",
      "kind": 13,
      "detail": "MouseEventKind",
      "documentation": {
        "kind": "markdown",
        "value": "A mouse event kind.\n\n# Platform-specific Notes\n\n## Mouse Buttons\n\nSome platforms/terminals do not report mouse button for the\n`MouseEventKind::Up` and `MouseEventKind::Drag` events. `MouseButton::Left`\nis returned if we don't know which button was used."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "MouseEventKind",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "MouseEventKind"
      },
      "additionalTextEdits": []
    },
    {
      "label": "MoveTo",
      "kind": 22,
      "detail": "MoveTo",
      "documentation": {
        "kind": "markdown",
        "value": "A command that moves the terminal cursor to the given position (column, row).\n\n# Notes\n* Top left cell is represented as `0,0`.\n* Commands must be executed/queued for execution otherwise they do nothing."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "MoveTo",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "MoveTo"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Ordering",
      "kind": 13,
      "detail": "Ordering",
      "documentation": {
        "kind": "markdown",
        "value": "An `Ordering` is the result of a comparison between two values.\n\n# Examples\n\n```rust\nuse std::cmp::Ordering;\n\nassert_eq!(1.cmp(&2), Ordering::Less);\n\nassert_eq!(1.cmp(&1), Ordering::Equal);\n\nassert_eq!(2.cmp(&1), Ordering::Greater);\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Ordering",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Ordering"
      },
      "additionalTextEdits": []
    },
    {
      "label": "ParsedNotification",
      "kind": 13,
      "detail": "ParsedNotification",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "ParsedNotification",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "ParsedNotification"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Picker",
      "kind": 22,
      "detail": "Picker",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Picker",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Picker"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Pid",
      "kind": 22,
      "detail": "Pid",
      "documentation": {
        "kind": "markdown",
        "value": "Process identifier\n\nNewtype pattern around `pid_t` (which is just alias). It prevents bugs caused by accidentally\npassing wrong value."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Pid",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Pid"
      },
      "additionalTextEdits": []
    },
    {
      "label": "PluginRegistry",
      "kind": 22,
      "detail": "PluginRegistry",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "PluginRegistry",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "PluginRegistry"
      },
      "additionalTextEdits": []
    },
    {
      "label": "PluginRequest",
      "kind": 13,
      "detail": "PluginRequest",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "PluginRequest",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "PluginRequest"
      },
      "additionalTextEdits": []
    },
    {
      "label": "PluginResponse",
      "kind": 22,
      "detail": "PluginResponse",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "PluginResponse",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "PluginResponse"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Point",
      "kind": 22,
      "detail": "Point",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Point",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Point"
      },
      "additionalTextEdits": []
    },
    {
      "label": "QueueableCommand",
      "kind": 8,
      "documentation": {
        "kind": "markdown",
        "value": "An interface for types that can queue commands for further execution."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "QueueableCommand",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "QueueableCommand"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Rect",
      "kind": 22,
      "detail": "Rect",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Rect",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Rect"
      },
      "additionalTextEdits": []
    },
    {
      "label": "RenderBuffer",
      "kind": 22,
      "detail": "RenderBuffer",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "RenderBuffer",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "RenderBuffer"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Runtime",
      "kind": 22,
      "detail": "Runtime",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Runtime",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Runtime"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Serialize",
      "kind": 8,
      "documentation": {
        "kind": "markdown",
        "value": "A **data structure** that can be serialized into any data format supported\nby Serde.\n\nSerde provides `Serialize` implementations for many Rust primitive and\nstandard library types. The complete list is [here][crate::ser]. All of\nthese can be serialized using Serde out of the box.\n\nAdditionally, Serde provides a procedural macro called [`serde_derive`] to\nautomatically generate `Serialize` implementations for structs and enums in\nyour program. See the [derive section of the manual] for how to use this.\n\nIn rare cases it may be necessary to implement `Serialize` manually for some\ntype in your program. See the [Implementing `Serialize`] section of the\nmanual for more about this.\n\nThird-party crates may provide `Serialize` implementations for types that\nthey expose. For example the [`linked-hash-map`] crate provides a\n[`LinkedHashMap<K, V>`] type that is serializable by Serde because the crate\nprovides an implementation of `Serialize` for it.\n\n[Implementing `Serialize`]: https://serde.rs/impl-serialize.html\n[`LinkedHashMap<K, V>`]: https://docs.rs/linked-hash-map/*/linked_hash_map/struct.LinkedHashMap.html\n[`linked-hash-map`]: https://crates.io/crates/linked-hash-map\n[`serde_derive`]: https://crates.io/crates/serde_derive\n[derive section of the manual]: https://serde.rs/derive.html"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Serialize",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Serialize"
      },
      "additionalTextEdits": []
    },
    {
      "label": "ServerCapabilities",
      "kind": 22,
      "detail": "ServerCapabilities",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "ServerCapabilities",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "ServerCapabilities"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Show",
      "kind": 22,
      "detail": "Show",
      "documentation": {
        "kind": "markdown",
        "value": "A command that shows the terminal cursor.\n\n# Notes\n\n- Commands must be executed/queued for execution otherwise they do nothing."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Show",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Show"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Signal",
      "kind": 13,
      "detail": "Signal",
      "documentation": {
        "kind": "markdown",
        "value": "Types of operating system signals"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Signal",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Signal"
      },
      "additionalTextEdits": []
    },
    {
      "label": "StreamExt",
      "kind": 8,
      "documentation": {
        "kind": "markdown",
        "value": "An extension trait for `Stream`s that provides a variety of convenient\ncombinator functions."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "StreamExt",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "StreamExt"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Style",
      "kind": 22,
      "detail": "Style",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Style",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Style"
      },
      "additionalTextEdits": []
    },
    {
      "label": "StyleInfo",
      "kind": 22,
      "detail": "StyleInfo",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "StyleInfo",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "StyleInfo"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Theme",
      "kind": 22,
      "detail": "Theme",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Theme",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Theme"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Write",
      "kind": 8,
      "documentation": {
        "kind": "markdown",
        "value": "A trait for objects which are byte-oriented sinks.\n\nImplementors of the `Write` trait are sometimes called 'writers'.\n\nWriters are defined by two required methods, [`write`] and [`flush`]:\n\n* The [`write`] method will attempt to write some data into the object,\n  returning how many bytes were successfully written.\n\n* The [`flush`] method is useful for adapters and explicit buffers\n  themselves for ensuring that all buffered data has been pushed out to the\n  'true sink'.\n\nWriters are intended to be composable with one another. Many implementors\nthroughout [`std::io`] take and provide types which implement the `Write`\ntrait.\n\n[`write`]: Write::write\n[`flush`]: Write::flush\n[`std::io`]: self\n\n# Examples\n\n```rust\nuse std::io::prelude::*;\nuse std::fs::File;\n\nfn main() -> std::io::Result<()> {\n    let data = b\"some bytes\";\n\n    let mut pos = 0;\n    let mut buffer = File::create(\"foo.txt\")?;\n\n    while pos < data.len() {\n        let bytes_written = buffer.write(&data[pos..])?;\n        pos += bytes_written;\n    }\n    Ok(())\n}\n```\n\nThe trait also provides convenience methods like [`write_all`], which calls\n`write` in a loop until its entire input has been written.\n\n[`write_all`]: Write::write_all"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Write",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Write"
      },
      "additionalTextEdits": []
    },
    {
      "label": "adjust_color_brightness(…)",
      "kind": 3,
      "detail": "fn(Option<Color>, i32) -> Option<Color>",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "adjust_color_brightness",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "adjust_color_brightness(${1:color}, ${2:percentage})$0"
      },
      "additionalTextEdits": []
    },
    {
      "label": "blend_color(…)",
      "kind": 3,
      "detail": "fn(Color, Color) -> Color",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "blend_color",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "blend_color(${1:foreground}, ${2:background})$0"
      },
      "additionalTextEdits": []
    },
    {
      "label": "command",
      "kind": 9,
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "command",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "command"
      },
      "additionalTextEdits": []
    },
    {
      "label": "cursor",
      "kind": 9,
      "documentation": {
        "kind": "markdown",
        "value": "A module to work with the terminal cursor\n# Cursor\n\nThe `cursor` module provides functionality to work with the terminal cursor.\n\nThis documentation does not contain a lot of examples. The reason is that it's fairly\nobvious how to use this crate. Although, we do provide\n[examples](https://github.com/crossterm-rs/crossterm/tree/master/examples) repository\nto demonstrate the capabilities.\n\n## Examples\n\nCursor actions can be performed with commands.\nPlease have a look at [command documentation](../index.html#command-api) for a more detailed documentation.\n\n```rust\nuse std::io::{self, Write};\n\nuse crossterm::{\n    ExecutableCommand, execute,\n    cursor::{DisableBlinking, EnableBlinking, MoveTo, RestorePosition, SavePosition}\n};\n\nfn main() -> io::Result<()> {\n    // with macro\n    execute!(\n        io::stdout(),\n        SavePosition,\n        MoveTo(10, 10),\n        EnableBlinking,\n        DisableBlinking,\n        RestorePosition\n    );\n\n  // with function\n  io::stdout()\n    .execute(MoveTo(11,11))?\n    .execute(RestorePosition);\n\n Ok(())\n}\n```\n\nFor manual execution control check out [crossterm::queue](../macro.queue.html)."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "cursor",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "cursor"
      },
      "additionalTextEdits": []
    },
    {
      "label": "determine_style_for_position(…)",
      "kind": 3,
      "detail": "fn(&[StyleInfo], usize) -> Option<Style>",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "determine_style_for_position",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "determine_style_for_position(${1:style_info}, ${2:pos})$0"
      },
      "additionalTextEdits": []
    },
    {
      "label": "event",
      "kind": 9,
      "documentation": {
        "kind": "markdown",
        "value": "A module to read events.\n# Event\n\nThe `event` module provides the functionality to read keyboard, mouse and terminal resize events.\n\n* The [`read`](fn.read.html) function returns an [`Event`](enum.Event.html) immediately\n(if available) or blocks until an [`Event`](enum.Event.html) is available.\n\n* The [`poll`](fn.poll.html) function allows you to check if there is or isn't an [`Event`](enum.Event.html) available\nwithin the given period of time. In other words - if subsequent call to the [`read`](fn.read.html)\nfunction will block or not.\n\nIt's **not allowed** to call these functions from different threads or combine them with the\n[`EventStream`](struct.EventStream.html). You're allowed to either:\n\n* use the [`read`](fn.read.html) & [`poll`](fn.poll.html) functions on any, but same, thread\n* or the [`EventStream`](struct.EventStream.html).\n\n**Make sure to enable [raw mode](../terminal/index.html#raw-mode) in order for keyboard events to work properly**\n\n## Mouse Events\n\nMouse events are not enabled by default. You have to enable them with the\n[`EnableMouseCapture`](struct.EnableMouseCapture.html) command. See [Command API](../index.html#command-api)\nfor more information.\n\n## Examples\n\nBlocking read:\n\n```rust\nuse crossterm::event::{read, Event};\n\nfn print_events() -> std::io::Result<()> {\n    loop {\n        // `read()` blocks until an `Event` is available\n        match read()? {\n            Event::FocusGained => println!(\"FocusGained\"),\n            Event::FocusLost => println!(\"FocusLost\"),\n            Event::Key(event) => println!(\"{:?}\", event),\n            Event::Mouse(event) => println!(\"{:?}\", event),\n            #[cfg(feature = \"bracketed-paste\")]\n            Event::Paste(data) => println!(\"{:?}\", data),\n            Event::Resize(width, height) => println!(\"New size {}x{}\", width, height),\n        }\n    }\n    Ok(())\n}\n```\n\nNon-blocking read:\n\n```rust\nuse std::{time::Duration, io};\n\nuse crossterm::event::{poll, read, Event};\n\nfn print_events() -> io::Result<()> {\n    loop {\n        // `poll()` waits for an `Event` for a given time period\n        if poll(Duration::from_millis(500))? {\n            // It's guaranteed that the `read()` won't block when the `poll()`\n            // function returns `true`\n            match read()? {\n                Event::FocusGained => println!(\"FocusGained\"),\n                Event::FocusLost => println!(\"FocusLost\"),\n                Event::Key(event) => println!(\"{:?}\", event),\n                Event::Mouse(event) => println!(\"{:?}\", event),\n                #[cfg(feature = \"bracketed-paste\")]\n                Event::Paste(data) => println!(\"Pasted {:?}\", data),\n                Event::Resize(width, height) => println!(\"New size {}x{}\", width, height),\n            }\n        } else {\n            // Timeout expired and no `Event` is available\n        }\n    }\n    Ok(())\n}\n```\n\nCheck the [examples](https://github.com/crossterm-rs/crossterm/tree/master/examples) folder for more of\nthem (`event-*`)."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "event",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "event"
      },
      "additionalTextEdits": []
    },
    {
      "label": "format_mode_name(…)",
      "kind": 3,
      "detail": "fn(&Mode) -> String",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "format_mode_name",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "format_mode_name(${1:mode})$0"
      },
      "additionalTextEdits": []
    },
    {
      "label": "json!(…)",
      "kind": 3,
      "detail": "macro_rules! json",
      "documentation": {
        "kind": "markdown",
        "value": "Construct a `serde_json::Value` from a JSON literal.\n\n```rust\nlet value = json!({\n    \"code\": 200,\n    \"success\": true,\n    \"payload\": {\n        \"features\": [\n            \"serde\",\n            \"json\"\n        ],\n        \"homepage\": null\n    }\n});\n```\n\nVariables or expressions can be interpolated into the JSON literal. Any type\ninterpolated into an array element or object value must implement Serde's\n`Serialize` trait, while any type interpolated into a object key must\nimplement `Into<String>`. If the `Serialize` implementation of the\ninterpolated type decides to fail, or if the interpolated type contains a\nmap with non-string keys, the `json!` macro will panic.\n\n```rust\nlet code = 200;\nlet features = vec![\"serde\", \"json\"];\n\nlet value = json!({\n    \"code\": code,\n    \"success\": code == 200,\n    \"payload\": {\n        features[0]: features[1]\n    }\n});\n```\n\nTrailing commas are allowed inside both arrays and objects.\n\n```rust\nlet value = json!([\n    \"notice\",\n    \"the\",\n    \"trailing\",\n    \"comma -->\",\n]);\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "json!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "json!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "log!(…)",
      "kind": 3,
      "detail": "macro_rules! log",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "log!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "log!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "mem",
      "kind": 9,
      "documentation": {
        "kind": "markdown",
        "value": "Basic functions for dealing with memory.\n\nThis module contains functions for querying the size and alignment of\ntypes, initializing and manipulating memory."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "mem",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "mem"
      },
      "additionalTextEdits": []
    },
    {
      "label": "select! {…}",
      "kind": 3,
      "detail": "macro_rules! select",
      "documentation": {
        "kind": "markdown",
        "value": "Polls multiple futures and streams simultaneously, executing the branch\nfor the future that finishes first. If multiple futures are ready,\none will be pseudo-randomly selected at runtime. Futures directly\npassed to `select!` must be `Unpin` and implement `FusedFuture`.\n\nIf an expression which yields a `Future` is passed to `select!`\n(e.g. an `async fn` call) instead of a `Future` by name the `Unpin`\nrequirement is relaxed, since the macro will pin the resulting `Future`\non the stack. However the `Future` returned by the expression must\nstill implement `FusedFuture`.\n\nFutures and streams which are not already fused can be fused using the\n`.fuse()` method. Note, though, that fusing a future or stream directly\nin the call to `select!` will not be enough to prevent it from being\npolled after completion if the `select!` call is in a loop, so when\n`select!`ing in a loop, users should take care to `fuse()` outside of\nthe loop.\n\n`select!` can be used as an expression and will return the return\nvalue of the selected branch. For this reason the return type of every\nbranch in a `select!` must be the same.\n\nThis macro is only usable inside of async functions, closures, and blocks.\nIt is also gated behind the `async-await` feature of this library, which is\nactivated by default.\n\n# Examples\n\n```rust\nuse futures::future;\nuse futures::select;\nlet mut a = future::ready(4);\nlet mut b = future::pending::<()>();\n\nlet res = select! {\n    a_res = a => a_res + 1,\n    _ = b => 0,\n};\nassert_eq!(res, 5);\n```\n\n```rust\nuse futures::future;\nuse futures::stream::{self, StreamExt};\nuse futures::select;\nlet mut st = stream::iter(vec![2]).fuse();\nlet mut fut = future::pending::<()>();\n\nselect! {\n    x = st.next() => assert_eq!(Some(2), x),\n    _ = fut => panic!(),\n};\n```\n\nAs described earlier, `select` can directly select on expressions\nwhich return `Future`s - even if those do not implement `Unpin`:\n\n```rust\nuse futures::future::FutureExt;\nuse futures::select;\n\n// Calling the following async fn returns a Future which does not\n// implement Unpin\nasync fn async_identity_fn(arg: usize) -> usize {\n    arg\n}\n\nlet res = select! {\n    a_res = async_identity_fn(62).fuse() => a_res + 1,\n    b_res = async_identity_fn(13).fuse() => b_res,\n};\nassert!(res == 63 || res == 13);\n```\n\nIf a similar async function is called outside of `select` to produce\na `Future`, the `Future` must be pinned in order to be able to pass\nit to `select`. This can be achieved via `Box::pin` for pinning a\n`Future` on the heap or the `pin_mut!` macro for pinning a `Future`\non the stack.\n\n```rust\nuse futures::future::FutureExt;\nuse futures::select;\nuse futures::pin_mut;\n\n// Calling the following async fn returns a Future which does not\n// implement Unpin\nasync fn async_identity_fn(arg: usize) -> usize {\n    arg\n}\n\nlet fut_1 = async_identity_fn(1).fuse();\nlet fut_2 = async_identity_fn(2).fuse();\nlet mut fut_1 = Box::pin(fut_1); // Pins the Future on the heap\npin_mut!(fut_2); // Pins the Future on the stack\n\nlet res = select! {\n    a_res = fut_1 => a_res,\n    b_res = fut_2 => b_res,\n};\nassert!(res == 1 || res == 2);\n```\n\n`select` also accepts a `complete` branch and a `default` branch.\n`complete` will run if all futures and streams have already been\nexhausted. `default` will run if no futures or streams are\nimmediately ready. `complete` takes priority over `default` in\nthe case where all futures have completed.\nA motivating use-case for passing `Future`s by name as well as for\n`complete` blocks is to call `select!` in a loop, which is\ndemonstrated in the following example:\n\n```rust\nuse futures::future;\nuse futures::select;\nlet mut a_fut = future::ready(4);\nlet mut b_fut = future::ready(6);\nlet mut total = 0;\n\nloop {\n    select! {\n        a = a_fut => total += a,\n        b = b_fut => total += b,\n        complete => break,\n        default => panic!(), // never runs (futures run first, then complete)\n    };\n}\nassert_eq!(total, 10);\n```\n\nNote that the futures that have been matched over can still be mutated\nfrom inside the `select!` block's branches. This can be used to implement\nmore complex behavior such as timer resets or writing into the head of\na stream."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "select!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "select! {$0}"
      },
      "additionalTextEdits": []
    },
    {
      "label": "signal",
      "kind": 9,
      "documentation": {
        "kind": "markdown",
        "value": "Operating system signals."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "signal",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "signal"
      },
      "additionalTextEdits": []
    },
    {
      "label": "stdout()",
      "kind": 3,
      "detail": "fn() -> Stdout",
      "documentation": {
        "kind": "markdown",
        "value": "Constructs a new handle to the standard output of the current process.\n\nEach handle returned is a reference to a shared global buffer whose access\nis synchronized via a mutex. If you need more explicit control over\nlocking, see the [`Stdout::lock`] method.\n\n### Note: Windows Portability Considerations\n\nWhen operating in a console, the Windows implementation of this stream does not support\nnon-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\nan error.\n\nIn a process with a detached console, such as one using\n`#![windows_subsystem = \"windows\"]`, or in a child process spawned from such a process,\nthe contained handle will be null. In such cases, the standard library's `Read` and\n`Write` will do nothing and silently succeed. All other I/O operations, via the\nstandard library or via raw Windows API calls, will fail.\n\n# Examples\n\nUsing implicit synchronization:\n\n```rust\nuse std::io::{self, Write};\n\nfn main() -> io::Result<()> {\n    io::stdout().write_all(b\"hello world\")?;\n\n    Ok(())\n}\n```\n\nUsing explicit synchronization:\n\n```rust\nuse std::io::{self, Write};\n\nfn main() -> io::Result<()> {\n    let stdout = io::stdout();\n    let mut handle = stdout.lock();\n\n    handle.write_all(b\"hello world\")?;\n\n    Ok(())\n}\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "stdout",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "stdout()$0"
      },
      "additionalTextEdits": []
    },
    {
      "label": "terminal",
      "kind": 9,
      "documentation": {
        "kind": "markdown",
        "value": "A module to work with the terminal.\n# Terminal\n\nThe `terminal` module provides functionality to work with the terminal.\n\nThis documentation does not contain a lot of examples. The reason is that it's fairly\nobvious how to use this crate. Although, we do provide\n[examples](https://github.com/crossterm-rs/crossterm/tree/master/examples) repository\nto demonstrate the capabilities.\n\nMost terminal actions can be performed with commands.\nPlease have a look at [command documentation](../index.html#command-api) for a more detailed documentation.\n\n## Screen Buffer\n\nA screen buffer is a two-dimensional array of character\nand color data which is displayed in a terminal screen.\n\nThe terminal has several of those buffers and is able to switch between them.\nThe default screen in which you work is called the 'main screen'.\nThe other screens are called the 'alternative screen'.\n\nIt is important to understand that crossterm does not yet support creating screens,\nor switch between more than two buffers, and only offers the ability to change\nbetween the 'alternate' and 'main screen'.\n\n### Alternate Screen\n\nBy default, you will be working on the main screen.\nThere is also another screen called the 'alternative' screen.\nThis screen is slightly different from the main screen.\nFor example, it has the exact dimensions of the terminal window,\nwithout any scroll-back area.\n\nCrossterm offers the possibility to switch to the 'alternative' screen,\nmake some modifications, and move back to the 'main' screen again.\nThe main screen will stay intact and will have the original data as we performed all\noperations on the alternative screen.\n\nAn good example of this is Vim.\nWhen it is launched from bash, a whole new buffer is used to modify a file.\nThen, when the modification is finished, it closes again and continues on the main screen.\n\n### Raw Mode\n\nBy default, the terminal functions in a certain way.\nFor example, it will move the cursor to the beginning of the next line when the input hits the end of a line.\nOr that the backspace is interpreted for character removal.\n\nSometimes these default modes are irrelevant,\nand in this case, we can turn them off.\nThis is what happens when you enable raw modes.\n\nThose modes will be set when enabling raw modes:\n\n- Input will not be forwarded to screen\n- Input will not be processed on enter press\n- Input will not be line buffered (input sent byte-by-byte to input buffer)\n- Special keys like backspace and CTRL+C will not be processed by terminal driver\n- New line character will not be processed therefore `println!` can't be used, use `write!` instead\n\nRaw mode can be enabled/disabled with the [enable_raw_mode](terminal::enable_raw_mode) and [disable_raw_mode](terminal::disable_raw_mode) functions.\n\n## Examples\n\n```rust\nuse std::io::{self, Write};\nuse crossterm::{execute, terminal::{ScrollUp, SetSize, size}};\n\nfn main() -> io::Result<()> {\n    let (cols, rows) = size()?;\n    // Resize terminal and scroll up.\n    execute!(\n        io::stdout(),\n        SetSize(10, 10),\n        ScrollUp(5)\n    )?;\n\n    // Be a good citizen, cleanup\n    execute!(io::stdout(), SetSize(cols, rows))?;\n    Ok(())\n}\n```\n\nFor manual execution control check out [crossterm::queue](../macro.queue.html)."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "terminal",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "terminal"
      },
      "additionalTextEdits": []
    },
    {
      "label": "test",
      "kind": 9,
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "test",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "test"
      },
      "additionalTextEdits": []
    },
    {
      "label": "assert!(…)",
      "kind": 3,
      "detail": "macro_rules! assert",
      "documentation": {
        "kind": "markdown",
        "value": "Asserts that a boolean expression is `true` at runtime.\n\nThis will invoke the [`panic!`] macro if the provided expression cannot be\nevaluated to `true` at runtime.\n\n# Uses\n\nAssertions are always checked in both debug and release builds, and cannot\nbe disabled. See [`debug_assert!`] for assertions that are not enabled in\nrelease builds by default.\n\nUnsafe code may rely on `assert!` to enforce run-time invariants that, if\nviolated could lead to unsafety.\n\nOther use-cases of `assert!` include testing and enforcing run-time\ninvariants in safe code (whose violation cannot result in unsafety).\n\n# Custom Messages\n\nThis macro has a second form, where a custom panic message can\nbe provided with or without arguments for formatting. See [`std::fmt`]\nfor syntax for this form. Expressions used as format arguments will only\nbe evaluated if the assertion fails.\n\n[`std::fmt`]: ../std/fmt/index.html\n\n# Examples\n\n```rust\n// the panic message for these assertions is the stringified value of the\n// expression given.\nassert!(true);\n\nfn some_computation() -> bool { true } // a very simple function\n\nassert!(some_computation());\n\n// assert with a custom message\nlet x = true;\nassert!(x, \"x wasn't true!\");\n\nlet a = 3; let b = 27;\nassert!(a + b == 30, \"a = {}, b = {}\", a, b);\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "assert!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "assert!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "assert_eq!(…)",
      "kind": 3,
      "detail": "macro_rules! assert_eq",
      "documentation": {
        "kind": "markdown",
        "value": "Asserts that two expressions are equal to each other (using [`PartialEq`]).\n\nAssertions are always checked in both debug and release builds, and cannot\nbe disabled. See [`debug_assert_eq!`] for assertions that are disabled in\nrelease builds by default.\n\n[`debug_assert_eq!`]: crate::debug_assert_eq\n\nOn panic, this macro will print the values of the expressions with their\ndebug representations.\n\nLike [`assert!`], this macro has a second form, where a custom\npanic message can be provided.\n\n# Examples\n\n```rust\nlet a = 3;\nlet b = 1 + 2;\nassert_eq!(a, b);\n\nassert_eq!(a, b, \"we are testing addition with {} and {}\", a, b);\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "assert_eq!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "assert_eq!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "assert_ne!(…)",
      "kind": 3,
      "detail": "macro_rules! assert_ne",
      "documentation": {
        "kind": "markdown",
        "value": "Asserts that two expressions are not equal to each other (using [`PartialEq`]).\n\nAssertions are always checked in both debug and release builds, and cannot\nbe disabled. See [`debug_assert_ne!`] for assertions that are disabled in\nrelease builds by default.\n\n[`debug_assert_ne!`]: crate::debug_assert_ne\n\nOn panic, this macro will print the values of the expressions with their\ndebug representations.\n\nLike [`assert!`], this macro has a second form, where a custom\npanic message can be provided.\n\n# Examples\n\n```rust\nlet a = 3;\nlet b = 2;\nassert_ne!(a, b);\n\nassert_ne!(a, b, \"we are testing that the values are not equal\");\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "assert_ne!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "assert_ne!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "cfg!(…)",
      "kind": 3,
      "detail": "macro_rules! cfg",
      "documentation": {
        "kind": "markdown",
        "value": "Evaluates boolean combinations of configuration flags at compile-time.\n\nIn addition to the `#[cfg]` attribute, this macro is provided to allow\nboolean expression evaluation of configuration flags. This frequently\nleads to less duplicated code.\n\nThe syntax given to this macro is the same syntax as the [`cfg`]\nattribute.\n\n`cfg!`, unlike `#[cfg]`, does not remove any code and only evaluates to true or false. For\nexample, all blocks in an if/else expression need to be valid when `cfg!` is used for\nthe condition, regardless of what `cfg!` is evaluating.\n\n[`cfg`]: ../reference/conditional-compilation.html#the-cfg-attribute\n\n# Examples\n\n```rust\nlet my_directory = if cfg!(windows) {\n    \"windows-specific-directory\"\n} else {\n    \"unix-directory\"\n};\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "cfg!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "cfg!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "column!(…)",
      "kind": 3,
      "detail": "macro_rules! column",
      "documentation": {
        "kind": "markdown",
        "value": "Expands to the column number at which it was invoked.\n\nWith [`line!`] and [`file!`], these macros provide debugging information for\ndevelopers about the location within the source.\n\nThe expanded expression has type `u32` and is 1-based, so the first column\nin each line evaluates to 1, the second to 2, etc. This is consistent\nwith error messages by common compilers or popular editors.\nThe returned column is *not necessarily* the line of the `column!` invocation itself,\nbut rather the first macro invocation leading up to the invocation\nof the `column!` macro.\n\n# Examples\n\n```rust\nlet current_col = column!();\nprintln!(\"defined on column: {current_col}\");\n```\n\n`column!` counts Unicode code points, not bytes or graphemes. As a result, the first two\ninvocations return the same value, but the third does not.\n\n```rust\nlet a = (\"foobar\", column!()).1;\nlet b = (\"人之初性本善\", column!()).1;\nlet c = (\"f̅o̅o̅b̅a̅r̅\", column!()).1; // Uses combining overline (U+0305)\n\nassert_eq!(a, b);\nassert_ne!(b, c);\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "column!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "column!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "compile_error!(…)",
      "kind": 3,
      "detail": "macro_rules! compile_error",
      "documentation": {
        "kind": "markdown",
        "value": "Causes compilation to fail with the given error message when encountered.\n\nThis macro should be used when a crate uses a conditional compilation strategy to provide\nbetter error messages for erroneous conditions. It's the compiler-level form of [`panic!`],\nbut emits an error during *compilation* rather than at *runtime*.\n\n# Examples\n\nTwo such examples are macros and `#[cfg]` environments.\n\nEmit a better compiler error if a macro is passed invalid values. Without the final branch,\nthe compiler would still emit an error, but the error's message would not mention the two\nvalid values.\n\n```rust\nmacro_rules! give_me_foo_or_bar {\n    (foo) => {};\n    (bar) => {};\n    ($x:ident) => {\n        compile_error!(\"This macro only accepts `foo` or `bar`\");\n    }\n}\n\ngive_me_foo_or_bar!(neither);\n// ^ will fail at compile time with message \"This macro only accepts `foo` or `bar`\"\n```\n\nEmit a compiler error if one of a number of features isn't available.\n\n```rust\n#[cfg(not(any(feature = \"foo\", feature = \"bar\")))]\ncompile_error!(\"Either feature \\\"foo\\\" or \\\"bar\\\" must be enabled for this crate.\");\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "compile_error!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "compile_error!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "concat!(…)",
      "kind": 3,
      "detail": "macro_rules! concat",
      "documentation": {
        "kind": "markdown",
        "value": "Concatenates literals into a static string slice.\n\nThis macro takes any number of comma-separated literals, yielding an\nexpression of type `&'static str` which represents all of the literals\nconcatenated left-to-right.\n\nInteger and floating point literals are [stringified](core::stringify) in order to be\nconcatenated.\n\n# Examples\n\n```rust\nlet s = concat!(\"test\", 10, 'b', true);\nassert_eq!(s, \"test10btrue\");\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "concat!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "concat!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "dbg!(…)",
      "kind": 3,
      "detail": "macro_rules! dbg",
      "documentation": {
        "kind": "markdown",
        "value": "Prints and returns the value of a given expression for quick and dirty\ndebugging.\n\nAn example:\n\n```rust\nlet a = 2;\nlet b = dbg!(a * 2) + 1;\n//      ^-- prints: [src/main.rs:2:9] a * 2 = 4\nassert_eq!(b, 5);\n```\n\nThe macro works by using the `Debug` implementation of the type of\nthe given expression to print the value to [stderr] along with the\nsource location of the macro invocation as well as the source code\nof the expression.\n\nInvoking the macro on an expression moves and takes ownership of it\nbefore returning the evaluated expression unchanged. If the type\nof the expression does not implement `Copy` and you don't want\nto give up ownership, you can instead borrow with `dbg!(&expr)`\nfor some expression `expr`.\n\nThe `dbg!` macro works exactly the same in release builds.\nThis is useful when debugging issues that only occur in release\nbuilds or when debugging in release mode is significantly faster.\n\nNote that the macro is intended as a debugging tool and therefore you\nshould avoid having uses of it in version control for long periods\n(other than in tests and similar).\nDebug output from production code is better done with other facilities\nsuch as the [`debug!`] macro from the [`log`] crate.\n\n# Stability\n\nThe exact output printed by this macro should not be relied upon\nand is subject to future changes.\n\n# Panics\n\nPanics if writing to `io::stderr` fails.\n\n# Further examples\n\nWith a method call:\n\n```rust\nfn foo(n: usize) {\n    if let Some(_) = dbg!(n.checked_sub(4)) {\n        // ...\n    }\n}\n\nfoo(3)\n```\n\nThis prints to [stderr]:\n\n```text,ignore\n[src/main.rs:2:22] n.checked_sub(4) = None\n```\n\nNaive factorial implementation:\n\n```rust\nfn factorial(n: u32) -> u32 {\n    if dbg!(n <= 1) {\n        dbg!(1)\n    } else {\n        dbg!(n * factorial(n - 1))\n    }\n}\n\ndbg!(factorial(4));\n```\n\nThis prints to [stderr]:\n\n```text,ignore\n[src/main.rs:2:8] n <= 1 = false\n[src/main.rs:2:8] n <= 1 = false\n[src/main.rs:2:8] n <= 1 = false\n[src/main.rs:2:8] n <= 1 = true\n[src/main.rs:3:9] 1 = 1\n[src/main.rs:7:9] n * factorial(n - 1) = 2\n[src/main.rs:7:9] n * factorial(n - 1) = 6\n[src/main.rs:7:9] n * factorial(n - 1) = 24\n[src/main.rs:9:1] factorial(4) = 24\n```\n\nThe `dbg!(..)` macro moves the input:\n\n```rust\n/// A wrapper around `usize` which importantly is not Copyable.\n#[derive(Debug)]\nstruct NoCopy(usize);\n\nlet a = NoCopy(42);\nlet _ = dbg!(a); // <-- `a` is moved here.\nlet _ = dbg!(a); // <-- `a` is moved again; error!\n```\n\nYou can also use `dbg!()` without a value to just print the\nfile and line whenever it's reached.\n\nFinally, if you want to `dbg!(..)` multiple values, it will treat them as\na tuple (and return it, too):\n\n```rust\nassert_eq!(dbg!(1usize, 2u32), (1, 2));\n```\n\nHowever, a single argument with a trailing comma will still not be treated\nas a tuple, following the convention of ignoring trailing commas in macro\ninvocations. You can use a 1-tuple directly if you need one:\n\n```rust\nassert_eq!(1, dbg!(1u32,)); // trailing comma ignored\nassert_eq!((1,), dbg!((1u32,))); // 1-tuple\n```\n\n[stderr]: https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)\n[`debug!`]: https://docs.rs/log/*/log/macro.debug.html\n[`log`]: https://crates.io/crates/log"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "dbg!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "dbg!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "debug_assert!(…)",
      "kind": 3,
      "detail": "macro_rules! debug_assert",
      "documentation": {
        "kind": "markdown",
        "value": "Asserts that a boolean expression is `true` at runtime.\n\nThis will invoke the [`panic!`] macro if the provided expression cannot be\nevaluated to `true` at runtime.\n\nLike [`assert!`], this macro also has a second version, where a custom panic\nmessage can be provided.\n\n# Uses\n\nUnlike [`assert!`], `debug_assert!` statements are only enabled in non\noptimized builds by default. An optimized build will not execute\n`debug_assert!` statements unless `-C debug-assertions` is passed to the\ncompiler. This makes `debug_assert!` useful for checks that are too\nexpensive to be present in a release build but may be helpful during\ndevelopment. The result of expanding `debug_assert!` is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to keep\nrunning, which might have unexpected consequences but does not introduce\nunsafety as long as this only happens in safe code. The performance cost\nof assertions, however, is not measurable in general. Replacing [`assert!`]\nwith `debug_assert!` is thus only encouraged after thorough profiling, and\nmore importantly, only in safe code!\n\n# Examples\n\n```rust\n// the panic message for these assertions is the stringified value of the\n// expression given.\ndebug_assert!(true);\n\nfn some_expensive_computation() -> bool { true } // a very simple function\ndebug_assert!(some_expensive_computation());\n\n// assert with a custom message\nlet x = true;\ndebug_assert!(x, \"x wasn't true!\");\n\nlet a = 3; let b = 27;\ndebug_assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "debug_assert!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "debug_assert!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "debug_assert_eq!(…)",
      "kind": 3,
      "detail": "macro_rules! debug_assert_eq",
      "documentation": {
        "kind": "markdown",
        "value": "Asserts that two expressions are equal to each other.\n\nOn panic, this macro will print the values of the expressions with their\ndebug representations.\n\nUnlike [`assert_eq!`], `debug_assert_eq!` statements are only enabled in non\noptimized builds by default. An optimized build will not execute\n`debug_assert_eq!` statements unless `-C debug-assertions` is passed to the\ncompiler. This makes `debug_assert_eq!` useful for checks that are too\nexpensive to be present in a release build but may be helpful during\ndevelopment. The result of expanding `debug_assert_eq!` is always type checked.\n\n# Examples\n\n```rust\nlet a = 3;\nlet b = 1 + 2;\ndebug_assert_eq!(a, b);\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "debug_assert_eq!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "debug_assert_eq!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "debug_assert_ne!(…)",
      "kind": 3,
      "detail": "macro_rules! debug_assert_ne",
      "documentation": {
        "kind": "markdown",
        "value": "Asserts that two expressions are not equal to each other.\n\nOn panic, this macro will print the values of the expressions with their\ndebug representations.\n\nUnlike [`assert_ne!`], `debug_assert_ne!` statements are only enabled in non\noptimized builds by default. An optimized build will not execute\n`debug_assert_ne!` statements unless `-C debug-assertions` is passed to the\ncompiler. This makes `debug_assert_ne!` useful for checks that are too\nexpensive to be present in a release build but may be helpful during\ndevelopment. The result of expanding `debug_assert_ne!` is always type checked.\n\n# Examples\n\n```rust\nlet a = 3;\nlet b = 2;\ndebug_assert_ne!(a, b);\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "debug_assert_ne!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "debug_assert_ne!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "env!(…)",
      "kind": 3,
      "detail": "macro_rules! env",
      "documentation": {
        "kind": "markdown",
        "value": "Inspects an environment variable at compile time.\n\nThis macro will expand to the value of the named environment variable at\ncompile time, yielding an expression of type `&'static str`. Use\n[`std::env::var`] instead if you want to read the value at runtime.\n\n[`std::env::var`]: ../std/env/fn.var.html\n\nIf the environment variable is not defined, then a compilation error\nwill be emitted. To not emit a compile error, use the [`option_env!`]\nmacro instead. A compilation error will also be emitted if the\nenvironment variable is not a valid Unicode string.\n\n# Examples\n\n```rust\nlet path: &'static str = env!(\"PATH\");\nprintln!(\"the $PATH variable at the time of compiling was: {path}\");\n```\n\nYou can customize the error message by passing a string as the second\nparameter:\n\n```rust\nlet doc: &'static str = env!(\"documentation\", \"what's that?!\");\n```\n\nIf the `documentation` environment variable is not defined, you'll get\nthe following error:\n\n```text\nerror: what's that?!\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "env!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "env!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "eprint!(…)",
      "kind": 3,
      "detail": "macro_rules! eprint",
      "documentation": {
        "kind": "markdown",
        "value": "Prints to the standard error.\n\nEquivalent to the [`print!`] macro, except that output goes to\n[`io::stderr`] instead of [`io::stdout`]. See [`print!`] for\nexample usage.\n\nUse `eprint!` only for error and progress messages. Use `print!`\ninstead for the primary output of your program.\n\n[`io::stderr`]: crate::io::stderr\n[`io::stdout`]: crate::io::stdout\n\nSee [the formatting documentation in `std::fmt`](../std/fmt/index.html)\nfor details of the macro argument syntax.\n\n# Panics\n\nPanics if writing to `io::stderr` fails.\n\nWriting to non-blocking stderr can cause an error, which will lead\nthis macro to panic.\n\n# Examples\n\n```rust\neprint!(\"Error: Could not complete task\");\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "eprint!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "eprint!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "eprintln!(…)",
      "kind": 3,
      "detail": "macro_rules! eprintln",
      "documentation": {
        "kind": "markdown",
        "value": "Prints to the standard error, with a newline.\n\nEquivalent to the [`println!`] macro, except that output goes to\n[`io::stderr`] instead of [`io::stdout`]. See [`println!`] for\nexample usage.\n\nUse `eprintln!` only for error and progress messages. Use `println!`\ninstead for the primary output of your program.\n\nSee [the formatting documentation in `std::fmt`](../std/fmt/index.html)\nfor details of the macro argument syntax.\n\n[`io::stderr`]: crate::io::stderr\n[`io::stdout`]: crate::io::stdout\n[`println!`]: crate::println\n\n# Panics\n\nPanics if writing to `io::stderr` fails.\n\nWriting to non-blocking stderr can cause an error, which will lead\nthis macro to panic.\n\n# Examples\n\n```rust\neprintln!(\"Error: Could not complete task\");\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "eprintln!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "eprintln!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "file!(…)",
      "kind": 3,
      "detail": "macro_rules! file",
      "documentation": {
        "kind": "markdown",
        "value": "Expands to the file name in which it was invoked.\n\nWith [`line!`] and [`column!`], these macros provide debugging information for\ndevelopers about the location within the source.\n\nThe expanded expression has type `&'static str`, and the returned file\nis not the invocation of the `file!` macro itself, but rather the\nfirst macro invocation leading up to the invocation of the `file!`\nmacro.\n\n# Examples\n\n```rust\nlet this_file = file!();\nprintln!(\"defined in file: {this_file}\");\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "file!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "file!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "format!(…)",
      "kind": 3,
      "detail": "macro_rules! format",
      "documentation": {
        "kind": "markdown",
        "value": "Creates a `String` using interpolation of runtime expressions.\n\nThe first argument `format!` receives is a format string. This must be a string\nliteral. The power of the formatting string is in the `{}`s contained.\nAdditional parameters passed to `format!` replace the `{}`s within the\nformatting string in the order given unless named or positional parameters\nare used.\n\nSee [the formatting syntax documentation in `std::fmt`](../std/fmt/index.html)\nfor details.\n\nA common use for `format!` is concatenation and interpolation of strings.\nThe same convention is used with [`print!`] and [`write!`] macros,\ndepending on the intended destination of the string; all these macros internally use [`format_args!`].\n\nTo convert a single value to a string, use the [`to_string`] method. This\nwill use the [`Display`] formatting trait.\n\nTo concatenate literals into a `&'static str`, use the [`concat!`] macro.\n\n[`print!`]: ../std/macro.print.html\n[`write!`]: core::write\n[`format_args!`]: core::format_args\n[`to_string`]: crate::string::ToString\n[`Display`]: core::fmt::Display\n[`concat!`]: core::concat\n\n# Panics\n\n`format!` panics if a formatting trait implementation returns an error.\nThis indicates an incorrect implementation\nsince `fmt::Write for String` never returns an error itself.\n\n# Examples\n\n```rust\nformat!(\"test\");                             // => \"test\"\nformat!(\"hello {}\", \"world!\");               // => \"hello world!\"\nformat!(\"x = {}, y = {val}\", 10, val = 30);  // => \"x = 10, y = 30\"\nlet (x, y) = (1, 2);\nformat!(\"{x} + {y} = 3\");                    // => \"1 + 2 = 3\"\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "format!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "format!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "format_args!(…)",
      "kind": 3,
      "detail": "macro_rules! format_args",
      "documentation": {
        "kind": "markdown",
        "value": "Constructs parameters for the other string-formatting macros.\n\nThis macro functions by taking a formatting string literal containing\n`{}` for each additional argument passed. `format_args!` prepares the\nadditional parameters to ensure the output can be interpreted as a string\nand canonicalizes the arguments into a single type. Any value that implements\nthe [`Display`] trait can be passed to `format_args!`, as can any\n[`Debug`] implementation be passed to a `{:?}` within the formatting string.\n\nThis macro produces a value of type [`fmt::Arguments`]. This value can be\npassed to the macros within [`std::fmt`] for performing useful redirection.\nAll other formatting macros ([`format!`], [`write!`], [`println!`], etc) are\nproxied through this one. `format_args!`, unlike its derived macros, avoids\nheap allocations.\n\nYou can use the [`fmt::Arguments`] value that `format_args!` returns\nin `Debug` and `Display` contexts as seen below. The example also shows\nthat `Debug` and `Display` format to the same thing: the interpolated\nformat string in `format_args!`.\n\n```rust\nlet debug = format!(\"{:?}\", format_args!(\"{} foo {:?}\", 1, 2));\nlet display = format!(\"{}\", format_args!(\"{} foo {:?}\", 1, 2));\nassert_eq!(\"1 foo 2\", display);\nassert_eq!(display, debug);\n```\n\nSee [the formatting documentation in `std::fmt`](../std/fmt/index.html)\nfor details of the macro argument syntax, and further information.\n\n[`Display`]: crate::fmt::Display\n[`Debug`]: crate::fmt::Debug\n[`fmt::Arguments`]: crate::fmt::Arguments\n[`std::fmt`]: ../std/fmt/index.html\n[`format!`]: ../std/macro.format.html\n[`println!`]: ../std/macro.println.html\n\n# Examples\n\n```rust\nuse std::fmt;\n\nlet s = fmt::format(format_args!(\"hello {}\", \"world\"));\nassert_eq!(s, format!(\"hello {}\", \"world\"));\n```\n\n# Lifetime limitation\n\nExcept when no formatting arguments are used,\nthe produced `fmt::Arguments` value borrows temporary values,\nwhich means it can only be used within the same expression\nand cannot be stored for later use.\nThis is a known limitation, see [#92698](https://github.com/rust-lang/rust/issues/92698)."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "format_args!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "format_args!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "include!(…)",
      "kind": 3,
      "detail": "macro_rules! include",
      "documentation": {
        "kind": "markdown",
        "value": "Parses a file as an expression or an item according to the context.\n\n**Warning**: For multi-file Rust projects, the `include!` macro is probably not what you\nare looking for. Usually, multi-file Rust projects use\n[modules](https://doc.rust-lang.org/reference/items/modules.html). Multi-file projects and\nmodules are explained in the Rust-by-Example book\n[here](https://doc.rust-lang.org/rust-by-example/mod/split.html) and the module system is\nexplained in the Rust Book\n[here](https://doc.rust-lang.org/book/ch07-02-defining-modules-to-control-scope-and-privacy.html).\n\nThe included file is placed in the surrounding code\n[unhygienically](https://doc.rust-lang.org/reference/macros-by-example.html#hygiene). If\nthe included file is parsed as an expression and variables or functions share names across\nboth files, it could result in variables or functions being different from what the\nincluded file expected.\n\nThe included file is located relative to the current file (similarly to how modules are\nfound). The provided path is interpreted in a platform-specific way at compile time. So,\nfor instance, an invocation with a Windows path containing backslashes `\\` would not\ncompile correctly on Unix.\n\n# Uses\n\nThe `include!` macro is primarily used for two purposes. It is used to include\ndocumentation that is written in a separate file and it is used to include [build artifacts\nusually as a result from the `build.rs`\nscript](https://doc.rust-lang.org/cargo/reference/build-scripts.html#outputs-of-the-build-script).\n\nWhen using the `include` macro to include stretches of documentation, remember that the\nincluded file still needs to be a valid Rust syntax. It is also possible to\nuse the [`include_str`] macro as `#![doc = include_str!(\"...\")]` (at the module level) or\n`#[doc = include_str!(\"...\")]` (at the item level) to include documentation from a plain\ntext or markdown file.\n\n# Examples\n\nAssume there are two files in the same directory with the following contents:\n\nFile 'monkeys.in':\n\n```rust\n['🙈', '🙊', '🙉']\n    .iter()\n    .cycle()\n    .take(6)\n    .collect::<String>()\n```\n\nFile 'main.rs':\n\n```rust\nfn main() {\n    let my_string = include!(\"monkeys.in\");\n    assert_eq!(\"🙈🙊🙉🙈🙊🙉\", my_string);\n    println!(\"{my_string}\");\n}\n```\n\nCompiling 'main.rs' and running the resulting binary will print\n\"🙈🙊🙉🙈🙊🙉\"."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "include!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "include!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "include_bytes!(…)",
      "kind": 3,
      "detail": "macro_rules! include_bytes",
      "documentation": {
        "kind": "markdown",
        "value": "Includes a file as a reference to a byte array.\n\nThe file is located relative to the current file (similarly to how\nmodules are found). The provided path is interpreted in a platform-specific\nway at compile time. So, for instance, an invocation with a Windows path\ncontaining backslashes `\\` would not compile correctly on Unix.\n\nThis macro will yield an expression of type `&'static [u8; N]` which is\nthe contents of the file.\n\n# Examples\n\nAssume there are two files in the same directory with the following\ncontents:\n\nFile 'spanish.in':\n\n```text\nadiós\n```\n\nFile 'main.rs':\n\n```rust\nfn main() {\n    let bytes = include_bytes!(\"spanish.in\");\n    assert_eq!(bytes, b\"adi\\xc3\\xb3s\\n\");\n    print!(\"{}\", String::from_utf8_lossy(bytes));\n}\n```\n\nCompiling 'main.rs' and running the resulting binary will print \"adiós\"."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "include_bytes!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "include_bytes!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "include_str!(…)",
      "kind": 3,
      "detail": "macro_rules! include_str",
      "documentation": {
        "kind": "markdown",
        "value": "Includes a UTF-8 encoded file as a string.\n\nThe file is located relative to the current file (similarly to how\nmodules are found). The provided path is interpreted in a platform-specific\nway at compile time. So, for instance, an invocation with a Windows path\ncontaining backslashes `\\` would not compile correctly on Unix.\n\nThis macro will yield an expression of type `&'static str` which is the\ncontents of the file.\n\n# Examples\n\nAssume there are two files in the same directory with the following\ncontents:\n\nFile 'spanish.in':\n\n```text\nadiós\n```\n\nFile 'main.rs':\n\n```rust\nfn main() {\n    let my_str = include_str!(\"spanish.in\");\n    assert_eq!(my_str, \"adiós\\n\");\n    print!(\"{my_str}\");\n}\n```\n\nCompiling 'main.rs' and running the resulting binary will print \"adiós\"."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "include_str!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "include_str!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "is_x86_feature_detected!(…)",
      "kind": 3,
      "detail": "macro_rules! is_x86_feature_detected",
      "documentation": {
        "kind": "markdown",
        "value": "A macro to test at *runtime* whether a CPU feature is available on\nx86/x86-64 platforms.\n\nThis macro is provided in the standard library and will detect at runtime\nwhether the specified CPU feature is detected. This does **not** resolve at\ncompile time unless the specified feature is already enabled for the entire\ncrate. Runtime detection currently relies mostly on the `cpuid` instruction.\n\nThis macro only takes one argument which is a string literal of the feature\nbeing tested for. The feature names supported are the lowercase versions of\nthe ones defined by Intel in [their documentation][docs].\n\n## Supported arguments\n\nThis macro supports the same names that `#[target_feature]` supports. Unlike\n`#[target_feature]`, however, this macro does not support names separated\nwith a comma. Instead testing for multiple features must be done through\nseparate macro invocations for now.\n\nSupported arguments are:\n\n* `\"aes\"`\n* `\"pclmulqdq\"`\n* `\"rdrand\"`\n* `\"rdseed\"`\n* `\"tsc\"`\n* `\"mmx\"`\n* `\"sse\"`\n* `\"sse2\"`\n* `\"sse3\"`\n* `\"ssse3\"`\n* `\"sse4.1\"`\n* `\"sse4.2\"`\n* `\"sse4a\"`\n* `\"sha\"`\n* `\"avx\"`\n* `\"avx2\"`\n* `\"sha512\"`\n* `\"sm3\"`\n* `\"sm4\"`\n* `\"avx512f\"`\n* `\"avx512cd\"`\n* `\"avx512er\"`\n* `\"avx512pf\"`\n* `\"avx512bw\"`\n* `\"avx512dq\"`\n* `\"avx512vl\"`\n* `\"avx512ifma\"`\n* `\"avx512vbmi\"`\n* `\"avx512vpopcntdq\"`\n* `\"avx512vbmi2\"`\n* `\"gfni\"`\n* `\"vaes\"`\n* `\"vpclmulqdq\"`\n* `\"avx512vnni\"`\n* `\"avx512bitalg\"`\n* `\"avx512bf16\"`\n* `\"avx512vp2intersect\"`\n* `\"avx512fp16\"`\n* `\"avxvnni\"`\n* `\"avxifma\"`\n* `\"avxneconvert\"`\n* `\"avxvnniint8\"`\n* `\"avxvnniint16\"`\n* `\"amx-tile\"`\n* `\"amx-int8\"`\n* `\"amx-bf16\"`\n* `\"amx-fp16\"`\n* `\"amx-complex\"`\n* `\"f16c\"`\n* `\"fma\"`\n* `\"bmi1\"`\n* `\"bmi2\"`\n* `\"abm\"`\n* `\"lzcnt\"`\n* `\"tbm\"`\n* `\"popcnt\"`\n* `\"fxsr\"`\n* `\"xsave\"`\n* `\"xsaveopt\"`\n* `\"xsaves\"`\n* `\"xsavec\"`\n* `\"cmpxchg16b\"`\n* `\"adx\"`\n* `\"rtm\"`\n* `\"movbe\"`\n* `\"ermsb\"`\n\n[docs]: https://software.intel.com/sites/landingpage/IntrinsicsGuide"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "is_x86_feature_detected!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "is_x86_feature_detected!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "line!(…)",
      "kind": 3,
      "detail": "macro_rules! line",
      "documentation": {
        "kind": "markdown",
        "value": "Expands to the line number on which it was invoked.\n\nWith [`column!`] and [`file!`], these macros provide debugging information for\ndevelopers about the location within the source.\n\nThe expanded expression has type `u32` and is 1-based, so the first line\nin each file evaluates to 1, the second to 2, etc. This is consistent\nwith error messages by common compilers or popular editors.\nThe returned line is *not necessarily* the line of the `line!` invocation itself,\nbut rather the first macro invocation leading up to the invocation\nof the `line!` macro.\n\n# Examples\n\n```rust\nlet current_line = line!();\nprintln!(\"defined on line: {current_line}\");\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "line!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "line!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "matches!(…)",
      "kind": 3,
      "detail": "macro_rules! matches",
      "documentation": {
        "kind": "markdown",
        "value": "Returns whether the given expression matches the provided pattern.\n\nThe pattern syntax is exactly the same as found in a match arm. The optional if guard can be\nused to add additional checks that must be true for the matched value, otherwise this macro will\nreturn `false`.\n\nWhen testing that a value matches a pattern, it's generally preferable to use\n[`assert_matches!`] as it will print the debug representation of the value if the assertion\nfails.\n\n# Examples\n\n```rust\nlet foo = 'f';\nassert!(matches!(foo, 'A'..='Z' | 'a'..='z'));\n\nlet bar = Some(4);\nassert!(matches!(bar, Some(x) if x > 2));\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "matches!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "matches!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "module_path!(…)",
      "kind": 3,
      "detail": "macro_rules! module_path",
      "documentation": {
        "kind": "markdown",
        "value": "Expands to a string that represents the current module path.\n\nThe current module path can be thought of as the hierarchy of modules\nleading back up to the crate root. The first component of the path\nreturned is the name of the crate currently being compiled.\n\n# Examples\n\n```rust\nmod test {\n    pub fn foo() {\n        assert!(module_path!().ends_with(\"test\"));\n    }\n}\n\ntest::foo();\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "module_path!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "module_path!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "option_env!(…)",
      "kind": 3,
      "detail": "macro_rules! option_env",
      "documentation": {
        "kind": "markdown",
        "value": "Optionally inspects an environment variable at compile time.\n\nIf the named environment variable is present at compile time, this will\nexpand into an expression of type `Option<&'static str>` whose value is\n`Some` of the value of the environment variable. If the environment\nvariable is not present, then this will expand to `None`. See\n[`Option<T>`][Option] for more information on this type.  Use\n[`std::env::var`] instead if you want to read the value at runtime.\n\n[`std::env::var`]: ../std/env/fn.var.html\n\nA compile time error is never emitted when using this macro regardless\nof whether the environment variable is present or not.\nTo emit a compile error if the environment variable is not present,\nuse the [`env!`] macro instead.\n\n# Examples\n\n```rust\nlet key: Option<&'static str> = option_env!(\"SECRET_KEY\");\nprintln!(\"the secret key might be: {key:?}\");\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "option_env!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "option_env!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "panic!(…)",
      "kind": 3,
      "detail": "macro_rules! panic",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "panic!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "panic!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "print!(…)",
      "kind": 3,
      "detail": "macro_rules! print",
      "documentation": {
        "kind": "markdown",
        "value": "Prints to the standard output.\n\nEquivalent to the [`println!`] macro except that a newline is not printed at\nthe end of the message.\n\nNote that stdout is frequently line-buffered by default so it may be\nnecessary to use [`io::stdout().flush()`][flush] to ensure the output is emitted\nimmediately.\n\nThe `print!` macro will lock the standard output on each call. If you call\n`print!` within a hot loop, this behavior may be the bottleneck of the loop.\nTo avoid this, lock stdout with [`io::stdout().lock()`][lock]:\n```rust\nuse std::io::{stdout, Write};\n\nlet mut lock = stdout().lock();\nwrite!(lock, \"hello world\").unwrap();\n```\n\nUse `print!` only for the primary output of your program. Use\n[`eprint!`] instead to print error and progress messages.\n\nSee [the formatting documentation in `std::fmt`](../std/fmt/index.html)\nfor details of the macro argument syntax.\n\n[flush]: crate::io::Write::flush\n[`println!`]: crate::println\n[`eprint!`]: crate::eprint\n[lock]: crate::io::Stdout\n\n# Panics\n\nPanics if writing to `io::stdout()` fails.\n\nWriting to non-blocking stdout can cause an error, which will lead\nthis macro to panic.\n\n# Examples\n\n```rust\nuse std::io::{self, Write};\n\nprint!(\"this \");\nprint!(\"will \");\nprint!(\"be \");\nprint!(\"on \");\nprint!(\"the \");\nprint!(\"same \");\nprint!(\"line \");\n\nio::stdout().flush().unwrap();\n\nprint!(\"this string has a newline, why not choose println! instead?\\n\");\n\nio::stdout().flush().unwrap();\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "print!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "print!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "println!(…)",
      "kind": 3,
      "detail": "macro_rules! println",
      "documentation": {
        "kind": "markdown",
        "value": "Prints to the standard output, with a newline.\n\nOn all platforms, the newline is the LINE FEED character (`\\n`/`U+000A`) alone\n(no additional CARRIAGE RETURN (`\\r`/`U+000D`)).\n\nThis macro uses the same syntax as [`format!`], but writes to the standard output instead.\nSee [`std::fmt`] for more information.\n\nThe `println!` macro will lock the standard output on each call. If you call\n`println!` within a hot loop, this behavior may be the bottleneck of the loop.\nTo avoid this, lock stdout with [`io::stdout().lock()`][lock]:\n```rust\nuse std::io::{stdout, Write};\n\nlet mut lock = stdout().lock();\nwriteln!(lock, \"hello world\").unwrap();\n```\n\nUse `println!` only for the primary output of your program. Use\n[`eprintln!`] instead to print error and progress messages.\n\nSee [the formatting documentation in `std::fmt`](../std/fmt/index.html)\nfor details of the macro argument syntax.\n\n[`std::fmt`]: crate::fmt\n[`eprintln!`]: crate::eprintln\n[lock]: crate::io::Stdout\n\n# Panics\n\nPanics if writing to [`io::stdout`] fails.\n\nWriting to non-blocking stdout can cause an error, which will lead\nthis macro to panic.\n\n[`io::stdout`]: crate::io::stdout\n\n# Examples\n\n```rust\nprintln!(); // prints just a newline\nprintln!(\"hello there!\");\nprintln!(\"format {} arguments\", \"some\");\nlet local_variable = \"some\";\nprintln!(\"format {local_variable} arguments\");\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "println!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "println!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "stringify!(…)",
      "kind": 3,
      "detail": "macro_rules! stringify",
      "documentation": {
        "kind": "markdown",
        "value": "Stringifies its arguments.\n\nThis macro will yield an expression of type `&'static str` which is the\nstringification of all the tokens passed to the macro. No restrictions\nare placed on the syntax of the macro invocation itself.\n\nNote that the expanded results of the input tokens may change in the\nfuture. You should be careful if you rely on the output.\n\n# Examples\n\n```rust\nlet one_plus_one = stringify!(1 + 1);\nassert_eq!(one_plus_one, \"1 + 1\");\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "stringify!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "stringify!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "thread_local! {…}",
      "kind": 3,
      "detail": "macro_rules! thread_local",
      "documentation": {
        "kind": "markdown",
        "value": "Declare a new thread local storage key of type [`std::thread::LocalKey`].\n\n# Syntax\n\nThe macro wraps any number of static declarations and makes them thread local.\nPublicity and attributes for each static are allowed. Example:\n\n```rust\nuse std::cell::{Cell, RefCell};\n\nthread_local! {\n    pub static FOO: Cell<u32> = Cell::new(1);\n\n    static BAR: RefCell<Vec<f32>> = RefCell::new(vec![1.0, 2.0]);\n}\n\nassert_eq!(FOO.get(), 1);\nBAR.with_borrow(|v| assert_eq!(v[1], 2.0));\n```\n\nNote that only shared references (`&T`) to the inner data may be obtained, so a\ntype such as [`Cell`] or [`RefCell`] is typically used to allow mutating access.\n\nThis macro supports a special `const {}` syntax that can be used\nwhen the initialization expression can be evaluated as a constant.\nThis can enable a more efficient thread local implementation that\ncan avoid lazy initialization. For types that do not\n[need to be dropped][crate::mem::needs_drop], this can enable an\neven more efficient implementation that does not need to\ntrack any additional state.\n\n```rust\nuse std::cell::RefCell;\n\nthread_local! {\n    pub static FOO: RefCell<Vec<u32>> = const { RefCell::new(Vec::new()) };\n}\n\nFOO.with_borrow(|v| assert_eq!(v.len(), 0));\n```\n\nSee [`LocalKey` documentation][`std::thread::LocalKey`] for more\ninformation.\n\n[`std::thread::LocalKey`]: crate::thread::LocalKey"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "thread_local!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "thread_local! {$0}"
      },
      "additionalTextEdits": []
    },
    {
      "label": "todo!(…)",
      "kind": 3,
      "detail": "macro_rules! todo",
      "documentation": {
        "kind": "markdown",
        "value": "Indicates unfinished code.\n\nThis can be useful if you are prototyping and just\nwant a placeholder to let your code pass type analysis.\n\nThe difference between [`unimplemented!`] and `todo!` is that while `todo!` conveys\nan intent of implementing the functionality later and the message is \"not yet\nimplemented\", `unimplemented!` makes no such claims. Its message is \"not implemented\".\n\nAlso, some IDEs will mark `todo!`s.\n\n# Panics\n\nThis will always [`panic!`] because `todo!` is just a shorthand for `panic!` with a\nfixed, specific message.\n\nLike `panic!`, this macro has a second form for displaying custom values.\n\n# Examples\n\nHere's an example of some in-progress code. We have a trait `Foo`:\n\n```rust\ntrait Foo {\n    fn bar(&self) -> u8;\n    fn baz(&self);\n    fn qux(&self) -> Result<u64, ()>;\n}\n```\n\nWe want to implement `Foo` on one of our types, but we also want to work on\njust `bar()` first. In order for our code to compile, we need to implement\n`baz()` and `qux()`, so we can use `todo!`:\n\n```rust\nstruct MyStruct;\n\nimpl Foo for MyStruct {\n    fn bar(&self) -> u8 {\n        1 + 1\n    }\n\n    fn baz(&self) {\n        // Let's not worry about implementing baz() for now\n        todo!();\n    }\n\n    fn qux(&self) -> Result<u64, ()> {\n        // We can add a message to todo! to display our omission.\n        // This will display:\n        // \"thread 'main' panicked at 'not yet implemented: MyStruct is not yet quxable'\".\n        todo!(\"MyStruct is not yet quxable\");\n    }\n}\n\nfn main() {\n    let s = MyStruct;\n    s.bar();\n\n    // We aren't even using baz() or qux(), so this is fine.\n}\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "todo!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "todo!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "try!(…)",
      "kind": 3,
      "detail": "macro_rules! r#try",
      "documentation": {
        "kind": "markdown",
        "value": "Unwraps a result or propagates its error.\n\nThe [`?` operator][propagating-errors] was added to replace `try!`\nand should be used instead. Furthermore, `try` is a reserved word\nin Rust 2018, so if you must use it, you will need to use the\n[raw-identifier syntax][ris]: `r#try`.\n\n[propagating-errors]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator\n[ris]: https://doc.rust-lang.org/nightly/rust-by-example/compatibility/raw_identifiers.html\n\n`try!` matches the given [`Result`]. In case of the `Ok` variant, the\nexpression has the value of the wrapped value.\n\nIn case of the `Err` variant, it retrieves the inner error. `try!` then\nperforms conversion using `From`. This provides automatic conversion\nbetween specialized errors and more general ones. The resulting\nerror is then immediately returned.\n\nBecause of the early return, `try!` can only be used in functions that\nreturn [`Result`].\n\n# Examples\n\n```rust\nuse std::io;\nuse std::fs::File;\nuse std::io::prelude::*;\n\nenum MyError {\n    FileWriteError\n}\n\nimpl From<io::Error> for MyError {\n    fn from(e: io::Error) -> MyError {\n        MyError::FileWriteError\n    }\n}\n\n// The preferred method of quick returning Errors\nfn write_to_file_question() -> Result<(), MyError> {\n    let mut file = File::create(\"my_best_friends.txt\")?;\n    file.write_all(b\"This is a list of my best friends.\")?;\n    Ok(())\n}\n\n// The previous method of quick returning Errors\nfn write_to_file_using_try() -> Result<(), MyError> {\n    let mut file = r#try!(File::create(\"my_best_friends.txt\"));\n    r#try!(file.write_all(b\"This is a list of my best friends.\"));\n    Ok(())\n}\n\n// This is equivalent to:\nfn write_to_file_using_match() -> Result<(), MyError> {\n    let mut file = r#try!(File::create(\"my_best_friends.txt\"));\n    match file.write_all(b\"This is a list of my best friends.\") {\n        Ok(v) => v,\n        Err(e) => return Err(From::from(e)),\n    }\n    Ok(())\n}\n```"
      },
      "deprecated": true,
      "sortText": "7fffffff",
      "filterText": "try!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "r#try!($0)"
      },
      "additionalTextEdits": [],
      "tags": [1]
    },
    {
      "label": "unimplemented!(…)",
      "kind": 3,
      "detail": "macro_rules! unimplemented",
      "documentation": {
        "kind": "markdown",
        "value": "Indicates unimplemented code by panicking with a message of \"not implemented\".\n\nThis allows your code to type-check, which is useful if you are prototyping or\nimplementing a trait that requires multiple methods which you don't plan to use all of.\n\nThe difference between `unimplemented!` and [`todo!`] is that while `todo!`\nconveys an intent of implementing the functionality later and the message is \"not yet\nimplemented\", `unimplemented!` makes no such claims. Its message is \"not implemented\".\n\nAlso, some IDEs will mark `todo!`s.\n\n# Panics\n\nThis will always [`panic!`] because `unimplemented!` is just a shorthand for `panic!` with a\nfixed, specific message.\n\nLike `panic!`, this macro has a second form for displaying custom values.\n\n[`todo!`]: crate::todo\n\n# Examples\n\nSay we have a trait `Foo`:\n\n```rust\ntrait Foo {\n    fn bar(&self) -> u8;\n    fn baz(&self);\n    fn qux(&self) -> Result<u64, ()>;\n}\n```\n\nWe want to implement `Foo` for 'MyStruct', but for some reason it only makes sense\nto implement the `bar()` function. `baz()` and `qux()` will still need to be defined\nin our implementation of `Foo`, but we can use `unimplemented!` in their definitions\nto allow our code to compile.\n\nWe still want to have our program stop running if the unimplemented methods are\nreached.\n\n```rust\nstruct MyStruct;\n\nimpl Foo for MyStruct {\n    fn bar(&self) -> u8 {\n        1 + 1\n    }\n\n    fn baz(&self) {\n        // It makes no sense to `baz` a `MyStruct`, so we have no logic here\n        // at all.\n        // This will display \"thread 'main' panicked at 'not implemented'\".\n        unimplemented!();\n    }\n\n    fn qux(&self) -> Result<u64, ()> {\n        // We have some logic here,\n        // We can add a message to unimplemented! to display our omission.\n        // This will display:\n        // \"thread 'main' panicked at 'not implemented: MyStruct isn't quxable'\".\n        unimplemented!(\"MyStruct isn't quxable\");\n    }\n}\n\nfn main() {\n    let s = MyStruct;\n    s.bar();\n}\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "unimplemented!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "unimplemented!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "unreachable!(…)",
      "kind": 3,
      "detail": "macro_rules! unreachable",
      "documentation": {
        "kind": "markdown",
        "value": "Indicates unreachable code.\n\nThis is useful any time that the compiler can't determine that some code is unreachable. For\nexample:\n\n* Match arms with guard conditions.\n* Loops that dynamically terminate.\n* Iterators that dynamically terminate.\n\nIf the determination that the code is unreachable proves incorrect, the\nprogram immediately terminates with a [`panic!`].\n\nThe unsafe counterpart of this macro is the [`unreachable_unchecked`] function, which\nwill cause undefined behavior if the code is reached.\n\n[`unreachable_unchecked`]: crate::hint::unreachable_unchecked\n\n# Panics\n\nThis will always [`panic!`] because `unreachable!` is just a shorthand for `panic!` with a\nfixed, specific message.\n\nLike `panic!`, this macro has a second form for displaying custom values.\n\n# Examples\n\nMatch arms:\n\n```rust\nfn foo(x: Option<i32>) {\n    match x {\n        Some(n) if n >= 0 => println!(\"Some(Non-negative)\"),\n        Some(n) if n <  0 => println!(\"Some(Negative)\"),\n        Some(_)           => unreachable!(), // compile error if commented out\n        None              => println!(\"None\")\n    }\n}\n```\n\nIterators:\n\n```rust\nfn divide_by_three(x: u32) -> u32 { // one of the poorest implementations of x/3\n    for i in 0.. {\n        if 3*i < i { panic!(\"u32 overflow\"); }\n        if x < 3*i { return i-1; }\n    }\n    unreachable!(\"The loop should always return\");\n}\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "unreachable!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "unreachable!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "vec![…]",
      "kind": 3,
      "detail": "macro_rules! vec",
      "documentation": {
        "kind": "markdown",
        "value": "Creates a [`Vec`] containing the arguments.\n\n`vec!` allows `Vec`s to be defined with the same syntax as array expressions.\nThere are two forms of this macro:\n\n- Create a [`Vec`] containing a given list of elements:\n\n```rust\nlet v = vec![1, 2, 3];\nassert_eq!(v[0], 1);\nassert_eq!(v[1], 2);\nassert_eq!(v[2], 3);\n```\n\n- Create a [`Vec`] from a given element and size:\n\n```rust\nlet v = vec![1; 3];\nassert_eq!(v, [1, 1, 1]);\n```\n\nNote that unlike array expressions this syntax supports all elements\nwhich implement [`Clone`] and the number of elements doesn't have to be\na constant.\n\nThis will use `clone` to duplicate an expression, so one should be careful\nusing this with types having a nonstandard `Clone` implementation. For\nexample, `vec![Rc::new(1); 5]` will create a vector of five references\nto the same boxed integer value, not five references pointing to independently\nboxed integers.\n\nAlso, note that `vec![expr; 0]` is allowed, and produces an empty vector.\nThis will still evaluate `expr`, however, and immediately drop the resulting value, so\nbe mindful of side effects.\n\n[`Vec`]: crate::vec::Vec"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "vec!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "vec![$0]"
      },
      "additionalTextEdits": []
    },
    {
      "label": "write!(…)",
      "kind": 3,
      "detail": "macro_rules! write",
      "documentation": {
        "kind": "markdown",
        "value": "Writes formatted data into a buffer.\n\nThis macro accepts a 'writer', a format string, and a list of arguments. Arguments will be\nformatted according to the specified format string and the result will be passed to the writer.\nThe writer may be any value with a `write_fmt` method; generally this comes from an\nimplementation of either the [`fmt::Write`] or the [`io::Write`] trait. The macro\nreturns whatever the `write_fmt` method returns; commonly a [`fmt::Result`], or an\n[`io::Result`].\n\nSee [`std::fmt`] for more information on the format string syntax.\n\n[`std::fmt`]: ../std/fmt/index.html\n[`fmt::Write`]: crate::fmt::Write\n[`io::Write`]: ../std/io/trait.Write.html\n[`fmt::Result`]: crate::fmt::Result\n[`io::Result`]: ../std/io/type.Result.html\n\n# Examples\n\n```rust\nuse std::io::Write;\n\nfn main() -> std::io::Result<()> {\n    let mut w = Vec::new();\n    write!(&mut w, \"test\")?;\n    write!(&mut w, \"formatted {}\", \"arguments\")?;\n\n    assert_eq!(w, b\"testformatted arguments\");\n    Ok(())\n}\n```\n\nA module can import both `std::fmt::Write` and `std::io::Write` and call `write!` on objects\nimplementing either, as objects do not typically implement both. However, the module must\navoid conflict between the trait names, such as by importing them as `_` or otherwise renaming\nthem:\n\n```rust\nuse std::fmt::Write as _;\nuse std::io::Write as _;\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let mut s = String::new();\n    let mut v = Vec::new();\n\n    write!(&mut s, \"{} {}\", \"abc\", 123)?; // uses fmt::Write::write_fmt\n    write!(&mut v, \"s = {:?}\", s)?; // uses io::Write::write_fmt\n    assert_eq!(v, b\"s = \\\"abc 123\\\"\");\n    Ok(())\n}\n```\n\nIf you also need the trait names themselves, such as to implement one or both on your types,\nimport the containing module and then name them with a prefix:\n\n```rust\nuse std::fmt::{self, Write as _};\nuse std::io::{self, Write as _};\n\nstruct Example;\n\nimpl fmt::Write for Example {\n    fn write_str(&mut self, _s: &str) -> core::fmt::Result {\n         unimplemented!();\n    }\n}\n```\n\nNote: This macro can be used in `no_std` setups as well.\nIn a `no_std` setup you are responsible for the implementation details of the components.\n\n```rust\nuse core::fmt::Write;\n\nstruct Example;\n\nimpl Write for Example {\n    fn write_str(&mut self, _s: &str) -> core::fmt::Result {\n         unimplemented!();\n    }\n}\n\nlet mut m = Example{};\nwrite!(&mut m, \"Hello World\").expect(\"Not written\");\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "write!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "write!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "writeln!(…)",
      "kind": 3,
      "detail": "macro_rules! writeln",
      "documentation": {
        "kind": "markdown",
        "value": "Writes formatted data into a buffer, with a newline appended.\n\nOn all platforms, the newline is the LINE FEED character (`\\n`/`U+000A`) alone\n(no additional CARRIAGE RETURN (`\\r`/`U+000D`).\n\nFor more information, see [`write!`]. For information on the format string syntax, see\n[`std::fmt`].\n\n[`std::fmt`]: ../std/fmt/index.html\n\n# Examples\n\n```rust\nuse std::io::{Write, Result};\n\nfn main() -> Result<()> {\n    let mut w = Vec::new();\n    writeln!(&mut w)?;\n    writeln!(&mut w, \"test\")?;\n    writeln!(&mut w, \"formatted {}\", \"arguments\")?;\n\n    assert_eq!(&w[..], \"\\ntest\\nformatted arguments\\n\".as_bytes());\n    Ok(())\n}\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "writeln!",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "writeln!($0)"
      },
      "additionalTextEdits": []
    },
    {
      "label": "crossterm",
      "kind": 9,
      "documentation": {
        "kind": "markdown",
        "value": " # Cross-platform Terminal Manipulation Library\n\n Crossterm is a pure-rust, terminal manipulation library that makes it possible to write cross-platform text-based interfaces (see [features](#features)). It supports all UNIX and Windows terminals down to Windows 7 (not all terminals are tested,\n see [Tested Terminals](#tested-terminals) for more info).\n\n This crate supports all UNIX and Windows terminals down to Windows 7 (not all terminals are tested\n see [Tested Terminals](https://github.com/crossterm-rs/crossterm#tested-terminals)\n for more info).\n\n ## Command API\n\n The command API makes the use of `crossterm` much easier and offers more control over when and how a\n command is executed. A command is just an action you can perform on the terminal e.g. cursor movement.\n\n The command API offers:\n\n * Better Performance.\n * Complete control over when to flush.\n * Complete control over where the ANSI escape commands are executed to.\n * Way easier and nicer API.\n\n There are two ways to use the API command:\n\n * Functions can execute commands on types that implement Write. Functions are easier to use and debug.\n   There is a disadvantage, and that is that there is a boilerplate code involved.\n * Macros are generally seen as more difficult and aren't always well supported by editors but offer an API with less boilerplate code. If you are\n   not afraid of macros, this is a recommendation.\n\n Linux and Windows 10 systems support ANSI escape codes. Those ANSI escape codes are strings or rather a\n byte sequence. When we `write` and `flush` those to the terminal we can perform some action.\n For older windows systems a WinAPI call is made.\n\n ### Supported Commands\n\n - Module [`cursor`](cursor/index.html)\n   - Visibility - [`Show`](cursor/struct.Show.html), [`Hide`](cursor/struct.Hide.html)\n   - Appearance - [`EnableBlinking`](cursor/struct.EnableBlinking.html),\n     [`DisableBlinking`](cursor/struct.DisableBlinking.html),\n     [`SetCursorStyle`](cursor/enum.SetCursorStyle.html)\n   - Position -\n     [`SavePosition`](cursor/struct.SavePosition.html), [`RestorePosition`](cursor/struct.RestorePosition.html),\n     [`MoveUp`](cursor/struct.MoveUp.html), [`MoveDown`](cursor/struct.MoveDown.html),\n     [`MoveLeft`](cursor/struct.MoveLeft.html), [`MoveRight`](cursor/struct.MoveRight.html),\n     [`MoveTo`](cursor/struct.MoveTo.html), [`MoveToColumn`](cursor/struct.MoveToColumn.html),[`MoveToRow`](cursor/struct.MoveToRow.html),\n     [`MoveToNextLine`](cursor/struct.MoveToNextLine.html), [`MoveToPreviousLine`](cursor/struct.MoveToPreviousLine.html)\n - Module [`event`](event/index.html)\n   - Keyboard events -\n     [`PushKeyboardEnhancementFlags`](event/struct.PushKeyboardEnhancementFlags.html),\n     [`PopKeyboardEnhancementFlags`](event/struct.PopKeyboardEnhancementFlags.html)\n   - Mouse events - [`EnableMouseCapture`](event/struct.EnableMouseCapture.html),\n     [`DisableMouseCapture`](event/struct.DisableMouseCapture.html)\n - Module [`style`](style/index.html)\n   - Colors - [`SetForegroundColor`](style/struct.SetForegroundColor.html),\n     [`SetBackgroundColor`](style/struct.SetBackgroundColor.html),\n     [`ResetColor`](style/struct.ResetColor.html), [`SetColors`](style/struct.SetColors.html)\n   - Attributes - [`SetAttribute`](style/struct.SetAttribute.html), [`SetAttributes`](style/struct.SetAttributes.html),\n     [`PrintStyledContent`](style/struct.PrintStyledContent.html)\n - Module [`terminal`](terminal/index.html)\n   - Scrolling - [`ScrollUp`](terminal/struct.ScrollUp.html),\n     [`ScrollDown`](terminal/struct.ScrollDown.html)\n   - Miscellaneous - [`Clear`](terminal/struct.Clear.html),\n     [`SetSize`](terminal/struct.SetSize.html),\n     [`SetTitle`](terminal/struct.SetTitle.html),\n     [`DisableLineWrap`](terminal/struct.DisableLineWrap.html),\n     [`EnableLineWrap`](terminal/struct.EnableLineWrap.html)\n   - Alternate screen - [`EnterAlternateScreen`](terminal/struct.EnterAlternateScreen.html),\n     [`LeaveAlternateScreen`](terminal/struct.LeaveAlternateScreen.html)\n\n ### Command Execution\n\n There are two different ways to execute commands:\n\n * [Lazy Execution](#lazy-execution)\n * [Direct Execution](#direct-execution)\n\n #### Lazy Execution\n\n Flushing bytes to the terminal buffer is a heavy system call. If we perform a lot of actions with the terminal,\n we want to do this periodically - like with a TUI editor - so that we can flush more data to the terminal buffer\n at the same time.\n\n Crossterm offers the possibility to do this with `queue`.\n With `queue` you can queue commands, and when you call [Write::flush][flush] these commands will be executed.\n\n You can pass a custom buffer implementing [std::io::Write][write] to this `queue` operation.\n The commands will be executed on that buffer.\n The most common buffer is [std::io::stdout][stdout] however, [std::io::stderr][stderr] is used sometimes as well.\n\n ##### Examples\n\n A simple demonstration that shows the command API in action with cursor commands.\n\n Functions:\n\n ```no_run\n use std::io::{Write, stdout};\n use crossterm::{QueueableCommand, cursor};\n\n let mut stdout = stdout();\n stdout.queue(cursor::MoveTo(5,5));\n\n // some other code ...\n\n stdout.flush();\n ```\n\n The [queue](./trait.QueueableCommand.html) function returns itself, therefore you can use this to queue another\n command. Like `stdout.queue(Goto(5,5)).queue(Clear(ClearType::All))`.\n\n Macros:\n\n ```no_run\n use std::io::{Write, stdout};\n use crossterm::{queue, QueueableCommand, cursor};\n\n let mut stdout = stdout();\n queue!(stdout,  cursor::MoveTo(5, 5));\n\n // some other code ...\n\n // move operation is performed only if we flush the buffer.\n stdout.flush();\n ```\n\n You can pass more than one command into the [queue](./macro.queue.html) macro like\n `queue!(stdout, MoveTo(5, 5), Clear(ClearType::All))` and\n they will be executed in the given order from left to right.\n\n #### Direct Execution\n\n For many applications it is not at all important to be efficient with 'flush' operations.\n For this use case there is the `execute` operation.\n This operation executes the command immediately, and calls the `flush` under water.\n\n You can pass a custom buffer implementing [std::io::Write][write] to this `execute` operation.\n The commands will be executed on that buffer.\n The most common buffer is [std::io::stdout][stdout] however, [std::io::stderr][stderr] is used sometimes as well.\n\n ##### Examples\n\n Functions:\n\n ```no_run\n use std::io::{Write, stdout};\n use crossterm::{ExecutableCommand, cursor};\n\n let mut stdout = stdout();\n stdout.execute(cursor::MoveTo(5,5));\n ```\n The [execute](./trait.ExecutableCommand.html) function returns itself, therefore you can use this to queue\n another command. Like `stdout.execute(Goto(5,5))?.execute(Clear(ClearType::All))`.\n\n Macros:\n\n ```no_run\n use std::io::{stdout, Write};\n use crossterm::{execute, ExecutableCommand, cursor};\n\n let mut stdout = stdout();\n execute!(stdout, cursor::MoveTo(5, 5));\n ```\n You can pass more than one command into the [execute](./macro.execute.html) macro like\n `execute!(stdout, MoveTo(5, 5), Clear(ClearType::All))` and they will be executed in the given order from\n left to right.\n\n ## Examples\n\n Print a rectangle colored with magenta and use both direct execution and lazy execution.\n\n Functions:\n\n ```no_run\n use std::io::{self, Write};\n use crossterm::{\n     ExecutableCommand, QueueableCommand,\n     terminal, cursor, style::{self, Stylize}\n };\n\n fn main() -> io::Result<()> {\n   let mut stdout = io::stdout();\n\n   stdout.execute(terminal::Clear(terminal::ClearType::All))?;\n\n   for y in 0..40 {\n     for x in 0..150 {\n       if (y == 0 || y == 40 - 1) || (x == 0 || x == 150 - 1) {\n         // in this loop we are more efficient by not flushing the buffer.\n         stdout\n           .queue(cursor::MoveTo(x,y))?\n           .queue(style::PrintStyledContent( \"█\".magenta()))?;\n       }\n     }\n   }\n   stdout.flush()?;\n   Ok(())\n }\n ```\n\n Macros:\n\n ```no_run\n use std::io::{self, Write};\n use crossterm::{\n     execute, queue,\n     style::{self, Stylize}, cursor, terminal\n };\n\n fn main() -> io::Result<()> {\n   let mut stdout = io::stdout();\n\n   execute!(stdout, terminal::Clear(terminal::ClearType::All))?;\n\n   for y in 0..40 {\n     for x in 0..150 {\n       if (y == 0 || y == 40 - 1) || (x == 0 || x == 150 - 1) {\n         // in this loop we are more efficient by not flushing the buffer.\n         queue!(stdout, cursor::MoveTo(x,y), style::PrintStyledContent( \"█\".magenta()))?;\n       }\n     }\n   }\n   stdout.flush()?;\n   Ok(())\n }\n```rust\n\n [write]: https://doc.rust-lang.org/std/io/trait.Write.html\n [stdout]: https://doc.rust-lang.org/std/io/fn.stdout.html\n [stderr]: https://doc.rust-lang.org/std/io/fn.stderr.html\n [flush]: https://doc.rust-lang.org/std/io/trait.Write.html#tymethod.flush"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "crossterm",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "crossterm"
      },
      "additionalTextEdits": []
    },
    {
      "label": "serde",
      "kind": 9,
      "documentation": {
        "kind": "markdown",
        "value": "# Serde\n\nSerde is a framework for ***ser***ializing and ***de***serializing Rust data\nstructures efficiently and generically.\n\nThe Serde ecosystem consists of data structures that know how to serialize\nand deserialize themselves along with data formats that know how to\nserialize and deserialize other things. Serde provides the layer by which\nthese two groups interact with each other, allowing any supported data\nstructure to be serialized and deserialized using any supported data format.\n\nSee the Serde website <https://serde.rs/> for additional documentation and\nusage examples.\n\n## Design\n\nWhere many other languages rely on runtime reflection for serializing data,\nSerde is instead built on Rust's powerful trait system. A data structure\nthat knows how to serialize and deserialize itself is one that implements\nSerde's `Serialize` and `Deserialize` traits (or uses Serde's derive\nattribute to automatically generate implementations at compile time). This\navoids any overhead of reflection or runtime type information. In fact in\nmany situations the interaction between data structure and data format can\nbe completely optimized away by the Rust compiler, leaving Serde\nserialization to perform the same speed as a handwritten serializer for the\nspecific selection of data structure and data format.\n\n## Data formats\n\nThe following is a partial list of data formats that have been implemented\nfor Serde by the community.\n\n- [JSON], the ubiquitous JavaScript Object Notation used by many HTTP APIs.\n- [Postcard], a no\\_std and embedded-systems friendly compact binary format.\n- [CBOR], a Concise Binary Object Representation designed for small message\n  size without the need for version negotiation.\n- [YAML], a self-proclaimed human-friendly configuration language that ain't\n  markup language.\n- [MessagePack], an efficient binary format that resembles a compact JSON.\n- [TOML], a minimal configuration format used by [Cargo].\n- [Pickle], a format common in the Python world.\n- [RON], a Rusty Object Notation.\n- [BSON], the data storage and network transfer format used by MongoDB.\n- [Avro], a binary format used within Apache Hadoop, with support for schema\n  definition.\n- [JSON5], a superset of JSON including some productions from ES5.\n- [URL] query strings, in the x-www-form-urlencoded format.\n- [Starlark], the format used for describing build targets by the Bazel and\n  Buck build systems. *(serialization only)*\n- [Envy], a way to deserialize environment variables into Rust structs.\n  *(deserialization only)*\n- [Envy Store], a way to deserialize [AWS Parameter Store] parameters into\n  Rust structs. *(deserialization only)*\n- [S-expressions], the textual representation of code and data used by the\n  Lisp language family.\n- [D-Bus]'s binary wire format.\n- [FlexBuffers], the schemaless cousin of Google's FlatBuffers zero-copy\n  serialization format.\n- [Bencode], a simple binary format used in the BitTorrent protocol.\n- [Token streams], for processing Rust procedural macro input.\n  *(deserialization only)*\n- [DynamoDB Items], the format used by [rusoto_dynamodb] to transfer data to\n  and from DynamoDB.\n- [Hjson], a syntax extension to JSON designed around human reading and\n  editing. *(deserialization only)*\n- [CSV], Comma-separated values is a tabular text file format.\n\n[JSON]: https://github.com/serde-rs/json\n[Postcard]: https://github.com/jamesmunns/postcard\n[CBOR]: https://github.com/enarx/ciborium\n[YAML]: https://github.com/dtolnay/serde-yaml\n[MessagePack]: https://github.com/3Hren/msgpack-rust\n[TOML]: https://docs.rs/toml\n[Pickle]: https://github.com/birkenfeld/serde-pickle\n[RON]: https://github.com/ron-rs/ron\n[BSON]: https://github.com/mongodb/bson-rust\n[Avro]: https://docs.rs/apache-avro\n[JSON5]: https://github.com/callum-oakley/json5-rs\n[URL]: https://docs.rs/serde_qs\n[Starlark]: https://github.com/dtolnay/serde-starlark\n[Envy]: https://github.com/softprops/envy\n[Envy Store]: https://github.com/softprops/envy-store\n[Cargo]: https://doc.rust-lang.org/cargo/reference/manifest.html\n[AWS Parameter Store]: https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-parameter-store.html\n[S-expressions]: https://github.com/rotty/lexpr-rs\n[D-Bus]: https://docs.rs/zvariant\n[FlexBuffers]: https://github.com/google/flatbuffers/tree/master/rust/flexbuffers\n[Bencode]: https://github.com/P3KI/bendy\n[Token streams]: https://github.com/oxidecomputer/serde_tokenstream\n[DynamoDB Items]: https://docs.rs/serde_dynamo\n[rusoto_dynamodb]: https://docs.rs/rusoto_dynamodb\n[Hjson]: https://github.com/Canop/deser-hjson\n[CSV]: https://docs.rs/csv"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "serde",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "serde"
      },
      "additionalTextEdits": []
    },
    {
      "label": "once_cell",
      "kind": 9,
      "documentation": {
        "kind": "markdown",
        "value": "# Overview\n\n`once_cell` provides two new cell-like types, [`unsync::OnceCell`] and\n[`sync::OnceCell`]. A `OnceCell` might store arbitrary non-`Copy` types, can\nbe assigned to at most once and provides direct access to the stored\ncontents. The core API looks *roughly* like this (and there's much more\ninside, read on!):\n\n```rust\nimpl<T> OnceCell<T> {\n    const fn new() -> OnceCell<T> { ... }\n    fn set(&self, value: T) -> Result<(), T> { ... }\n    fn get(&self) -> Option<&T> { ... }\n}\n```\n\nNote that, like with [`RefCell`] and [`Mutex`], the `set` method requires\nonly a shared reference. Because of the single assignment restriction `get`\ncan return a `&T` instead of `Ref<T>` or `MutexGuard<T>`.\n\nThe `sync` flavor is thread-safe (that is, implements the [`Sync`] trait),\nwhile the `unsync` one is not.\n\n[`unsync::OnceCell`]: unsync/struct.OnceCell.html\n[`sync::OnceCell`]: sync/struct.OnceCell.html\n[`RefCell`]: https://doc.rust-lang.org/std/cell/struct.RefCell.html\n[`Mutex`]: https://doc.rust-lang.org/std/sync/struct.Mutex.html\n[`Sync`]: https://doc.rust-lang.org/std/marker/trait.Sync.html\n\n# Recipes\n\n`OnceCell` might be useful for a variety of patterns.\n\n## Safe Initialization of Global Data\n\n```rust\nuse std::{env, io};\n\nuse once_cell::sync::OnceCell;\n\n#[derive(Debug)]\npub struct Logger {\n    // ...\n}\nstatic INSTANCE: OnceCell<Logger> = OnceCell::new();\n\nimpl Logger {\n    pub fn global() -> &'static Logger {\n        INSTANCE.get().expect(\"logger is not initialized\")\n    }\n\n    fn from_cli(args: env::Args) -> Result<Logger, std::io::Error> {\n       // ...\n    }\n}\n\nfn main() {\n    let logger = Logger::from_cli(env::args()).unwrap();\n    INSTANCE.set(logger).unwrap();\n    // use `Logger::global()` from now on\n}\n```\n\n## Lazy Initialized Global Data\n\nThis is essentially the `lazy_static!` macro, but without a macro.\n\n```rust\nuse std::{sync::Mutex, collections::HashMap};\n\nuse once_cell::sync::OnceCell;\n\nfn global_data() -> &'static Mutex<HashMap<i32, String>> {\n    static INSTANCE: OnceCell<Mutex<HashMap<i32, String>>> = OnceCell::new();\n    INSTANCE.get_or_init(|| {\n        let mut m = HashMap::new();\n        m.insert(13, \"Spica\".to_string());\n        m.insert(74, \"Hoyten\".to_string());\n        Mutex::new(m)\n    })\n}\n```\n\nThere are also the [`sync::Lazy`] and [`unsync::Lazy`] convenience types to\nstreamline this pattern:\n\n```rust\nuse std::{sync::Mutex, collections::HashMap};\nuse once_cell::sync::Lazy;\n\nstatic GLOBAL_DATA: Lazy<Mutex<HashMap<i32, String>>> = Lazy::new(|| {\n    let mut m = HashMap::new();\n    m.insert(13, \"Spica\".to_string());\n    m.insert(74, \"Hoyten\".to_string());\n    Mutex::new(m)\n});\n\nfn main() {\n    println!(\"{:?}\", GLOBAL_DATA.lock().unwrap());\n}\n```\n\nNote that the variable that holds `Lazy` is declared as `static`, *not*\n`const`. This is important: using `const` instead compiles, but works wrong.\n\n[`sync::Lazy`]: sync/struct.Lazy.html\n[`unsync::Lazy`]: unsync/struct.Lazy.html\n\n## General purpose lazy evaluation\n\nUnlike `lazy_static!`, `Lazy` works with local variables.\n\n```rust\nuse once_cell::unsync::Lazy;\n\nfn main() {\n    let ctx = vec![1, 2, 3];\n    let thunk = Lazy::new(|| {\n        ctx.iter().sum::<i32>()\n    });\n    assert_eq!(*thunk, 6);\n}\n```\n\nIf you need a lazy field in a struct, you probably should use `OnceCell`\ndirectly, because that will allow you to access `self` during\ninitialization.\n\n```rust\nuse std::{fs, path::PathBuf};\n\nuse once_cell::unsync::OnceCell;\n\nstruct Ctx {\n    config_path: PathBuf,\n    config: OnceCell<String>,\n}\n\nimpl Ctx {\n    pub fn get_config(&self) -> Result<&str, std::io::Error> {\n        let cfg = self.config.get_or_try_init(|| {\n            fs::read_to_string(&self.config_path)\n        })?;\n        Ok(cfg.as_str())\n    }\n}\n```\n\n## Lazily Compiled Regex\n\nThis is a `regex!` macro which takes a string literal and returns an\n*expression* that evaluates to a `&'static Regex`:\n\n```rust\nmacro_rules! regex {\n    ($re:literal $(,)?) => {{\n        static RE: once_cell::sync::OnceCell<regex::Regex> = once_cell::sync::OnceCell::new();\n        RE.get_or_init(|| regex::Regex::new($re).unwrap())\n    }};\n}\n```\n\nThis macro can be useful to avoid the \"compile regex on every loop\niteration\" problem.\n\n## Runtime `include_bytes!`\n\nThe `include_bytes` macro is useful to include test resources, but it slows\ndown test compilation a lot. An alternative is to load the resources at\nruntime:\n\n```rust\nuse std::path::Path;\n\nuse once_cell::sync::OnceCell;\n\npub struct TestResource {\n    path: &'static str,\n    cell: OnceCell<Vec<u8>>,\n}\n\nimpl TestResource {\n    pub const fn new(path: &'static str) -> TestResource {\n        TestResource { path, cell: OnceCell::new() }\n    }\n    pub fn bytes(&self) -> &[u8] {\n        self.cell.get_or_init(|| {\n            let dir = std::env::var(\"CARGO_MANIFEST_DIR\").unwrap();\n            let path = Path::new(dir.as_str()).join(self.path);\n            std::fs::read(&path).unwrap_or_else(|_err| {\n                panic!(\"failed to load test resource: {}\", path.display())\n            })\n        }).as_slice()\n    }\n}\n\nstatic TEST_IMAGE: TestResource = TestResource::new(\"test_data/lena.png\");\n\n#[test]\nfn test_sobel_filter() {\n    let rgb: &[u8] = TEST_IMAGE.bytes();\n    // ...\n}\n```\n\n## `lateinit`\n\n`LateInit` type for delayed initialization. It is reminiscent of Kotlin's\n`lateinit` keyword and allows construction of cyclic data structures:\n\n\n```rust\nuse once_cell::sync::OnceCell;\n\npub struct LateInit<T> { cell: OnceCell<T> }\n\nimpl<T> LateInit<T> {\n    pub fn init(&self, value: T) {\n        assert!(self.cell.set(value).is_ok())\n    }\n}\n\nimpl<T> Default for LateInit<T> {\n    fn default() -> Self { LateInit { cell: OnceCell::default() } }\n}\n\nimpl<T> std::ops::Deref for LateInit<T> {\n    type Target = T;\n    fn deref(&self) -> &T {\n        self.cell.get().unwrap()\n    }\n}\n\n#[derive(Default)]\nstruct A<'a> {\n    b: LateInit<&'a B<'a>>,\n}\n\n#[derive(Default)]\nstruct B<'a> {\n    a: LateInit<&'a A<'a>>\n}\n\n\nfn build_cycle() {\n    let a = A::default();\n    let b = B::default();\n    a.b.init(&b);\n    b.a.init(&a);\n\n    let _a = &a.b.a.b.a;\n}\n```\n\n# Comparison with std\n\n|`!Sync` types         | Access Mode            | Drawbacks                                     |\n|----------------------|------------------------|-----------------------------------------------|\n|`Cell<T>`             | `T`                    | requires `T: Copy` for `get`                  |\n|`RefCell<T>`          | `RefMut<T>` / `Ref<T>` | may panic at runtime                          |\n|`unsync::OnceCell<T>` | `&T`                   | assignable only once                          |\n\n|`Sync` types          | Access Mode            | Drawbacks                                     |\n|----------------------|------------------------|-----------------------------------------------|\n|`AtomicT`             | `T`                    | works only with certain `Copy` types          |\n|`Mutex<T>`            | `MutexGuard<T>`        | may deadlock at runtime, may block the thread |\n|`sync::OnceCell<T>`   | `&T`                   | assignable only once, may block the thread    |\n\nTechnically, calling `get_or_init` will also cause a panic or a deadlock if\nit recursively calls itself. However, because the assignment can happen only\nonce, such cases should be more rare than equivalents with `RefCell` and\n`Mutex`.\n\n# Minimum Supported `rustc` Version\n\nIf only the `std`, `alloc`, or `race` features are enabled, MSRV will be\nupdated conservatively, supporting at least latest 8 versions of the compiler.\nWhen using other features, like `parking_lot`, MSRV might be updated more\nfrequently, up to the latest stable. In both cases, increasing MSRV is *not*\nconsidered a semver-breaking change and requires only a minor version bump.\n\n# Implementation details\n\nThe implementation is based on the\n[`lazy_static`](https://github.com/rust-lang-nursery/lazy-static.rs/) and\n[`lazy_cell`](https://github.com/indiv0/lazycell/) crates and\n[`std::sync::Once`]. In some sense, `once_cell` just streamlines and unifies\nthose APIs.\n\nTo implement a sync flavor of `OnceCell`, this crates uses either a custom\nre-implementation of `std::sync::Once` or `parking_lot::Mutex`. This is\ncontrolled by the `parking_lot` feature (disabled by default). Performance\nis the same for both cases, but the `parking_lot` based `OnceCell<T>` is\nsmaller by up to 16 bytes.\n\nThis crate uses `unsafe`.\n\n[`std::sync::Once`]: https://doc.rust-lang.org/std/sync/struct.Once.html\n\n# F.A.Q.\n\n**Should I use the sync or unsync flavor?**\n\nBecause Rust compiler checks thread safety for you, it's impossible to\naccidentally use `unsync` where `sync` is required. So, use `unsync` in\nsingle-threaded code and `sync` in multi-threaded. It's easy to switch\nbetween the two if code becomes multi-threaded later.\n\nAt the moment, `unsync` has an additional benefit that reentrant\ninitialization causes a panic, which might be easier to debug than a\ndeadlock.\n\n**Does this crate support async?**\n\nNo, but you can use\n[`async_once_cell`](https://crates.io/crates/async_once_cell) instead.\n\n**Does this crate support `no_std`?**\n\nYes, but with caveats. `OnceCell` is a synchronization primitive which\n_semantically_ relies on blocking. `OnceCell` guarantees that at most one\n`f` will be called to compute the value. If two threads of execution call\n`get_or_init` concurrently, one of them has to wait.\n\nWaiting fundamentally requires OS support. Execution environment needs to\nunderstand who waits on whom to prevent deadlocks due to priority inversion.\nYou _could_ make code to compile by blindly using pure spinlocks, but the\nruntime behavior would be subtly wrong.\n\nGiven these constraints, `once_cell` provides the following options:\n\n- The `race` module provides similar, but distinct synchronization primitive\n  which is compatible with `no_std`. With `race`, the `f` function can be\n  called multiple times by different threads, but only one thread will win\n  to install the value.\n- `critical-section` feature (with a `-`, not `_`) uses `critical_section`\n  to implement blocking.\n\n**Can I bring my own mutex?**\n\nThere is [generic_once_cell](https://crates.io/crates/generic_once_cell) to\nallow just that.\n\n**Should I use `std::cell::OnceCell`, `once_cell`, or `lazy_static`?**\n\nIf you can use `std` version (your MSRV is at least 1.70, and you don't need\nextra features `once_cell` provides), use `std`. Otherwise, use `once_cell`.\nDon't use `lazy_static`.\n\n# Related crates\n\n* Most of this crate's functionality is available in `std` starting with\n  Rust 1.70. See `std::cell::OnceCell` and `std::sync::OnceLock`.\n* [double-checked-cell](https://github.com/niklasf/double-checked-cell)\n* [lazy-init](https://crates.io/crates/lazy-init)\n* [lazycell](https://crates.io/crates/lazycell)\n* [mitochondria](https://crates.io/crates/mitochondria)\n* [lazy_static](https://crates.io/crates/lazy_static)\n* [async_once_cell](https://crates.io/crates/async_once_cell)\n* [generic_once_cell](https://crates.io/crates/generic_once_cell) (bring\n  your own mutex)"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "once_cell",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "once_cell"
      },
      "additionalTextEdits": []
    },
    {
      "label": "serde_json",
      "kind": 9,
      "documentation": {
        "kind": "markdown",
        "value": "# Serde JSON\n\nJSON is a ubiquitous open-standard format that uses human-readable text to\ntransmit data objects consisting of key-value pairs.\n\n```json\n{\n    \"name\": \"John Doe\",\n    \"age\": 43,\n    \"address\": {\n        \"street\": \"10 Downing Street\",\n        \"city\": \"London\"\n    },\n    \"phones\": [\n        \"+44 1234567\",\n        \"+44 2345678\"\n    ]\n}\n```\n\nThere are three common ways that you might find yourself needing to work\nwith JSON data in Rust.\n\n - **As text data.** An unprocessed string of JSON data that you receive on\n   an HTTP endpoint, read from a file, or prepare to send to a remote\n   server.\n - **As an untyped or loosely typed representation.** Maybe you want to\n   check that some JSON data is valid before passing it on, but without\n   knowing the structure of what it contains. Or you want to do very basic\n   manipulations like insert a key in a particular spot.\n - **As a strongly typed Rust data structure.** When you expect all or most\n   of your data to conform to a particular structure and want to get real\n   work done without JSON's loosey-goosey nature tripping you up.\n\nSerde JSON provides efficient, flexible, safe ways of converting data\nbetween each of these representations.\n\n# Operating on untyped JSON values\n\nAny valid JSON data can be manipulated in the following recursive enum\nrepresentation. This data structure is [`serde_json::Value`][value].\n\n```rust\nenum Value {\n    Null,\n    Bool(bool),\n    Number(Number),\n    String(String),\n    Array(Vec<Value>),\n    Object(Map<String, Value>),\n}\n```\n\nA string of JSON data can be parsed into a `serde_json::Value` by the\n[`serde_json::from_str`][from_str] function. There is also [`from_slice`]\nfor parsing from a byte slice &\\[u8\\] and [`from_reader`] for parsing from\nany `io::Read` like a File or a TCP stream.\n\n```rust\nuse serde_json::{Result, Value};\n\nfn untyped_example() -> Result<()> {\n    // Some JSON input data as a &str. Maybe this comes from the user.\n    let data = r#\"\n        {\n            \"name\": \"John Doe\",\n            \"age\": 43,\n            \"phones\": [\n                \"+44 1234567\",\n                \"+44 2345678\"\n            ]\n        }\"#;\n\n    // Parse the string of data into serde_json::Value.\n    let v: Value = serde_json::from_str(data)?;\n\n    // Access parts of the data by indexing with square brackets.\n    println!(\"Please call {} at the number {}\", v[\"name\"], v[\"phones\"][0]);\n\n    Ok(())\n}\n```\n\nThe result of square bracket indexing like `v[\"name\"]` is a borrow of the\ndata at that index, so the type is `&Value`. A JSON map can be indexed with\nstring keys, while a JSON array can be indexed with integer keys. If the\ntype of the data is not right for the type with which it is being indexed,\nor if a map does not contain the key being indexed, or if the index into a\nvector is out of bounds, the returned element is `Value::Null`.\n\nWhen a `Value` is printed, it is printed as a JSON string. So in the code\nabove, the output looks like `Please call \"John Doe\" at the number \"+44\n1234567\"`. The quotation marks appear because `v[\"name\"]` is a `&Value`\ncontaining a JSON string and its JSON representation is `\"John Doe\"`.\nPrinting as a plain string without quotation marks involves converting from\na JSON string to a Rust string with [`as_str()`] or avoiding the use of\n`Value` as described in the following section.\n\n[`as_str()`]: crate::Value::as_str\n\nThe `Value` representation is sufficient for very basic tasks but can be\ntedious to work with for anything more significant. Error handling is\nverbose to implement correctly, for example imagine trying to detect the\npresence of unrecognized fields in the input data. The compiler is powerless\nto help you when you make a mistake, for example imagine typoing `v[\"name\"]`\nas `v[\"nmae\"]` in one of the dozens of places it is used in your code.\n\n# Parsing JSON as strongly typed data structures\n\nSerde provides a powerful way of mapping JSON data into Rust data structures\nlargely automatically.\n\n```rust\nuse serde::{Deserialize, Serialize};\nuse serde_json::Result;\n\n#[derive(Serialize, Deserialize)]\nstruct Person {\n    name: String,\n    age: u8,\n    phones: Vec<String>,\n}\n\nfn typed_example() -> Result<()> {\n    // Some JSON input data as a &str. Maybe this comes from the user.\n    let data = r#\"\n        {\n            \"name\": \"John Doe\",\n            \"age\": 43,\n            \"phones\": [\n                \"+44 1234567\",\n                \"+44 2345678\"\n            ]\n        }\"#;\n\n    // Parse the string of data into a Person object. This is exactly the\n    // same function as the one that produced serde_json::Value above, but\n    // now we are asking it for a Person as output.\n    let p: Person = serde_json::from_str(data)?;\n\n    // Do things just like with any other Rust data structure.\n    println!(\"Please call {} at the number {}\", p.name, p.phones[0]);\n\n    Ok(())\n}\n```\n\nThis is the same `serde_json::from_str` function as before, but this time we\nassign the return value to a variable of type `Person` so Serde will\nautomatically interpret the input data as a `Person` and produce informative\nerror messages if the layout does not conform to what a `Person` is expected\nto look like.\n\nAny type that implements Serde's `Deserialize` trait can be deserialized\nthis way. This includes built-in Rust standard library types like `Vec<T>`\nand `HashMap<K, V>`, as well as any structs or enums annotated with\n`#[derive(Deserialize)]`.\n\nOnce we have `p` of type `Person`, our IDE and the Rust compiler can help us\nuse it correctly like they do for any other Rust code. The IDE can\nautocomplete field names to prevent typos, which was impossible in the\n`serde_json::Value` representation. And the Rust compiler can check that\nwhen we write `p.phones[0]`, then `p.phones` is guaranteed to be a\n`Vec<String>` so indexing into it makes sense and produces a `String`.\n\n# Constructing JSON values\n\nSerde JSON provides a [`json!` macro][macro] to build `serde_json::Value`\nobjects with very natural JSON syntax.\n\n```rust\nuse serde_json::json;\n\nfn main() {\n    // The type of `john` is `serde_json::Value`\n    let john = json!({\n        \"name\": \"John Doe\",\n        \"age\": 43,\n        \"phones\": [\n            \"+44 1234567\",\n            \"+44 2345678\"\n        ]\n    });\n\n    println!(\"first phone number: {}\", john[\"phones\"][0]);\n\n    // Convert to a string of JSON and print it out\n    println!(\"{}\", john.to_string());\n}\n```\n\nThe `Value::to_string()` function converts a `serde_json::Value` into a\n`String` of JSON text.\n\nOne neat thing about the `json!` macro is that variables and expressions can\nbe interpolated directly into the JSON value as you are building it. Serde\nwill check at compile time that the value you are interpolating is able to\nbe represented as JSON.\n\n```rust\nlet full_name = \"John Doe\";\nlet age_last_year = 42;\n\n// The type of `john` is `serde_json::Value`\nlet john = json!({\n    \"name\": full_name,\n    \"age\": age_last_year + 1,\n    \"phones\": [\n        format!(\"+44 {}\", random_phone())\n    ]\n});\n```\n\nThis is amazingly convenient, but we have the problem we had before with\n`Value`: the IDE and Rust compiler cannot help us if we get it wrong. Serde\nJSON provides a better way of serializing strongly-typed data structures\ninto JSON text.\n\n# Creating JSON by serializing data structures\n\nA data structure can be converted to a JSON string by\n[`serde_json::to_string`][to_string]. There is also\n[`serde_json::to_vec`][to_vec] which serializes to a `Vec<u8>` and\n[`serde_json::to_writer`][to_writer] which serializes to any `io::Write`\nsuch as a File or a TCP stream.\n\n```rust\nuse serde::{Deserialize, Serialize};\nuse serde_json::Result;\n\n#[derive(Serialize, Deserialize)]\nstruct Address {\n    street: String,\n    city: String,\n}\n\nfn print_an_address() -> Result<()> {\n    // Some data structure.\n    let address = Address {\n        street: \"10 Downing Street\".to_owned(),\n        city: \"London\".to_owned(),\n    };\n\n    // Serialize it to a JSON string.\n    let j = serde_json::to_string(&address)?;\n\n    // Print, write to a file, or send to an HTTP server.\n    println!(\"{}\", j);\n\n    Ok(())\n}\n```\n\nAny type that implements Serde's `Serialize` trait can be serialized this\nway. This includes built-in Rust standard library types like `Vec<T>` and\n`HashMap<K, V>`, as well as any structs or enums annotated with\n`#[derive(Serialize)]`.\n\n# No-std support\n\nAs long as there is a memory allocator, it is possible to use serde_json\nwithout the rest of the Rust standard library. Disable the default \"std\"\nfeature and enable the \"alloc\" feature:\n\n```toml\n[dependencies]\nserde_json = { version = \"1.0\", default-features = false, features = [\"alloc\"] }\n```\n\nFor JSON support in Serde without a memory allocator, please see the\n[`serde-json-core`] crate.\n\n[value]: crate::value::Value\n[from_str]: crate::de::from_str\n[from_slice]: crate::de::from_slice\n[from_reader]: crate::de::from_reader\n[to_string]: crate::ser::to_string\n[to_vec]: crate::ser::to_vec\n[to_writer]: crate::ser::to_writer\n[macro]: crate::json\n[`serde-json-core`]: https://github.com/rust-embedded-community/serde-json-core"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "serde_json",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "serde_json"
      },
      "additionalTextEdits": []
    },
    {
      "label": "deno_ast",
      "kind": 9,
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "deno_ast",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "deno_ast"
      },
      "additionalTextEdits": []
    },
    {
      "label": "thiserror",
      "kind": 9,
      "documentation": {
        "kind": "markdown",
        "value": "[![github]](https://github.com/dtolnay/thiserror)&ensp;[![crates-io]](https://crates.io/crates/thiserror)&ensp;[![docs-rs]](https://docs.rs/thiserror)\n\n[github]: https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github\n[crates-io]: https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust\n[docs-rs]: https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs\n\n<br>\n\nThis library provides a convenient derive macro for the standard library's\n[`std::error::Error`] trait.\n\n[`std::error::Error`]: https://doc.rust-lang.org/std/error/trait.Error.html\n\n<br>\n\n# Example\n\n```rust\nuse thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum DataStoreError {\n    #[error(\"data store disconnected\")]\n    Disconnect(#[from] io::Error),\n    #[error(\"the data for key `{0}` is not available\")]\n    Redaction(String),\n    #[error(\"invalid header (expected {expected:?}, found {found:?})\")]\n    InvalidHeader {\n        expected: String,\n        found: String,\n    },\n    #[error(\"unknown data store error\")]\n    Unknown,\n}\n```\n\n<br>\n\n# Details\n\n- Thiserror deliberately does not appear in your public API. You get the\n  same thing as if you had written an implementation of `std::error::Error`\n  by hand, and switching from handwritten impls to thiserror or vice versa\n  is not a breaking change.\n\n- Errors may be enums, structs with named fields, tuple structs, or unit\n  structs.\n\n- A `Display` impl is generated for your error if you provide\n  `#[error(\"...\")]` messages on the struct or each variant of your enum, as\n  shown above in the example.\n\n  The messages support a shorthand for interpolating fields from the error.\n\n    - `#[error(\"{var}\")]`&ensp;⟶&ensp;`write!(\"{}\", self.var)`\n    - `#[error(\"{0}\")]`&ensp;⟶&ensp;`write!(\"{}\", self.0)`\n    - `#[error(\"{var:?}\")]`&ensp;⟶&ensp;`write!(\"{:?}\", self.var)`\n    - `#[error(\"{0:?}\")]`&ensp;⟶&ensp;`write!(\"{:?}\", self.0)`\n\n  These shorthands can be used together with any additional format args,\n  which may be arbitrary expressions. For example:\n\n  ```rust\n  # use std::i32;\n  # use thiserror::Error;\n  #\n  #[derive(Error, Debug)]\n  pub enum Error {\n      #[error(\"invalid rdo_lookahead_frames {0} (expected < {})\", i32::MAX)]\n      InvalidLookahead(u32),\n  }\n  ```\n\n  If one of the additional expression arguments needs to refer to a field of\n  the struct or enum, then refer to named fields as `.var` and tuple fields\n  as `.0`.\n\n  ```rust\n  # use thiserror::Error;\n  #\n  # fn first_char(s: &String) -> char {\n  #     s.chars().next().unwrap()\n  # }\n  #\n  # #[derive(Debug)]\n  # struct Limits {\n  #     lo: usize,\n  #     hi: usize,\n  # }\n  #\n  #[derive(Error, Debug)]\n  pub enum Error {\n      #[error(\"first letter must be lowercase but was {:?}\", first_char(.0))]\n      WrongCase(String),\n      #[error(\"invalid index {idx}, expected at least {} and at most {}\", .limits.lo, .limits.hi)]\n      OutOfBounds { idx: usize, limits: Limits },\n  }\n  ```\n\n- A `From` impl is generated for each variant containing a `#[from]`\n  attribute.\n\n  Note that the variant must not contain any other fields beyond the source\n  error and possibly a backtrace. A backtrace is captured from within the\n  `From` impl if there is a field for it.\n\n  ```rust\n  # const IGNORE: &str = stringify! {\n  #[derive(Error, Debug)]\n  pub enum MyError {\n      Io {\n          #[from]\n          source: io::Error,\n          backtrace: Backtrace,\n      },\n  }\n  # };\n  ```\n\n- The Error trait's `source()` method is implemented to return whichever\n  field has a `#[source]` attribute or is named `source`, if any. This is\n  for identifying the underlying lower level error that caused your error.\n\n  The `#[from]` attribute always implies that the same field is `#[source]`,\n  so you don't ever need to specify both attributes.\n\n  Any error type that implements `std::error::Error` or dereferences to `dyn\n  std::error::Error` will work as a source.\n\n  ```rust\n  # use std::fmt::{self, Display};\n  # use thiserror::Error;\n  #\n  #[derive(Error, Debug)]\n  pub struct MyError {\n      msg: String,\n      #[source]  // optional if field name is `source`\n      source: anyhow::Error,\n  }\n  #\n  # impl Display for MyError {\n  #     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n  #         unimplemented!()\n  #     }\n  # }\n  ```\n\n- The Error trait's `provide()` method is implemented to provide whichever\n  field has a type named `Backtrace`, if any, as a\n  `std::backtrace::Backtrace`.\n\n  ```rust\n  # const IGNORE: &str = stringify! {\n  use std::backtrace::Backtrace;\n\n  #[derive(Error, Debug)]\n  pub struct MyError {\n      msg: String,\n      backtrace: Backtrace,  // automatically detected\n  }\n  # };\n  ```\n\n- If a field is both a source (named `source`, or has `#[source]` or\n  `#[from]` attribute) *and* is marked `#[backtrace]`, then the Error\n  trait's `provide()` method is forwarded to the source's `provide` so that\n  both layers of the error share the same backtrace.\n\n  ```rust\n  # const IGNORE: &str = stringify! {\n  #[derive(Error, Debug)]\n  pub enum MyError {\n      Io {\n          #[backtrace]\n          source: io::Error,\n      },\n  }\n  # };\n  ```\n\n- Errors may use `error(transparent)` to forward the source and Display\n  methods straight through to an underlying error without adding an\n  additional message. This would be appropriate for enums that need an\n  \"anything else\" variant.\n\n  ```\n  # use thiserror::Error;\n  #\n  #[derive(Error, Debug)]\n  pub enum MyError {\n      # /*\n      ...\n      # */\n\n      #[error(transparent)]\n      Other(#[from] anyhow::Error),  // source and Display delegate to anyhow::Error\n  }\n  ```\n\n  Another use case is hiding implementation details of an error\n  representation behind an opaque error type, so that the representation is\n  able to evolve without breaking the crate's public API.\n\n  ```\n  # use thiserror::Error;\n  #\n  // PublicError is public, but opaque and easy to keep compatible.\n  #[derive(Error, Debug)]\n  #[error(transparent)]\n  pub struct PublicError(#[from] ErrorRepr);\n\n  impl PublicError {\n      // Accessors for anything we do want to expose publicly.\n  }\n\n  // Private and free to change across minor version of the crate.\n  #[derive(Error, Debug)]\n  enum ErrorRepr {\n      # /*\n      ...\n      # */\n  }\n  ```\n\n- See also the [`anyhow`] library for a convenient single error type to use\n  in application code.\n\n  [`anyhow`]: https://github.com/dtolnay/anyhow"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "thiserror",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "thiserror"
      },
      "additionalTextEdits": []
    },
    {
      "label": "tokio",
      "kind": 9,
      "documentation": {
        "kind": "markdown",
        "value": "A runtime for writing reliable network applications without compromising speed.\n\nTokio is an event-driven, non-blocking I/O platform for writing asynchronous\napplications with the Rust programming language. At a high level, it\nprovides a few major components:\n\n* Tools for [working with asynchronous tasks][tasks], including\n  [synchronization primitives and channels][sync] and [timeouts, sleeps, and\n  intervals][time].\n* APIs for [performing asynchronous I/O][io], including [TCP and UDP][net] sockets,\n  [filesystem][fs] operations, and [process] and [signal] management.\n* A [runtime] for executing asynchronous code, including a task scheduler,\n  an I/O driver backed by the operating system's event queue (`epoll`, `kqueue`,\n  `IOCP`, etc...), and a high performance timer.\n\nGuide level documentation is found on the [website].\n\n[tasks]: #working-with-tasks\n[sync]: crate::sync\n[time]: crate::time\n[io]: #asynchronous-io\n[net]: crate::net\n[fs]: crate::fs\n[process]: crate::process\n[signal]: crate::signal\n[fs]: crate::fs\n[runtime]: crate::runtime\n[website]: https://tokio.rs/tokio/tutorial\n\n# A Tour of Tokio\n\nTokio consists of a number of modules that provide a range of functionality\nessential for implementing asynchronous applications in Rust. In this\nsection, we will take a brief tour of Tokio, summarizing the major APIs and\ntheir uses.\n\nThe easiest way to get started is to enable all features. Do this by\nenabling the `full` feature flag:\n\n```toml\ntokio = { version = \"1\", features = [\"full\"] }\n```\n\n### Authoring applications\n\nTokio is great for writing applications and most users in this case shouldn't\nworry too much about what features they should pick. If you're unsure, we suggest\ngoing with `full` to ensure that you don't run into any road blocks while you're\nbuilding your application.\n\n#### Example\n\nThis example shows the quickest way to get started with Tokio.\n\n```toml\ntokio = { version = \"1\", features = [\"full\"] }\n```\n\n### Authoring libraries\n\nAs a library author your goal should be to provide the lightest weight crate\nthat is based on Tokio. To achieve this you should ensure that you only enable\nthe features you need. This allows users to pick up your crate without having\nto enable unnecessary features.\n\n#### Example\n\nThis example shows how you may want to import features for a library that just\nneeds to `tokio::spawn` and use a `TcpStream`.\n\n```toml\ntokio = { version = \"1\", features = [\"rt\", \"net\"] }\n```\n\n## Working With Tasks\n\nAsynchronous programs in Rust are based around lightweight, non-blocking\nunits of execution called [_tasks_][tasks]. The [`tokio::task`] module provides\nimportant tools for working with tasks:\n\n* The [`spawn`] function and [`JoinHandle`] type, for scheduling a new task\n  on the Tokio runtime and awaiting the output of a spawned task, respectively,\n* Functions for [running blocking operations][blocking] in an asynchronous\n  task context.\n\nThe [`tokio::task`] module is present only when the \"rt\" feature flag\nis enabled.\n\n[tasks]: task/index.html#what-are-tasks\n[`tokio::task`]: crate::task\n[`spawn`]: crate::task::spawn()\n[`JoinHandle`]: crate::task::JoinHandle\n[blocking]: task/index.html#blocking-and-yielding\n\nThe [`tokio::sync`] module contains synchronization primitives to use when\nneeding to communicate or share data. These include:\n\n* channels ([`oneshot`], [`mpsc`], [`watch`], and [`broadcast`]), for sending values\n  between tasks,\n* a non-blocking [`Mutex`], for controlling access to a shared, mutable\n  value,\n* an asynchronous [`Barrier`] type, for multiple tasks to synchronize before\n  beginning a computation.\n\nThe `tokio::sync` module is present only when the \"sync\" feature flag is\nenabled.\n\n[`tokio::sync`]: crate::sync\n[`Mutex`]: crate::sync::Mutex\n[`Barrier`]: crate::sync::Barrier\n[`oneshot`]: crate::sync::oneshot\n[`mpsc`]: crate::sync::mpsc\n[`watch`]: crate::sync::watch\n[`broadcast`]: crate::sync::broadcast\n\nThe [`tokio::time`] module provides utilities for tracking time and\nscheduling work. This includes functions for setting [timeouts][timeout] for\ntasks, [sleeping][sleep] work to run in the future, or [repeating an operation at an\ninterval][interval].\n\nIn order to use `tokio::time`, the \"time\" feature flag must be enabled.\n\n[`tokio::time`]: crate::time\n[sleep]: crate::time::sleep()\n[interval]: crate::time::interval()\n[timeout]: crate::time::timeout()\n\nFinally, Tokio provides a _runtime_ for executing asynchronous tasks. Most\napplications can use the [`#[tokio::main]`][main] macro to run their code on the\nTokio runtime. However, this macro provides only basic configuration options. As\nan alternative, the [`tokio::runtime`] module provides more powerful APIs for configuring\nand managing runtimes. You should use that module if the `#[tokio::main]` macro doesn't\nprovide the functionality you need.\n\nUsing the runtime requires the \"rt\" or \"rt-multi-thread\" feature flags, to\nenable the current-thread [single-threaded scheduler][rt] and the [multi-thread\nscheduler][rt-multi-thread], respectively. See the [`runtime` module\ndocumentation][rt-features] for details. In addition, the \"macros\" feature\nflag enables the `#[tokio::main]` and `#[tokio::test]` attributes.\n\n[main]: attr.main.html\n[`tokio::runtime`]: crate::runtime\n[`Builder`]: crate::runtime::Builder\n[`Runtime`]: crate::runtime::Runtime\n[rt]: runtime/index.html#current-thread-scheduler\n[rt-multi-thread]: runtime/index.html#multi-thread-scheduler\n[rt-features]: runtime/index.html#runtime-scheduler\n\n## CPU-bound tasks and blocking code\n\nTokio is able to concurrently run many tasks on a few threads by repeatedly\nswapping the currently running task on each thread. However, this kind of\nswapping can only happen at `.await` points, so code that spends a long time\nwithout reaching an `.await` will prevent other tasks from running. To\ncombat this, Tokio provides two kinds of threads: Core threads and blocking threads.\n\nThe core threads are where all asynchronous code runs, and Tokio will by default\nspawn one for each CPU core. You can use the environment variable `TOKIO_WORKER_THREADS`\nto override the default value.\n\nThe blocking threads are spawned on demand, can be used to run blocking code\nthat would otherwise block other tasks from running and are kept alive when\nnot used for a certain amount of time which can be configured with [`thread_keep_alive`].\nSince it is not possible for Tokio to swap out blocking tasks, like it\ncan do with asynchronous code, the upper limit on the number of blocking\nthreads is very large. These limits can be configured on the [`Builder`].\n\nTo spawn a blocking task, you should use the [`spawn_blocking`] function.\n\n[`Builder`]: crate::runtime::Builder\n[`spawn_blocking`]: crate::task::spawn_blocking()\n[`thread_keep_alive`]: crate::runtime::Builder::thread_keep_alive()\n\n```rust\n#[tokio::main]\nasync fn main() {\n    // This is running on a core thread.\n\n    let blocking_task = tokio::task::spawn_blocking(|| {\n        // This is running on a blocking thread.\n        // Blocking here is ok.\n    });\n\n    // We can wait for the blocking task like this:\n    // If the blocking task panics, the unwrap below will propagate the\n    // panic.\n    blocking_task.await.unwrap();\n}\n```\n\nIf your code is CPU-bound and you wish to limit the number of threads used\nto run it, you should use a separate thread pool dedicated to CPU bound tasks.\nFor example, you could consider using the [rayon] library for CPU-bound\ntasks. It is also possible to create an extra Tokio runtime dedicated to\nCPU-bound tasks, but if you do this, you should be careful that the extra\nruntime runs _only_ CPU-bound tasks, as IO-bound tasks on that runtime\nwill behave poorly.\n\nHint: If using rayon, you can use a [`oneshot`] channel to send the result back\nto Tokio when the rayon task finishes.\n\n[rayon]: https://docs.rs/rayon\n[`oneshot`]: crate::sync::oneshot\n\n## Asynchronous IO\n\nAs well as scheduling and running tasks, Tokio provides everything you need\nto perform input and output asynchronously.\n\nThe [`tokio::io`] module provides Tokio's asynchronous core I/O primitives,\nthe [`AsyncRead`], [`AsyncWrite`], and [`AsyncBufRead`] traits. In addition,\nwhen the \"io-util\" feature flag is enabled, it also provides combinators and\nfunctions for working with these traits, forming as an asynchronous\ncounterpart to [`std::io`].\n\nTokio also includes APIs for performing various kinds of I/O and interacting\nwith the operating system asynchronously. These include:\n\n* [`tokio::net`], which contains non-blocking versions of [TCP], [UDP], and\n  [Unix Domain Sockets][UDS] (enabled by the \"net\" feature flag),\n* [`tokio::fs`], similar to [`std::fs`] but for performing filesystem I/O\n  asynchronously (enabled by the \"fs\" feature flag),\n* [`tokio::signal`], for asynchronously handling Unix and Windows OS signals\n  (enabled by the \"signal\" feature flag),\n* [`tokio::process`], for spawning and managing child processes (enabled by\n  the \"process\" feature flag).\n\n[`tokio::io`]: crate::io\n[`AsyncRead`]: crate::io::AsyncRead\n[`AsyncWrite`]: crate::io::AsyncWrite\n[`AsyncBufRead`]: crate::io::AsyncBufRead\n[`std::io`]: std::io\n[`tokio::net`]: crate::net\n[TCP]: crate::net::tcp\n[UDP]: crate::net::UdpSocket\n[UDS]: crate::net::unix\n[`tokio::fs`]: crate::fs\n[`std::fs`]: std::fs\n[`tokio::signal`]: crate::signal\n[`tokio::process`]: crate::process\n\n# Examples\n\nA simple TCP echo server:\n\n```rust\nuse tokio::net::TcpListener;\nuse tokio::io::{AsyncReadExt, AsyncWriteExt};\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let listener = TcpListener::bind(\"127.0.0.1:8080\").await?;\n\n    loop {\n        let (mut socket, _) = listener.accept().await?;\n\n        tokio::spawn(async move {\n            let mut buf = [0; 1024];\n\n            // In a loop, read data from the socket and write the data back.\n            loop {\n                let n = match socket.read(&mut buf).await {\n                    // socket closed\n                    Ok(n) if n == 0 => return,\n                    Ok(n) => n,\n                    Err(e) => {\n                        eprintln!(\"failed to read from socket; err = {:?}\", e);\n                        return;\n                    }\n                };\n\n                // Write the data back\n                if let Err(e) = socket.write_all(&buf[0..n]).await {\n                    eprintln!(\"failed to write to socket; err = {:?}\", e);\n                    return;\n                }\n            }\n        });\n    }\n}\n```\n\n## Feature flags\n\nTokio uses a set of [feature flags] to reduce the amount of compiled code. It\nis possible to just enable certain features over others. By default, Tokio\ndoes not enable any features but allows one to enable a subset for their use\ncase. Below is a list of the available feature flags. You may also notice\nabove each function, struct and trait there is listed one or more feature flags\nthat are required for that item to be used. If you are new to Tokio it is\nrecommended that you use the `full` feature flag which will enable all public APIs.\nBeware though that this will pull in many extra dependencies that you may not\nneed.\n\n- `full`: Enables all features listed below except `test-util` and `tracing`.\n- `rt`: Enables `tokio::spawn`, the current-thread scheduler,\n        and non-scheduler utilities.\n- `rt-multi-thread`: Enables the heavier, multi-threaded, work-stealing scheduler.\n- `io-util`: Enables the IO based `Ext` traits.\n- `io-std`: Enable `Stdout`, `Stdin` and `Stderr` types.\n- `net`: Enables `tokio::net` types such as `TcpStream`, `UnixStream` and\n         `UdpSocket`, as well as (on Unix-like systems) `AsyncFd` and (on\n         FreeBSD) `PollAio`.\n- `time`: Enables `tokio::time` types and allows the schedulers to enable\n          the built in timer.\n- `process`: Enables `tokio::process` types.\n- `macros`: Enables `#[tokio::main]` and `#[tokio::test]` macros.\n- `sync`: Enables all `tokio::sync` types.\n- `signal`: Enables all `tokio::signal` types.\n- `fs`: Enables `tokio::fs` types.\n- `test-util`: Enables testing based infrastructure for the Tokio runtime.\n- `parking_lot`: As a potential optimization, use the `_parking_lot_` crate's\n                 synchronization primitives internally. Also, this\n                 dependency is necessary to construct some of our primitives\n                 in a `const` context. `MSRV` may increase according to the\n                 `_parking_lot_` release in use.\n\n_Note: `AsyncRead` and `AsyncWrite` traits do not require any features and are\nalways available._\n\n### Unstable features\n\nSome feature flags are only available when specifying the `tokio_unstable` flag:\n\n- `tracing`: Enables tracing events.\n\nLikewise, some parts of the API are only available with the same flag:\n\n- [`task::Builder`]\n- Some methods on [`task::JoinSet`]\n- [`runtime::RuntimeMetrics`]\n- [`runtime::Builder::unhandled_panic`]\n- [`task::Id`]\n\nThis flag enables **unstable** features. The public API of these features\nmay break in 1.x releases. To enable these features, the `--cfg\ntokio_unstable` argument must be passed to `rustc` when compiling. This\nserves to explicitly opt-in to features which may break semver conventions,\nsince Cargo [does not yet directly support such opt-ins][unstable features].\n\nYou can specify it in your project's `.cargo/config.toml` file:\n\n```toml\n[build]\nrustflags = [\"--cfg\", \"tokio_unstable\"]\n```\n\nAlternatively, you can specify it with an environment variable:\n\n```sh\n## Many *nix shells:\nexport RUSTFLAGS=\"--cfg tokio_unstable\"\ncargo build\n```\n\n```powershell\n## Windows PowerShell:\n$Env:RUSTFLAGS=\"--cfg tokio_unstable\"\ncargo build\n```\n\n[unstable features]: https://internals.rust-lang.org/t/feature-request-unstable-opt-in-non-transitive-crate-features/16193#why-not-a-crate-feature-2\n[feature flags]: https://doc.rust-lang.org/cargo/reference/manifest.html#the-features-section\n\n## Supported platforms\n\nTokio currently guarantees support for the following platforms:\n\n * Linux\n * Windows\n * Android (API level 21)\n * macOS\n * iOS\n * FreeBSD\n\nTokio will continue to support these platforms in the future. However,\nfuture releases may change requirements such as the minimum required libc\nversion on Linux, the API level on Android, or the supported FreeBSD\nrelease.\n\nBeyond the above platforms, Tokio is intended to work on all platforms\nsupported by the mio crate. You can find a longer list [in mio's\ndocumentation][mio-supported]. However, these additional platforms may\nbecome unsupported in the future.\n\nNote that Wine is considered to be a different platform from Windows. See\nmio's documentation for more information on Wine support.\n\n[mio-supported]: https://crates.io/crates/mio#platforms\n\n### `WASM` support\n\nTokio has some limited support for the `WASM` platform. Without the\n`tokio_unstable` flag, the following features are supported:\n\n * `sync`\n * `macros`\n * `io-util`\n * `rt`\n * `time`\n\nEnabling any other feature (including `full`) will cause a compilation\nfailure.\n\nThe `time` module will only work on `WASM` platforms that have support for\ntimers (e.g. wasm32-wasi). The timing functions will panic if used on a `WASM`\nplatform that does not support timers.\n\nNote also that if the runtime becomes indefinitely idle, it will panic\nimmediately instead of blocking forever. On platforms that don't support\ntime, this means that the runtime can never be idle in any way.\n\n### Unstable `WASM` support\n\nTokio also has unstable support for some additional `WASM` features. This\nrequires the use of the `tokio_unstable` flag.\n\nUsing this flag enables the use of `tokio::net` on the wasm32-wasi target.\nHowever, not all methods are available on the networking types as `WASI`\ncurrently does not support the creation of new sockets from within `WASM`.\nBecause of this, sockets must currently be created via the `FromRawFd`\ntrait."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "tokio",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "tokio"
      },
      "additionalTextEdits": []
    },
    {
      "label": "futures",
      "kind": 9,
      "documentation": {
        "kind": "markdown",
        "value": "Abstractions for asynchronous programming.\n\nThis crate provides a number of core abstractions for writing asynchronous\ncode:\n\n- [Futures](crate::future) are single eventual values produced by\n  asynchronous computations. Some programming languages (e.g. JavaScript)\n  call this concept \"promise\".\n- [Streams](crate::stream) represent a series of values\n  produced asynchronously.\n- [Sinks](crate::sink) provide support for asynchronous writing of\n  data.\n- [Executors](crate::executor) are responsible for running asynchronous\n  tasks.\n\nThe crate also contains abstractions for [asynchronous I/O](crate::io) and\n[cross-task communication](crate::channel).\n\nUnderlying all of this is the *task system*, which is a form of lightweight\nthreading. Large asynchronous computations are built up using futures,\nstreams and sinks, and then spawned as independent tasks that are run to\ncompletion, but *do not block* the thread running them.\n\nThe following example describes how the task system context is built and used\nwithin macros and keywords such as async and await!.\n\n```rust\nfn main() {\n    let pool = ThreadPool::new().expect(\"Failed to build pool\");\n    let (tx, rx) = mpsc::unbounded::<i32>();\n\n    // Create a future by an async block, where async is responsible for an\n    // implementation of Future. At this point no executor has been provided\n    // to this future, so it will not be running.\n    let fut_values = async {\n        // Create another async block, again where the Future implementation\n        // is generated by async. Since this is inside of a parent async block,\n        // it will be provided with the executor of the parent block when the parent\n        // block is executed.\n        //\n        // This executor chaining is done by Future::poll whose second argument\n        // is a std::task::Context. This represents our executor, and the Future\n        // implemented by this async block can be polled using the parent async\n        // block's executor.\n        let fut_tx_result = async move {\n            (0..100).for_each(|v| {\n                tx.unbounded_send(v).expect(\"Failed to send\");\n            })\n        };\n\n        // Use the provided thread pool to spawn the generated future\n        // responsible for transmission\n        pool.spawn_ok(fut_tx_result);\n\n        let fut_values = rx\n            .map(|v| v * 2)\n            .collect();\n\n        // Use the executor provided to this async block to wait for the\n        // future to complete.\n        fut_values.await\n    };\n\n    // Actually execute the above future, which will invoke Future::poll and\n    // subsequently chain appropriate Future::poll and methods needing executors\n    // to drive all futures. Eventually fut_values will be driven to completion.\n    let values: Vec<i32> = executor::block_on(fut_values);\n\n    println!(\"Values={:?}\", values);\n}\n```\n\nThe majority of examples and code snippets in this crate assume that they are\ninside an async block as written above."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "futures",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "futures"
      },
      "additionalTextEdits": []
    },
    {
      "label": "deno_core",
      "kind": 9,
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "deno_core",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "deno_core"
      },
      "additionalTextEdits": []
    },
    {
      "label": "futures_timer",
      "kind": 9,
      "documentation": {
        "kind": "markdown",
        "value": "A general purpose crate for working with timeouts and delays with futures.\n\n# Examples\n\n```rust\nuse std::time::Duration;\nuse futures_timer::Delay;\n\nlet now = Delay::new(Duration::from_secs(3)).await;\nprintln!(\"waited for 3 secs\");\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "futures_timer",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "futures_timer"
      },
      "additionalTextEdits": []
    },
    {
      "label": "fuzzy_matcher",
      "kind": 9,
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "fuzzy_matcher",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "fuzzy_matcher"
      },
      "additionalTextEdits": []
    },
    {
      "label": "tree_sitter",
      "kind": 9,
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "tree_sitter",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "tree_sitter"
      },
      "additionalTextEdits": []
    },
    {
      "label": "tree_sitter_rust",
      "kind": 9,
      "documentation": {
        "kind": "markdown",
        "value": "This crate provides a Rust grammar for the [tree-sitter][] parsing library.\n\nTypically, you will use the [language][language func] function to add this grammar to a\ntree-sitter [Parser][], and then use the parser to parse some code:\n\n```rust\nuse tree_sitter::Parser;\n\nlet code = r#\"\n    fn double(x: i32) -> i32 {\n        x * 2\n    }\n\"#;\nlet mut parser = Parser::new();\nparser.set_language(tree_sitter_rust::language()).expect(\"Error loading Rust grammar\");\nlet parsed = parser.parse(code, None);\n```\n\n[Language]: https://docs.rs/tree-sitter/*/tree_sitter/struct.Language.html\n[language func]: fn.language.html\n[Parser]: https://docs.rs/tree-sitter/*/tree_sitter/struct.Parser.html\n[tree-sitter]: https://tree-sitter.github.io/"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "tree_sitter_rust",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "tree_sitter_rust"
      },
      "additionalTextEdits": []
    },
    {
      "label": "core",
      "kind": 9,
      "documentation": {
        "kind": "markdown",
        "value": "# The Rust Core Library\n\nThe Rust Core Library is the dependency-free[^free] foundation of [The\nRust Standard Library](../std/index.html). It is the portable glue\nbetween the language and its libraries, defining the intrinsic and\nprimitive building blocks of all Rust code. It links to no\nupstream libraries, no system libraries, and no libc.\n\n[^free]: Strictly speaking, there are some symbols which are needed but\n         they aren't always necessary.\n\nThe core library is *minimal*: it isn't even aware of heap allocation,\nnor does it provide concurrency or I/O. These things require\nplatform integration, and this library is platform-agnostic.\n\n# How to use the core library\n\nPlease note that all of these details are currently not considered stable.\n\nThis library is built on the assumption of a few existing symbols:\n\n* `memcpy`, `memmove`, `memset`, `memcmp`, `bcmp`, `strlen` - These are core memory routines\n  which are generated by Rust codegen backends. Additionally, this library can make explicit\n  calls to `strlen`. Their signatures are the same as found in C, but there are extra\n  assumptions about their semantics: For `memcpy`, `memmove`, `memset`, `memcmp`, and `bcmp`, if\n  the `n` parameter is 0, the function is assumed to not be UB, even if the pointers are NULL or\n  dangling. (Note that making extra assumptions about these functions is common among compilers:\n  [clang](https://reviews.llvm.org/D86993) and [GCC](https://gcc.gnu.org/onlinedocs/gcc/Standards.html#C-Language) do the same.)\n  These functions are often provided by the system libc, but can also be provided by the\n  [compiler-builtins crate](https://crates.io/crates/compiler_builtins).\n  Note that the library does not guarantee that it will always make these assumptions, so Rust\n  user code directly calling the C functions should follow the C specification! The advice for\n  Rust user code is to call the functions provided by this library instead (such as\n  `ptr::copy`).\n\n* Panic handler - This function takes one argument, a `&panic::PanicInfo`. It is up to consumers of this core\n  library to define this panic function; it is only required to never\n  return. You should mark your implementation using `#[panic_handler]`.\n\n* `rust_eh_personality` - is used by the failure mechanisms of the\n   compiler. This is often mapped to GCC's personality function, but crates\n   which do not trigger a panic can be assured that this function is never\n   called. The `lang` attribute is called `eh_personality`."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "core",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "core"
      },
      "additionalTextEdits": []
    },
    {
      "label": "json_comments",
      "kind": 9,
      "documentation": {
        "kind": "markdown",
        "value": "`json_comments` is a library to strip out comments from JSON-like test. By processing text\nthrough a [`StripComments`] adapter first, it is possible to use a standard JSON parser (such\nas [serde_json](https://crates.io/crates/serde_json) with quasi-json input that contains\ncomments.\n\nIn fact, this code makes few assumptions about the input and could probably be used to strip\ncomments out of other types of code as well, provided that strings use double quotes and\nbackslashes are used for escapes in strings.\n\nThe following types of comments are supported:\n  - C style block comments (`/* ... */`)\n  - C style line comments (`// ...`)\n  - Shell style line comments (`# ...`)\n\n## Example using serde_json\n\n```rust\nuse serde_json::{Result, Value};\nuse json_comments::StripComments;\n\n// Some JSON input data as a &str. Maybe this comes form the user.\nlet data = r#\"\n    {\n        \"name\": /* full */ \"John Doe\",\n        \"age\": 43,\n        \"phones\": [\n            \"+44 1234567\", // work phone\n            \"+44 2345678\"  // home phone\n        ]\n    }\"#;\n\n// Strip the comments from the input (use `as_bytes()` to get a `Read`).\nlet stripped = StripComments::new(data.as_bytes());\n// Parse the string of data into serde_json::Value.\nlet v: Value = serde_json::from_reader(stripped)?;\n\nprintln!(\"Please call {} at the number {}\", v[\"name\"], v[\"phones\"][0]);\n\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "json_comments",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "json_comments"
      },
      "additionalTextEdits": []
    },
    {
      "label": "nix",
      "kind": 9,
      "documentation": {
        "kind": "markdown",
        "value": "Rust friendly bindings to the various *nix system functions.\n\nModules are structured according to the C header file that they would be\ndefined in.\n\n# Features\n\nNix uses the following Cargo features to enable optional functionality.\nThey may be enabled in any combination.\n* `acct` - Process accounting\n* `aio` - POSIX AIO\n* `dir` - Stuff relating to directory iteration\n* `env` - Manipulate environment variables\n* `event` - Event-driven APIs, like `kqueue` and `epoll`\n* `fanotify` - Linux's `fanotify` filesystem events monitoring API\n* `feature` - Query characteristics of the OS at runtime\n* `fs` - File system functionality\n* `hostname` - Get and set the system's hostname\n* `inotify` - Linux's `inotify` file system notification API\n* `ioctl` - The `ioctl` syscall, and wrappers for many specific instances\n* `kmod` - Load and unload kernel modules\n* `mman` - Stuff relating to memory management\n* `mount` - Mount and unmount file systems\n* `mqueue` - POSIX message queues\n* `net` - Networking-related functionality\n* `personality` - Set the process execution domain\n* `poll` - APIs like `poll` and `select`\n* `process` - Stuff relating to running processes\n* `pthread` - POSIX threads\n* `ptrace` - Process tracing and debugging\n* `quota` - File system quotas\n* `reboot` - Reboot the system\n* `resource` - Process resource limits\n* `sched` - Manipulate process's scheduling\n* `socket` - Sockets, whether for networking or local use\n* `signal` - Send and receive signals to processes\n* `term` - Terminal control APIs\n* `time` - Query the operating system's clocks\n* `ucontext` - User thread context\n* `uio` - Vectored I/O\n* `user` - Stuff relating to users and groups\n* `zerocopy` - APIs like `sendfile` and `copy_file_range`"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "nix",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "nix"
      },
      "additionalTextEdits": []
    },
    {
      "label": "path_absolutize",
      "kind": 9,
      "documentation": {
        "kind": "markdown",
        "value": "\n# Path Absolutize\n\nThis is a library for extending `Path` and `PathBuf` in order to get an absolute path and remove the containing dots.\n\nThe difference between `absolutize` and `canonicalize` methods is that `absolutize` does not care about whether the file exists and what the file really is.\n\nPlease read the following examples to know the parsing rules.\n\n## Examples\n\nThere are two methods you can use.\n\n### absolutize\n\nGet an absolute path.\n\nThe dots in a path will be parsed even if it is already an absolute path (which means the path starts with a `MAIN_SEPARATOR` on Unix-like systems).\n\n```rust\nuse std::path::Path;\n\nuse path_absolutize::*;\n\nlet p = Path::new(\"/path/to/123/456\");\n\nassert_eq!(\"/path/to/123/456\", p.absolutize().unwrap().to_str().unwrap());\n```\n\n```rust\nuse std::path::Path;\n\nuse path_absolutize::*;\n\nlet p = Path::new(\"/path/to/./123/../456\");\n\nassert_eq!(\"/path/to/456\", p.absolutize().unwrap().to_str().unwrap());\n```\n\nIf a path starts with a single dot, the dot means your program's **current working directory** (CWD).\n\n```rust\nuse std::path::Path;\nuse std::env;\n\nuse path_absolutize::*;\n\nlet p = Path::new(\"./path/to/123/456\");\n\nassert_eq!(Path::join(env::current_dir().unwrap().as_path(), Path::new(\"path/to/123/456\")).to_str().unwrap(), p.absolutize().unwrap().to_str().unwrap());\n```\n\nIf a path starts with a pair of dots, the dots means the parent of the CWD. If the CWD is **root**, the parent is still **root**.\n\n```rust\nuse std::path::Path;\nuse std::env;\n\nuse path_absolutize::*;\n\nlet p = Path::new(\"../path/to/123/456\");\n\nlet cwd = env::current_dir().unwrap();\n\nlet cwd_parent = cwd.parent();\n\nmatch cwd_parent {\n   Some(cwd_parent) => {\n       assert_eq!(Path::join(&cwd_parent, Path::new(\"path/to/123/456\")).to_str().unwrap(), p.absolutize().unwrap().to_str().unwrap());\n   }\n   None => {\n       assert_eq!(Path::join(Path::new(\"/\"), Path::new(\"path/to/123/456\")).to_str().unwrap(), p.absolutize().unwrap().to_str().unwrap());\n   }\n}\n```\n\nA path which does not start with a `MAIN_SEPARATOR`, **Single Dot** and **Double Dots**, will act like having a single dot at the start when `absolutize` method is used.\n\n```rust\nuse std::path::Path;\nuse std::env;\n\nuse path_absolutize::*;\n\nlet p = Path::new(\"path/to/123/456\");\n\nassert_eq!(Path::join(env::current_dir().unwrap().as_path(), Path::new(\"path/to/123/456\")).to_str().unwrap(), p.absolutize().unwrap().to_str().unwrap());\n```\n\n```rust\nuse std::path::Path;\nuse std::env;\n\nuse path_absolutize::*;\n\nlet p = Path::new(\"path/../../to/123/456\");\n\nlet cwd = env::current_dir().unwrap();\n\nlet cwd_parent = cwd.parent();\n\nmatch cwd_parent {\n   Some(cwd_parent) => {\n       assert_eq!(Path::join(&cwd_parent, Path::new(\"to/123/456\")).to_str().unwrap(), p.absolutize().unwrap().to_str().unwrap());\n   }\n   None => {\n       assert_eq!(Path::join(Path::new(\"/\"), Path::new(\"to/123/456\")).to_str().unwrap(), p.absolutize().unwrap().to_str().unwrap());\n   }\n}\n```\n\n### Starting from a given current working directory\n\nWith the `absolutize_from` function, you can provide the current working directory that the relative paths should be resolved from.\n\n```rust\nuse std::env;\nuse std::path::Path;\n\nuse path_absolutize::*;\n\nlet p = Path::new(\"../path/to/123/456\");\nlet cwd = env::current_dir().unwrap();\n\nprintln!(\"{}\", p.absolutize_from(cwd).unwrap().to_str().unwrap());\n```\n\n### absolutize_virtually\n\nGet an absolute path **only under a specific directory**.\n\nThe dots in a path will be parsed even if it is already an absolute path (which means the path starts with a `MAIN_SEPARATOR` on Unix-like systems).\n\n```rust\nuse std::path::Path;\n\nuse path_absolutize::*;\n\nlet p = Path::new(\"/path/to/123/456\");\n\nassert_eq!(\"/path/to/123/456\", p.absolutize_virtually(\"/\").unwrap().to_str().unwrap());\n```\n\n```rust\nuse std::path::Path;\n\nuse path_absolutize::*;\n\nlet p = Path::new(\"/path/to/./123/../456\");\n\nassert_eq!(\"/path/to/456\", p.absolutize_virtually(\"/\").unwrap().to_str().unwrap());\n```\n\nEvery absolute path should under the virtual root.\n\n```rust\nuse std::path::Path;\n\nuse std::io::ErrorKind;\n\nuse path_absolutize::*;\n\nlet p = Path::new(\"/path/to/123/456\");\n\nassert_eq!(ErrorKind::InvalidInput, p.absolutize_virtually(\"/virtual/root\").unwrap_err().kind());\n```\n\nEvery relative path should under the virtual root.\n\n```rust\nuse std::path::Path;\n\nuse std::io::ErrorKind;\n\nuse path_absolutize::*;\n\nlet p = Path::new(\"./path/to/123/456\");\n\nassert_eq!(ErrorKind::InvalidInput, p.absolutize_virtually(\"/virtual/root\").unwrap_err().kind());\n```\n\n```rust\nuse std::path::Path;\n\nuse std::io::ErrorKind;\n\nuse path_absolutize::*;\n\nlet p = Path::new(\"../path/to/123/456\");\n\nassert_eq!(ErrorKind::InvalidInput, p.absolutize_virtually(\"/virtual/root\").unwrap_err().kind());\n```\n\nA path which does not start with a `MAIN_SEPARATOR`, **Single Dot** and **Double Dots**, will be located in the virtual root after the `absolutize_virtually` method is used.\n\n```rust\nuse std::path::Path;\n\nuse path_absolutize::*;\n\nlet p = Path::new(\"path/to/123/456\");\n\nassert_eq!(\"/virtual/root/path/to/123/456\", p.absolutize_virtually(\"/virtual/root\").unwrap().to_str().unwrap());\n```\n\n```rust\nuse std::path::Path;\n\nuse path_absolutize::*;\n\nlet p = Path::new(\"path/to/../../../../123/456\");\n\nassert_eq!(\"/virtual/root/123/456\", p.absolutize_virtually(\"/virtual/root\").unwrap().to_str().unwrap());\n```\n\n## Caching\n\nBy default, the `absolutize` method and the `absolutize_virtually` method create a new `PathBuf` instance of the CWD every time in their operation. The overhead is obvious. Although it allows us to safely change the CWD at runtime by the program itself (e.g. using the `std::env::set_current_dir` function) or outside controls (e.g. using gdb to call `chdir`), we don't need that in most cases.\n\nIn order to parse paths with better performance, this crate provides three ways to cache the CWD.\n\n### once_cell_cache\n\nEnabling the `once_cell_cache` feature can let this crate use `once_cell` to cache the CWD. It's thread-safe and does not need to modify any code, but once the CWD is cached, it cannot be changed anymore at runtime.\n\n```toml\n[dependencies.path-absolutize]\nversion = \"*\"\nfeatures = [\"once_cell_cache\"]\n```\n\n### lazy_static_cache\n\nEnabling the `lazy_static_cache` feature can let this crate use `lazy_static` to cache the CWD. It's thread-safe and does not need to modify any code, but once the CWD is cached, it cannot be changed anymore at runtime.\n\n```toml\n[dependencies.path-absolutize]\nversion = \"*\"\nfeatures = [\"lazy_static_cache\"]\n```\n\n### unsafe_cache\n\nEnabling the `unsafe_cache` feature can let this crate use a mutable static variable to cache the CWD. It allows the program to change the CWD at runtime by the program itself, but it's not thread-safe.\n\nYou need to use the `update_cwd` function to initialize the CWD first. The function should also be used to update the CWD after the CWD is changed.\n\n```toml\n[dependencies.path-absolutize]\nversion = \"*\"\nfeatures = [\"unsafe_cache\"]\n```\n\n```rust\nuse std::path::Path;\n\nuse path_absolutize::*;\n\nunsafe {\n    update_cwd();\n}\n\nlet p = Path::new(\"./path/to/123/456\");\n\nprintln!(\"{}\", p.absolutize().unwrap().to_str().unwrap());\n\nstd::env::set_current_dir(\"/\").unwrap();\n\nunsafe {\n    update_cwd();\n}\n\nprintln!(\"{}\", p.absolutize().unwrap().to_str().unwrap());\n```\n\n## Benchmark\n\n#### No-cache\n\n```bash\ncargo bench\n```\n\n#### once_cell_cache\n\n```bash\ncargo bench --features once_cell_cache\n```\n\n#### lazy_static_cache\n\n```bash\ncargo bench --features lazy_static_cache\n```\n\n#### unsafe_cache\n\n```bash\ncargo bench --features unsafe_cache\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "path_absolutize",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "path_absolutize"
      },
      "additionalTextEdits": []
    },
    {
      "label": "std",
      "kind": 9,
      "documentation": {
        "kind": "markdown",
        "value": "# The Rust Standard Library\n\nThe Rust Standard Library is the foundation of portable Rust software, a\nset of minimal and battle-tested shared abstractions for the [broader Rust\necosystem][crates.io]. It offers core types, like [`Vec<T>`] and\n[`Option<T>`], library-defined [operations on language\nprimitives](#primitives), [standard macros](#macros), [I/O] and\n[multithreading], among [many other things][other].\n\n`std` is available to all Rust crates by default. Therefore, the\nstandard library can be accessed in [`use`] statements through the path\n`std`, as in [`use std::env`].\n\n# How to read this documentation\n\nIf you already know the name of what you are looking for, the fastest way to\nfind it is to use the <a href=\"#\" onclick=\"window.searchState.focus();\">search\nbar</a> at the top of the page.\n\nOtherwise, you may want to jump to one of these useful sections:\n\n* [`std::*` modules](#modules)\n* [Primitive types](#primitives)\n* [Standard macros](#macros)\n* [The Rust Prelude]\n\nIf this is your first time, the documentation for the standard library is\nwritten to be casually perused. Clicking on interesting things should\ngenerally lead you to interesting places. Still, there are important bits\nyou don't want to miss, so read on for a tour of the standard library and\nits documentation!\n\nOnce you are familiar with the contents of the standard library you may\nbegin to find the verbosity of the prose distracting. At this stage in your\ndevelopment you may want to press the <code>\n<svg style=\"width:0.75rem;height:0.75rem\" viewBox=\"0 0 12 12\"\nstroke=\"currentColor\" fill=\"none\">\n<path d=\"M2,2l4,4l4,-4M2,6l4,4l4,-4\"/></svg> Summary</code> button near the\ntop of the page to collapse it into a more skimmable view.\n\nWhile you are looking at the top of the page, also notice the\n<code>source</code> link. Rust's API documentation comes with the source\ncode and you are encouraged to read it. The standard library source is\ngenerally high quality and a peek behind the curtains is\noften enlightening.\n\n# What is in the standard library documentation?\n\nFirst of all, The Rust Standard Library is divided into a number of focused\nmodules, [all listed further down this page](#modules). These modules are\nthe bedrock upon which all of Rust is forged, and they have mighty names\nlike [`std::slice`] and [`std::cmp`]. Modules' documentation typically\nincludes an overview of the module along with examples, and are a smart\nplace to start familiarizing yourself with the library.\n\nSecond, implicit methods on [primitive types] are documented here. This can\nbe a source of confusion for two reasons:\n\n1. While primitives are implemented by the compiler, the standard library\n   implements methods directly on the primitive types (and it is the only\n   library that does so), which are [documented in the section on\n   primitives](#primitives).\n2. The standard library exports many modules *with the same name as\n   primitive types*. These define additional items related to the primitive\n   type, but not the all-important methods.\n\nSo for example there is a [page for the primitive type\n`i32`](primitive::i32) that lists all the methods that can be called on\n32-bit integers (very useful), and there is a [page for the module\n`std::i32`] that documents the constant values [`MIN`] and [`MAX`] (rarely\nuseful).\n\nNote the documentation for the primitives [`str`] and [`[T]`][prim@slice] (also\ncalled 'slice'). Many method calls on [`String`] and [`Vec<T>`] are actually\ncalls to methods on [`str`] and [`[T]`][prim@slice] respectively, via [deref\ncoercions][deref-coercions].\n\nThird, the standard library defines [The Rust Prelude], a small collection\nof items - mostly traits - that are imported into every module of every\ncrate. The traits in the prelude are pervasive, making the prelude\ndocumentation a good entry point to learning about the library.\n\nAnd finally, the standard library exports a number of standard macros, and\n[lists them on this page](#macros) (technically, not all of the standard\nmacros are defined by the standard library - some are defined by the\ncompiler - but they are documented here the same). Like the prelude, the\nstandard macros are imported by default into all crates.\n\n# Contributing changes to the documentation\n\nCheck out the Rust contribution guidelines [here](\nhttps://rustc-dev-guide.rust-lang.org/contributing.html#writing-documentation).\nThe source for this documentation can be found on\n[GitHub](https://github.com/rust-lang/rust).\nTo contribute changes, make sure you read the guidelines first, then submit\npull-requests for your suggested changes.\n\nContributions are appreciated! If you see a part of the docs that can be\nimproved, submit a PR, or chat with us first on [Discord][rust-discord]\n#docs.\n\n# A Tour of The Rust Standard Library\n\nThe rest of this crate documentation is dedicated to pointing out notable\nfeatures of The Rust Standard Library.\n\n## Containers and collections\n\nThe [`option`] and [`result`] modules define optional and error-handling\ntypes, [`Option<T>`] and [`Result<T, E>`]. The [`iter`] module defines\nRust's iterator trait, [`Iterator`], which works with the [`for`] loop to\naccess collections.\n\nThe standard library exposes three common ways to deal with contiguous\nregions of memory:\n\n* [`Vec<T>`] - A heap-allocated *vector* that is resizable at runtime.\n* [`[T; N]`][prim@array] - An inline *array* with a fixed size at compile time.\n* [`[T]`][prim@slice] - A dynamically sized *slice* into any other kind of contiguous\n  storage, whether heap-allocated or not.\n\nSlices can only be handled through some kind of *pointer*, and as such come\nin many flavors such as:\n\n* `&[T]` - *shared slice*\n* `&mut [T]` - *mutable slice*\n* [`Box<[T]>`][owned slice] - *owned slice*\n\n[`str`], a UTF-8 string slice, is a primitive type, and the standard library\ndefines many methods for it. Rust [`str`]s are typically accessed as\nimmutable references: `&str`. Use the owned [`String`] for building and\nmutating strings.\n\nFor converting to strings use the [`format!`] macro, and for converting from\nstrings use the [`FromStr`] trait.\n\nData may be shared by placing it in a reference-counted box or the [`Rc`]\ntype, and if further contained in a [`Cell`] or [`RefCell`], may be mutated\nas well as shared. Likewise, in a concurrent setting it is common to pair an\natomically-reference-counted box, [`Arc`], with a [`Mutex`] to get the same\neffect.\n\nThe [`collections`] module defines maps, sets, linked lists and other\ntypical collection types, including the common [`HashMap<K, V>`].\n\n## Platform abstractions and I/O\n\nBesides basic data types, the standard library is largely concerned with\nabstracting over differences in common platforms, most notably Windows and\nUnix derivatives.\n\nCommon types of I/O, including [files], [TCP], and [UDP], are defined in\nthe [`io`], [`fs`], and [`net`] modules.\n\nThe [`thread`] module contains Rust's threading abstractions. [`sync`]\ncontains further primitive shared memory types, including [`atomic`], [`mpmc`] and\n[`mpsc`], which contains the channel types for message passing.\n\n# Use before and after `main()`\n\nMany parts of the standard library are expected to work before and after `main()`;\nbut this is not guaranteed or ensured by tests. It is recommended that you write your own tests\nand run them on each platform you wish to support.\nThis means that use of `std` before/after main, especially of features that interact with the\nOS or global state, is exempted from stability and portability guarantees and instead only\nprovided on a best-effort basis. Nevertheless bug reports are appreciated.\n\nOn the other hand `core` and `alloc` are most likely to work in such environments with\nthe caveat that any hookable behavior such as panics, oom handling or allocators will also\ndepend on the compatibility of the hooks.\n\nSome features may also behave differently outside main, e.g. stdio could become unbuffered,\nsome panics might turn into aborts, backtraces might not get symbolicated or similar.\n\nNon-exhaustive list of known limitations:\n\n- after-main use of thread-locals, which also affects additional features:\n  - [`thread::current()`]\n  - [`thread::scope()`]\n  - [`sync::mpmc`]\n  - [`sync::mpsc`]\n- before-main stdio file descriptors are not guaranteed to be open on unix platforms\n\n\n[I/O]: io\n[`MIN`]: i32::MIN\n[`MAX`]: i32::MAX\n[page for the module `std::i32`]: crate::i32\n[TCP]: net::TcpStream\n[The Rust Prelude]: prelude\n[UDP]: net::UdpSocket\n[`Arc`]: sync::Arc\n[owned slice]: boxed\n[`Cell`]: cell::Cell\n[`FromStr`]: str::FromStr\n[`HashMap<K, V>`]: collections::HashMap\n[`Mutex`]: sync::Mutex\n[`Option<T>`]: option::Option\n[`Rc`]: rc::Rc\n[`RefCell`]: cell::RefCell\n[`Result<T, E>`]: result::Result\n[`Vec<T>`]: vec::Vec\n[`atomic`]: sync::atomic\n[`for`]: ../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n[`str`]: prim@str\n[`mpmc`]: sync::mpmc\n[`mpsc`]: sync::mpsc\n[`std::cmp`]: cmp\n[`std::slice`]: mod@slice\n[`use std::env`]: env/index.html\n[`use`]: ../book/ch07-02-defining-modules-to-control-scope-and-privacy.html\n[crates.io]: https://crates.io\n[deref-coercions]: ../book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods\n[files]: fs::File\n[multithreading]: thread\n[other]: #what-is-in-the-standard-library-documentation\n[primitive types]: ../book/ch03-02-data-types.html\n[rust-discord]: https://discord.gg/rust-lang\n[array]: prim@array\n[slice]: prim@slice"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "std",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "std"
      },
      "additionalTextEdits": []
    },
    {
      "label": "reqwest",
      "kind": 9,
      "documentation": {
        "kind": "markdown",
        "value": "# reqwest\n\nThe `reqwest` crate provides a convenient, higher-level HTTP\n[`Client`][client].\n\nIt handles many of the things that most people just expect an HTTP client\nto do for them.\n\n- Async and [blocking] Clients\n- Plain bodies, [JSON](#json), [urlencoded](#forms), [multipart]\n- Customizable [redirect policy](#redirect-policies)\n- HTTP [Proxies](#proxies)\n- Uses [TLS](#tls) by default\n- Cookies\n\nThe [`reqwest::Client`][client] is asynchronous. For applications wishing\nto only make a few HTTP requests, the [`reqwest::blocking`](blocking) API\nmay be more convenient.\n\nAdditional learning resources include:\n\n- [The Rust Cookbook](https://rust-lang-nursery.github.io/rust-cookbook/web/clients.html)\n- [Reqwest Repository Examples](https://github.com/seanmonstar/reqwest/tree/master/examples)\n\n## Making a GET request\n\nFor a single request, you can use the [`get`][get] shortcut method.\n\n```rust\nlet body = reqwest::get(\"https://www.rust-lang.org\")\n    .await?\n    .text()\n    .await?;\n\nprintln!(\"body = {:?}\", body);\n```\n\n**NOTE**: If you plan to perform multiple requests, it is best to create a\n[`Client`][client] and reuse it, taking advantage of keep-alive connection\npooling.\n\n## Making POST requests (or setting request bodies)\n\nThere are several ways you can set the body of a request. The basic one is\nby using the `body()` method of a [`RequestBuilder`][builder]. This lets you set the\nexact raw bytes of what the body should be. It accepts various types,\nincluding `String` and `Vec<u8>`. If you wish to pass a custom\ntype, you can use the `reqwest::Body` constructors.\n\n```rust\nlet client = reqwest::Client::new();\nlet res = client.post(\"http://httpbin.org/post\")\n    .body(\"the exact body that is sent\")\n    .send()\n    .await?;\n```\n\n### Forms\n\nIt's very common to want to send form data in a request body. This can be\ndone with any type that can be serialized into form data.\n\nThis can be an array of tuples, or a `HashMap`, or a custom type that\nimplements [`Serialize`][serde].\n\n```rust\n// This will POST a body of `foo=bar&baz=quux`\nlet params = [(\"foo\", \"bar\"), (\"baz\", \"quux\")];\nlet client = reqwest::Client::new();\nlet res = client.post(\"http://httpbin.org/post\")\n    .form(&params)\n    .send()\n    .await?;\n```\n\n### JSON\n\nThere is also a `json` method helper on the [`RequestBuilder`][builder] that works in\na similar fashion the `form` method. It can take any value that can be\nserialized into JSON. The feature `json` is required.\n\n```rust\n// This will POST a body of `{\"lang\":\"rust\",\"body\":\"json\"}`\nlet mut map = HashMap::new();\nmap.insert(\"lang\", \"rust\");\nmap.insert(\"body\", \"json\");\n\nlet client = reqwest::Client::new();\nlet res = client.post(\"http://httpbin.org/post\")\n    .json(&map)\n    .send()\n    .await?;\n```\n\n## Redirect Policies\n\nBy default, a `Client` will automatically handle HTTP redirects, having a\nmaximum redirect chain of 10 hops. To customize this behavior, a\n[`redirect::Policy`][redirect] can be used with a `ClientBuilder`.\n\n## Cookies\n\nThe automatic storing and sending of session cookies can be enabled with\nthe [`cookie_store`][ClientBuilder::cookie_store] method on `ClientBuilder`.\n\n## Proxies\n\n**NOTE**: System proxies are enabled by default.\n\nSystem proxies look in environment variables to set HTTP or HTTPS proxies.\n\n`HTTP_PROXY` or `http_proxy` provide http proxies for http connections while\n`HTTPS_PROXY` or `https_proxy` provide HTTPS proxies for HTTPS connections.\n\nThese can be overwritten by adding a [`Proxy`] to `ClientBuilder`\ni.e. `let proxy = reqwest::Proxy::http(\"https://secure.example\")?;`\nor disabled by calling `ClientBuilder::no_proxy()`.\n\n`socks` feature is required if you have configured socks proxy like this:\n\n```bash\nexport https_proxy=socks5://127.0.0.1:1086\n```\n\n## TLS\n\nA `Client` will use transport layer security (TLS) by default to connect to\nHTTPS destinations.\n\n- Additional server certificates can be configured on a `ClientBuilder`\n  with the [`Certificate`] type.\n- Client certificates can be added to a `ClientBuilder` with the\n  [`Identity`] type.\n- Various parts of TLS can also be configured or even disabled on the\n  `ClientBuilder`.\n\nSee more details in the [`tls`] module.\n\n## WASM\n\nThe Client implementation automatically switches to the WASM one when the target_arch is wasm32,\nthe usage is basically the same as the async api. Some of the features are disabled in wasm\n: [`tls`], [`cookie`], [`blocking`].\n\n\n## Optional Features\n\nThe following are a list of [Cargo features][cargo-features] that can be\nenabled or disabled:\n\n- **default-tls** *(enabled by default)*: Provides TLS support to connect\n  over HTTPS.\n- **native-tls**: Enables TLS functionality provided by `native-tls`.\n- **native-tls-vendored**: Enables the `vendored` feature of `native-tls`.\n- **native-tls-alpn**: Enables the `alpn` feature of `native-tls`.\n- **rustls-tls**: Enables TLS functionality provided by `rustls`.\n  Equivalent to `rustls-tls-webpki-roots`.\n- **rustls-tls-manual-roots**: Enables TLS functionality provided by `rustls`,\n  without setting any root certificates. Roots have to be specified manually.\n- **rustls-tls-webpki-roots**: Enables TLS functionality provided by `rustls`,\n  while using root certificates from the `webpki-roots` crate.\n- **rustls-tls-native-roots**: Enables TLS functionality provided by `rustls`,\n  while using root certificates from the `rustls-native-certs` crate.\n- **blocking**: Provides the [blocking][] client API.\n- **cookies**: Provides cookie session support.\n- **gzip**: Provides response body gzip decompression.\n- **brotli**: Provides response body brotli decompression.\n- **deflate**: Provides response body deflate decompression.\n- **json**: Provides serialization and deserialization for JSON bodies.\n- **multipart**: Provides functionality for multipart forms.\n- **stream**: Adds support for `futures::Stream`.\n- **socks**: Provides SOCKS5 proxy support.\n- **trust-dns**: Enables a trust-dns async resolver instead of default\n  threadpool using `getaddrinfo`.\n\n## Unstable Features\n\nSome feature flags require additional opt-in by the application, by setting\na `reqwest_unstable` flag.\n\n- **http3** *(unstable)*: Enables support for sending HTTP/3 requests.\n\nThese features are unstable, and experimental. Details about them may be\nchanged in patch releases.\n\nYou can pass such a flag to the compiler via `.cargo/config`, or\nenvironment variables, such as:\n\n```notrust\nRUSTFLAGS=\"--cfg reqwest_unstable\" cargo build\n```\n\n[hyper]: http://hyper.rs\n[blocking]: ./blocking/index.html\n[client]: ./struct.Client.html\n[response]: ./struct.Response.html\n[get]: ./fn.get.html\n[builder]: ./struct.RequestBuilder.html\n[serde]: http://serde.rs\n[redirect]: crate::redirect\n[Proxy]: ./struct.Proxy.html\n[cargo-features]: https://doc.rust-lang.org/stable/cargo/reference/manifest.html#the-features-section"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "reqwest",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "reqwest"
      },
      "additionalTextEdits": []
    },
    {
      "label": "ropey",
      "kind": 9,
      "documentation": {
        "kind": "markdown",
        "value": "Ropey is a utf8 text rope for Rust.  It is fast, robust, and can handle\nhuge texts and memory-incoherent edits with ease.\n\nRopey's atomic unit of text is Unicode scalar values (or `char`s in Rust)\nencoded as utf8.  All of Ropey's editing and slicing operations are done\nin terms of char indices, which prevents accidental creation of invalid\nutf8 data.\n\nThe library is made up of four main components:\n\n- [`Rope`]: the main rope type.\n- [`RopeSlice`]: an immutable view into part of a\n  `Rope`.\n- [`iter`]: iterators over `Rope`/`RopeSlice` data.\n- [`RopeBuilder`]: an efficient incremental\n  `Rope` builder.\n\n\n# A Basic Example\n\nLet's say we want to open up a text file, replace the 516th line (the\nwriting was terrible!), and save it back to disk.  It's contrived, but will\ngive a good sampling of the APIs and how they work together.\n\n```rust\nuse std::fs::File;\nuse std::io::{BufReader, BufWriter};\nuse ropey::Rope;\n\n// Load a text file.\nlet mut text = Rope::from_reader(\n    BufReader::new(File::open(\"my_great_book.txt\")?)\n)?;\n\n// Print the 516th line (zero-indexed) to see the terrible\n// writing.\nprintln!(\"{}\", text.line(515));\n\n// Get the start/end char indices of the line.\nlet start_idx = text.line_to_char(515);\nlet end_idx = text.line_to_char(516);\n\n// Remove the line...\ntext.remove(start_idx..end_idx);\n\n// ...and replace it with something better.\ntext.insert(start_idx, \"The flowers are... so... dunno.\\n\");\n\n// Print the changes, along with the previous few lines for context.\nlet start_idx = text.line_to_char(511);\nlet end_idx = text.line_to_char(516);\nprintln!(\"{}\", text.slice(start_idx..end_idx));\n\n// Write the file back out to disk.\ntext.write_to(\n    BufWriter::new(File::create(\"my_great_book.txt\")?)\n)?;\n```\n\nMore examples can be found in the `examples` directory of the git\nrepository.  Many of those examples demonstrate doing non-trivial things\nwith Ropey such as grapheme handling, search-and-replace, and streaming\nloading of non-utf8 text files.\n\n\n# Low-level APIs\n\nRopey also provides access to some of its low-level APIs, enabling client\ncode to efficiently work with a `Rope`'s data and implement new\nfunctionality.  The most important of those API's are:\n\n- The [`chunk_at_*()`](Rope::chunk_at_byte)\n  chunk-fetching methods of `Rope` and `RopeSlice`.\n- The [`Chunks`](iter::Chunks) iterator.\n- The functions in [`str_utils`] for operating on\n  `&str` slices.\n\nInternally, each `Rope` stores text as a segemented collection of utf8\nstrings.  The chunk-fetching methods and `Chunks` iterator provide direct\naccess to those strings (or \"chunks\") as `&str` slices, allowing client\ncode to work directly with the underlying utf8 data.\n\nThe chunk-fetching methods and `str_utils` functions are the basic\nbuilding blocks that Ropey itself uses to build much of its functionality.\nFor example, the [`Rope::byte_to_char()`]\nmethod can be reimplemented as a free function like this:\n\n```rust\nuse ropey::{\n    Rope,\n    str_utils::byte_to_char_idx\n};\n\nfn byte_to_char(rope: &Rope, byte_idx: usize) -> usize {\n    let (chunk, b, c, _) = rope.chunk_at_byte(byte_idx);\n    c + byte_to_char_idx(chunk, byte_idx - b)\n}\n```\n\nAnd this will be just as efficient as Ropey's implementation.\n\nThe chunk-fetching methods in particular are among the fastest functions\nthat Ropey provides, generally operating in the sub-hundred nanosecond\nrange for medium-sized (~200kB) documents on recent-ish computer systems.\n\n\n# A Note About Line Breaks\n\nSome of Ropey's APIs use the concept of line breaks or lines of text.\n\nRopey considers the start of the rope and positions immediately\n_after_ line breaks to be the start of new lines.  And it treats\nline breaks as being a part of the lines they mark the end of.\n\nFor example, the rope `\"Hello\"` has a single line: `\"Hello\"`.  The\nrope `\"Hello\\nworld\"` has two lines: `\"Hello\\n\"` and `\"world\"`.  And\nthe rope `\"Hello\\nworld\\n\"` has three lines: `\"Hello\\n\"`,\n`\"world\\n\"`, and `\"\"`.\n\nRopey can be configured at build time via feature flags to recognize\ndifferent line breaks.  Ropey always recognizes:\n\n- `U+000A`          &mdash; LF (Line Feed)\n- `U+000D` `U+000A` &mdash; CRLF (Carriage Return + Line Feed)\n\nWith the `cr_lines` feature, the following are also recognized:\n\n- `U+000D`          &mdash; CR (Carriage Return)\n\nWith the `unicode_lines` feature, in addition to all of the\nabove, the following are also recognized (bringing Ropey into\nconformance with\n[Unicode Annex #14](https://www.unicode.org/reports/tr14/#BK)):\n\n- `U+000B`          &mdash; VT (Vertical Tab)\n- `U+000C`          &mdash; FF (Form Feed)\n- `U+0085`          &mdash; NEL (Next Line)\n- `U+2028`          &mdash; Line Separator\n- `U+2029`          &mdash; Paragraph Separator\n\n(Note: `unicode_lines` is enabled by default, and always implies\n`cr_lines`.)\n\nCRLF pairs are always treated as a single line break, and are never split\nacross chunks.  Note, however, that slicing can still split them.\n\n\n# A Note About SIMD Acceleration\n\nRopey has a `simd` feature flag (enabled by default) that enables\nexplicit SIMD on supported platforms to improve performance.\n\nThere is a bit of a footgun here: if you disable default features to\nconfigure line break behavior (as per the section above) then SIMD\nwill also get disabled, and performance will suffer.  So be careful\nto explicitly re-enable the `simd` feature flag (if desired) when\ndoing that."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "ropey",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "ropey"
      },
      "additionalTextEdits": []
    },
    {
      "label": "textwrap",
      "kind": 9,
      "documentation": {
        "kind": "markdown",
        "value": "The textwrap library provides functions for word wrapping and\nindenting text.\n\n# Wrapping Text\n\nWrapping text can be very useful in command-line programs where\nyou want to format dynamic output nicely so it looks good in a\nterminal. A quick example:\n\n```rust\nlet text = \"textwrap: a small library for wrapping text.\";\nassert_eq!(textwrap::wrap(text, 18),\n           vec![\"textwrap: a\",\n                \"small library for\",\n                \"wrapping text.\"]);\n```\n\nThe [`wrap()`] function returns the individual lines, use\n[`fill()`] is you want the lines joined with `'\\n'` to form a\n`String`.\n\nIf you enable the `hyphenation` Cargo feature, you can get\nautomatic hyphenation for a number of languages:\n\n```rust\n#[cfg(feature = \"hyphenation\")] {\nuse hyphenation::{Language, Load, Standard};\nuse textwrap::{wrap, Options, WordSplitter};\n\nlet text = \"textwrap: a small library for wrapping text.\";\nlet dictionary = Standard::from_embedded(Language::EnglishUS).unwrap();\nlet options = Options::new(18).word_splitter(WordSplitter::Hyphenation(dictionary));\nassert_eq!(wrap(text, &options),\n           vec![\"textwrap: a small\",\n                \"library for wrap-\",\n                \"ping text.\"]);\n}\n```\n\nSee also the [`unfill()`] and [`refill()`] functions which allow\nyou to manipulate already wrapped text.\n\n## Wrapping Strings at Compile Time\n\nIf your strings are known at compile time, please take a look at\nthe procedural macros from the [textwrap-macros] crate.\n\n## Displayed Width vs Byte Size\n\nTo word wrap text, one must know the width of each word so one can\nknow when to break lines. This library will by default measure the\nwidth of text using the _displayed width_, not the size in bytes.\nThe `unicode-width` Cargo feature controls this.\n\nThis is important for non-ASCII text. ASCII characters such as `a`\nand `!` are simple and take up one column each. This means that\nthe displayed width is equal to the string length in bytes.\nHowever, non-ASCII characters and symbols take up more than one\nbyte when UTF-8 encoded: `é` is `0xc3 0xa9` (two bytes) and `⚙` is\n`0xe2 0x9a 0x99` (three bytes) in UTF-8, respectively.\n\nThis is why we take care to use the displayed width instead of the\nbyte count when computing line lengths. All functions in this\nlibrary handle Unicode characters like this when the\n`unicode-width` Cargo feature is enabled (it is enabled by\ndefault).\n\n# Indentation and Dedentation\n\nThe textwrap library also offers functions for adding a prefix to\nevery line of a string and to remove leading whitespace. As an\nexample, [`indent()`] allows you to turn lines of text into a\nbullet list:\n\n```rust\nlet before = \"\\\nfoo\nbar\nbaz\n\";\nlet after = \"\\\n* foo\n* bar\n* baz\n\";\nassert_eq!(textwrap::indent(before, \"* \"), after);\n```\n\nRemoving leading whitespace is done with [`dedent()`]:\n\n```rust\nlet before = \"\n    Some\n      indented\n        text\n\";\nlet after = \"\nSome\n  indented\n    text\n\";\nassert_eq!(textwrap::dedent(before), after);\n```\n\n# Cargo Features\n\nThe textwrap library can be slimmed down as needed via a number of\nCargo features. This means you only pay for the features you\nactually use.\n\nThe full dependency graph, where dashed lines indicate optional\ndependencies, is shown below:\n\n<img src=\"https://raw.githubusercontent.com/mgeisler/textwrap/master/images/textwrap-0.16.1.svg\">\n\n## Default Features\n\nThese features are enabled by default:\n\n* `unicode-linebreak`: enables finding words using the\n  [unicode-linebreak] crate, which implements the line breaking\n  algorithm described in [Unicode Standard Annex\n  #14](https://www.unicode.org/reports/tr14/).\n\n  This feature can be disabled if you are happy to find words\n  separated by ASCII space characters only. People wrapping text\n  with emojis or East-Asian characters will want most likely want\n  to enable this feature. See [`WordSeparator`] for details.\n\n* `unicode-width`: enables correct width computation of non-ASCII\n  characters via the [unicode-width] crate. Without this feature,\n  every [`char`] is 1 column wide, except for emojis which are 2\n  columns wide. See [`core::display_width()`] for details.\n\n  This feature can be disabled if you only need to wrap ASCII\n  text, or if the functions in [`core`] are used directly with\n  [`core::Fragment`]s for which the widths have been computed in\n  other ways.\n\n* `smawk`: enables linear-time wrapping of the whole paragraph via\n  the [smawk] crate. See [`wrap_algorithms::wrap_optimal_fit()`]\n  for details on the optimal-fit algorithm.\n\n  This feature can be disabled if you only ever intend to use\n  [`wrap_algorithms::wrap_first_fit()`].\n\n<!-- begin binary-sizes -->\n\nWith Rust 1.64.0, the size impact of the above features on your\nbinary is as follows:\n\n| Configuration                            |  Binary Size |    Delta |\n| :---                                     |         ---: |     ---: |\n| quick-and-dirty implementation           |       289 KB |     — KB |\n| textwrap without default features        |       305 KB |    16 KB |\n| textwrap with smawk                      |       317 KB |    28 KB |\n| textwrap with unicode-width              |       309 KB |    20 KB |\n| textwrap with unicode-linebreak          |       342 KB |    53 KB |\n\n<!-- end binary-sizes -->\n\nThe above sizes are the stripped sizes and the binary is compiled\nin release mode with this profile:\n\n```toml\n[profile.release]\nlto = true\ncodegen-units = 1\n```\n\nSee the [binary-sizes demo] if you want to reproduce these\nresults.\n\n## Optional Features\n\nThese Cargo features enable new functionality:\n\n* `terminal_size`: enables automatic detection of the terminal\n  width via the [terminal_size] crate. See\n  [`Options::with_termwidth()`] for details.\n\n* `hyphenation`: enables language-sensitive hyphenation via the\n  [hyphenation] crate. See the [`word_splitters::WordSplitter`]\n  trait for details.\n\n[unicode-linebreak]: https://docs.rs/unicode-linebreak/\n[unicode-width]: https://docs.rs/unicode-width/\n[smawk]: https://docs.rs/smawk/\n[binary-sizes demo]: https://github.com/mgeisler/textwrap/tree/master/examples/binary-sizes\n[textwrap-macros]: https://docs.rs/textwrap-macros/\n[terminal_size]: https://docs.rs/terminal_size/\n[hyphenation]: https://docs.rs/hyphenation/"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "textwrap",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "textwrap"
      },
      "additionalTextEdits": []
    },
    {
      "label": "toml",
      "kind": 9,
      "documentation": {
        "kind": "markdown",
        "value": "A [serde]-compatible [TOML]-parsing library\n\nTOML itself is a simple, ergonomic, and readable configuration format:\n\n```toml\n[package]\nname = \"toml\"\nversion = \"0.4.2\"\nauthors = [\"Alex Crichton <alex@alexcrichton.com>\"]\n\n[dependencies]\nserde = \"1.0\"\n```\n\nThe TOML format tends to be relatively common throughout the Rust community\nfor configuration, notably being used by [Cargo], Rust's package manager.\n\n## TOML values\n\nA TOML document is represented with the [`Table`] type which maps `String` to the [`Value`] enum:\n\n```rust\npub enum Value {\n    String(String),\n    Integer(i64),\n    Float(f64),\n    Boolean(bool),\n    Datetime(Datetime),\n    Array(Array),\n    Table(Table),\n}\n```\n\n## Parsing TOML\n\nThe easiest way to parse a TOML document is via the [`Table`] type:\n\n```rust\nuse toml::Table;\n\nlet value = \"foo = 'bar'\".parse::<Table>().unwrap();\n\nassert_eq!(value[\"foo\"].as_str(), Some(\"bar\"));\n```\n\nThe [`Table`] type implements a number of convenience methods and\ntraits; the example above uses [`FromStr`] to parse a [`str`] into a\n[`Table`].\n\n## Deserialization and Serialization\n\nThis crate supports [`serde`] 1.0 with a number of\nimplementations of the `Deserialize`, `Serialize`, `Deserializer`, and\n`Serializer` traits. Namely, you'll find:\n\n* `Deserialize for Table`\n* `Serialize for Table`\n* `Deserialize for Value`\n* `Serialize for Value`\n* `Deserialize for Datetime`\n* `Serialize for Datetime`\n* `Deserializer for de::Deserializer`\n* `Serializer for ser::Serializer`\n* `Deserializer for Table`\n* `Deserializer for Value`\n\nThis means that you can use Serde to deserialize/serialize the\n[`Table`] type as well as [`Value`] and [`Datetime`] type in this crate. You can also\nuse the [`Deserializer`], [`Serializer`], or [`Table`] type itself to act as\na deserializer/serializer for arbitrary types.\n\nAn example of deserializing with TOML is:\n\n```rust\nuse serde::Deserialize;\n\n#[derive(Deserialize)]\nstruct Config {\n    ip: String,\n    port: Option<u16>,\n    keys: Keys,\n}\n\n#[derive(Deserialize)]\nstruct Keys {\n    github: String,\n    travis: Option<String>,\n}\n\nlet config: Config = toml::from_str(r#\"\n    ip = '127.0.0.1'\n\n    [keys]\n    github = 'xxxxxxxxxxxxxxxxx'\n    travis = 'yyyyyyyyyyyyyyyyy'\n\"#).unwrap();\n\nassert_eq!(config.ip, \"127.0.0.1\");\nassert_eq!(config.port, None);\nassert_eq!(config.keys.github, \"xxxxxxxxxxxxxxxxx\");\nassert_eq!(config.keys.travis.as_ref().unwrap(), \"yyyyyyyyyyyyyyyyy\");\n```\n\nYou can serialize types in a similar fashion:\n\n```rust\nuse serde::Serialize;\n\n#[derive(Serialize)]\nstruct Config {\n    ip: String,\n    port: Option<u16>,\n    keys: Keys,\n}\n\n#[derive(Serialize)]\nstruct Keys {\n    github: String,\n    travis: Option<String>,\n}\n\nlet config = Config {\n    ip: \"127.0.0.1\".to_string(),\n    port: None,\n    keys: Keys {\n        github: \"xxxxxxxxxxxxxxxxx\".to_string(),\n        travis: Some(\"yyyyyyyyyyyyyyyyy\".to_string()),\n    },\n};\n\nlet toml = toml::to_string(&config).unwrap();\n```\n\n[TOML]: https://github.com/toml-lang/toml\n[Cargo]: https://crates.io/\n[`serde`]: https://serde.rs/\n[serde]: https://serde.rs/"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "toml",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "toml"
      },
      "additionalTextEdits": []
    },
    {
      "label": "anyhow",
      "kind": 9,
      "documentation": {
        "kind": "markdown",
        "value": "[![github]](https://github.com/dtolnay/anyhow)&ensp;[![crates-io]](https://crates.io/crates/anyhow)&ensp;[![docs-rs]](https://docs.rs/anyhow)\n\n[github]: https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github\n[crates-io]: https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust\n[docs-rs]: https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs\n\n<br>\n\nThis library provides [`anyhow::Error`][Error], a trait object based error\ntype for easy idiomatic error handling in Rust applications.\n\n<br>\n\n# Details\n\n- Use `Result<T, anyhow::Error>`, or equivalently `anyhow::Result<T>`, as\n  the return type of any fallible function.\n\n  Within the function, use `?` to easily propagate any error that implements\n  the `std::error::Error` trait.\n\n  ```\n  # pub trait Deserialize {}\n  #\n  # mod serde_json {\n  #     use super::Deserialize;\n  #     use std::io;\n  #\n  #     pub fn from_str<T: Deserialize>(json: &str) -> io::Result<T> {\n  #         unimplemented!()\n  #     }\n  # }\n  #\n  # struct ClusterMap;\n  #\n  # impl Deserialize for ClusterMap {}\n  #\n  use anyhow::Result;\n\n  fn get_cluster_info() -> Result<ClusterMap> {\n      let config = std::fs::read_to_string(\"cluster.json\")?;\n      let map: ClusterMap = serde_json::from_str(&config)?;\n      Ok(map)\n  }\n  #\n  # fn main() {}\n  ```\n\n- Attach context to help the person troubleshooting the error understand\n  where things went wrong. A low-level error like \"No such file or\n  directory\" can be annoying to debug without more context about what higher\n  level step the application was in the middle of.\n\n  ```\n  # struct It;\n  #\n  # impl It {\n  #     fn detach(&self) -> Result<()> {\n  #         unimplemented!()\n  #     }\n  # }\n  #\n  use anyhow::{Context, Result};\n\n  fn main() -> Result<()> {\n      # return Ok(());\n      #\n      # const _: &str = stringify! {\n      ...\n      # };\n      #\n      # let it = It;\n      # let path = \"./path/to/instrs.json\";\n      #\n      it.detach().context(\"Failed to detach the important thing\")?;\n\n      let content = std::fs::read(path)\n          .with_context(|| format!(\"Failed to read instrs from {}\", path))?;\n      #\n      # const _: &str = stringify! {\n      ...\n      # };\n      #\n      # Ok(())\n  }\n  ```\n\n  ```console\n  Error: Failed to read instrs from ./path/to/instrs.json\n\n  Caused by:\n      No such file or directory (os error 2)\n  ```\n\n- Downcasting is supported and can be by value, by shared reference, or by\n  mutable reference as needed.\n\n  ```\n  # use anyhow::anyhow;\n  # use std::fmt::{self, Display};\n  # use std::task::Poll;\n  #\n  # #[derive(Debug)]\n  # enum DataStoreError {\n  #     Censored(()),\n  # }\n  #\n  # impl Display for DataStoreError {\n  #     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n  #         unimplemented!()\n  #     }\n  # }\n  #\n  # impl std::error::Error for DataStoreError {}\n  #\n  # const REDACTED_CONTENT: () = ();\n  #\n  # let error = anyhow!(\"...\");\n  # let root_cause = &error;\n  #\n  # let ret =\n  // If the error was caused by redaction, then return a\n  // tombstone instead of the content.\n  match root_cause.downcast_ref::<DataStoreError>() {\n      Some(DataStoreError::Censored(_)) => Ok(Poll::Ready(REDACTED_CONTENT)),\n      None => Err(error),\n  }\n  # ;\n  ```\n\n- If using Rust &ge; 1.65, a backtrace is captured and printed with the\n  error if the underlying error type does not already provide its own. In\n  order to see backtraces, they must be enabled through the environment\n  variables described in [`std::backtrace`]:\n\n  - If you want panics and errors to both have backtraces, set\n    `RUST_BACKTRACE=1`;\n  - If you want only errors to have backtraces, set `RUST_LIB_BACKTRACE=1`;\n  - If you want only panics to have backtraces, set `RUST_BACKTRACE=1` and\n    `RUST_LIB_BACKTRACE=0`.\n\n  [`std::backtrace`]: https://doc.rust-lang.org/std/backtrace/index.html#environment-variables\n\n- Anyhow works with any error type that has an impl of `std::error::Error`,\n  including ones defined in your crate. We do not bundle a `derive(Error)`\n  macro but you can write the impls yourself or use a standalone macro like\n  [thiserror].\n\n  [thiserror]: https://github.com/dtolnay/thiserror\n\n  ```\n  use thiserror::Error;\n\n  #[derive(Error, Debug)]\n  pub enum FormatError {\n      #[error(\"Invalid header (expected {expected:?}, got {found:?})\")]\n      InvalidHeader {\n          expected: String,\n          found: String,\n      },\n      #[error(\"Missing attribute: {0}\")]\n      MissingAttribute(String),\n  }\n  ```\n\n- One-off error messages can be constructed using the `anyhow!` macro, which\n  supports string interpolation and produces an `anyhow::Error`.\n\n  ```\n  # use anyhow::{anyhow, Result};\n  #\n  # fn demo() -> Result<()> {\n  #     let missing = \"...\";\n  return Err(anyhow!(\"Missing attribute: {}\", missing));\n  #     Ok(())\n  # }\n  ```\n\n  A `bail!` macro is provided as a shorthand for the same early return.\n\n  ```\n  # use anyhow::{bail, Result};\n  #\n  # fn demo() -> Result<()> {\n  #     let missing = \"...\";\n  bail!(\"Missing attribute: {}\", missing);\n  #     Ok(())\n  # }\n  ```\n\n<br>\n\n# No-std support\n\nIn no_std mode, the same API is almost all available and works the same way.\nTo depend on Anyhow in no_std mode, disable our default enabled \"std\"\nfeature in Cargo.toml. A global allocator is required.\n\n```toml\n[dependencies]\nanyhow = { version = \"1.0\", default-features = false }\n```\n\nSince the `?`-based error conversions would normally rely on the\n`std::error::Error` trait which is only available through std, no_std mode\nwill require an explicit `.map_err(Error::msg)` when working with a\nnon-Anyhow error type inside a function that returns Anyhow's error type."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "anyhow",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "anyhow"
      },
      "additionalTextEdits": []
    },
    {
      "label": "async_recursion",
      "kind": 9,
      "documentation": {
        "kind": "markdown",
        "value": "# async-recursion macro\n\n[![Latest version](https://img.shields.io/crates/v/async-recursion)](https://crates.io/crates/async-recursion)\n[![crates.io downloads](https://img.shields.io/crates/d/async_recursion)](https://crates.io/crates/async-recursion)\n[![Build Status](https://img.shields.io/github/actions/workflow/status/dcchut/async-recursion/ci.yml?branch=master)](https://github.com/dcchut/async-recursion/actions)\n![Apache/MIT2.0 License](https://img.shields.io/crates/l/async-recursion)\n\nProcedural macro for recursive async functions.\n\n* [Documentation](https://docs.rs/async-recursion/)\n* Cargo package: [async-recursion](https://crates.io/crates/async-recursion)\n\n## Motivation\nConsider the following recursive implementation of the fibonacci numbers:\n\n```rust\nasync fn fib(n : u32) -> u32 {\n   match n {\n       0 | 1 => 1,\n       _ => fib(n-1).await + fib(n-2).await\n   }\n}\n```\n\nThe compiler helpfully tells us that:\n\n```console\nerror[E0733]: recursion in an `async fn` requires boxing\n--> src/main.rs:1:26\n  |\n1 | async fn fib(n : u32) -> u32 {\n  |                          ^^^ recursive `async fn`\n  |\n  = note: a recursive `async fn` must be rewritten to return a boxed `dyn Future`.\n  = note: consider using the `async_recursion` crate: https://crates.io/crates/async_recursion\n```\n\nThis crate provides an attribute macro to automatically convert an async function\nto one returning a boxed [`Future`](core::future::Future).\n\n## Example\n\n```rust\nuse async_recursion::async_recursion;\n\n#[async_recursion]\nasync fn fib(n : u32) -> u32 {\n   match n {\n       0 | 1 => 1,\n       _ => fib(n-1).await + fib(n-2).await\n   }\n}\n```\n\n## ?Send Option\n\nThe returned future has a [`Send`] bound to make sure it can be sent between threads.\nIf this is undesirable you can mark that the bound should be left out like so:\n\n```rust\n\n#[async_recursion(?Send)]\nasync fn example() {\n    // ...\n}\n```\n\nIn detail:\n\n- `#[async_recursion]` modifies your function to return a [`BoxFuture`], and\n- `#[async_recursion(?Send)]` modifies your function to return a [`LocalBoxFuture`].\n\n[`BoxFuture`]: https://docs.rs/futures/0.3.19/futures/future/type.BoxFuture.html\n[`LocalBoxFuture`]: https://docs.rs/futures/0.3.19/futures/future/type.LocalBoxFuture.html\n\n### License\n\nLicensed under either of\n * Apache License, Version 2.0 (<http://www.apache.org/licenses/LICENSE-2.0>)\n * MIT license (<http://opensource.org/licenses/MIT>)\n\nat your option."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "async_recursion",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "async_recursion"
      },
      "additionalTextEdits": []
    },
    {
      "label": "async_trait",
      "kind": 9,
      "documentation": {
        "kind": "markdown",
        "value": "[![github]](https://github.com/dtolnay/async-trait)&ensp;[![crates-io]](https://crates.io/crates/async-trait)&ensp;[![docs-rs]](https://docs.rs/async-trait)\n\n[github]: https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github\n[crates-io]: https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust\n[docs-rs]: https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs\n\n<br>\n\n<h4>Type erasure for async trait methods</h4>\n\nThe stabilization of async functions in traits in Rust 1.75 did not include\nsupport for using traits containing async functions as `dyn Trait`. Trying\nto use dyn with an async trait produces the following error:\n\n```rust\npub trait Trait {\n    async fn f(&self);\n}\n\npub fn make() -> Box<dyn Trait> {\n    unimplemented!()\n}\n```\n\n```text\nerror[E0038]: the trait `Trait` cannot be made into an object\n --> src/main.rs:5:22\n  |\n5 | pub fn make() -> Box<dyn Trait> {\n  |                      ^^^^^^^^^ `Trait` cannot be made into an object\n  |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n --> src/main.rs:2:14\n  |\n1 | pub trait Trait {\n  |           ----- this trait cannot be made into an object...\n2 |     async fn f(&self);\n  |              ^ ...because method `f` is `async`\n  = help: consider moving `f` to another trait\n```\n\nThis crate provides an attribute macro to make async fn in traits work with\ndyn traits.\n\nPlease refer to [*why async fn in traits are hard*][hard] for a deeper\nanalysis of how this implementation differs from what the compiler and\nlanguage deliver natively.\n\n[hard]: https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/\n\n<br>\n\n# Example\n\nThis example implements the core of a highly effective advertising platform\nusing async fn in a trait.\n\nThe only thing to notice here is that we write an `#[async_trait]` macro on\ntop of traits and trait impls that contain async fn, and then they work. We\nget to have `Vec<Box<dyn Advertisement + Sync>>` or `&[&dyn Advertisement]`,\nfor example.\n\n```rust\nuse async_trait::async_trait;\n\n#[async_trait]\ntrait Advertisement {\n    async fn run(&self);\n}\n\nstruct Modal;\n\n#[async_trait]\nimpl Advertisement for Modal {\n    async fn run(&self) {\n        self.render_fullscreen().await;\n        for _ in 0..4u16 {\n            remind_user_to_join_mailing_list().await;\n        }\n        self.hide_for_now().await;\n    }\n}\n\nstruct AutoplayingVideo {\n    media_url: String,\n}\n\n#[async_trait]\nimpl Advertisement for AutoplayingVideo {\n    async fn run(&self) {\n        let stream = connect(&self.media_url).await;\n        stream.play().await;\n\n        // Video probably persuaded user to join our mailing list!\n        Modal.run().await;\n    }\n}\n```\n\n<br><br>\n\n# Supported features\n\nIt is the intention that all features of Rust traits should work nicely with\n#\\[async_trait\\], but the edge cases are numerous. Please file an issue if\nyou see unexpected borrow checker errors, type errors, or warnings. There is\nno use of `unsafe` in the expanded code, so rest assured that if your code\ncompiles it can't be that badly broken.\n\n> &#9745;&emsp;Self by value, by reference, by mut reference, or no self;<br>\n> &#9745;&emsp;Any number of arguments, any return value;<br>\n> &#9745;&emsp;Generic type parameters and lifetime parameters;<br>\n> &#9745;&emsp;Associated types;<br>\n> &#9745;&emsp;Having async and non-async functions in the same trait;<br>\n> &#9745;&emsp;Default implementations provided by the trait;<br>\n> &#9745;&emsp;Elided lifetimes.<br>\n\n<br>\n\n# Explanation\n\nAsync fns get transformed into methods that return `Pin<Box<dyn Future +\nSend + 'async_trait>>` and delegate to an async block.\n\nFor example the `impl Advertisement for AutoplayingVideo` above would be\nexpanded as:\n\n```rust\nimpl Advertisement for AutoplayingVideo {\n    fn run<'async_trait>(\n        &'async_trait self,\n    ) -> Pin<Box<dyn core::future::Future<Output = ()> + Send + 'async_trait>>\n    where\n        Self: Sync + 'async_trait,\n    {\n        Box::pin(async move {\n            /* the original method body */\n        })\n    }\n}\n```\n\n<br><br>\n\n# Non-threadsafe futures\n\nNot all async traits need futures that are `dyn Future + Send`. To avoid\nhaving Send and Sync bounds placed on the async trait methods, invoke the\nasync trait macro as `#[async_trait(?Send)]` on both the trait and the impl\nblocks.\n\n<br>\n\n# Elided lifetimes\n\nBe aware that async fn syntax does not allow lifetime elision outside of `&`\nand `&mut` references. (This is true even when not using #\\[async_trait\\].)\nLifetimes must be named or marked by the placeholder `'_`.\n\nFortunately the compiler is able to diagnose missing lifetimes with a good\nerror message.\n\n```rust\ntype Elided<'a> = &'a usize;\n\n#[async_trait]\ntrait Test {\n    async fn test(not_okay: Elided, okay: &usize) {}\n}\n```\n\n```text\nerror[E0726]: implicit elided lifetime not allowed here\n --> src/main.rs:9:29\n  |\n9 |     async fn test(not_okay: Elided, okay: &usize) {}\n  |                             ^^^^^^- help: indicate the anonymous lifetime: `<'_>`\n```\n\nThe fix is to name the lifetime or use `'_`.\n\n```rust\n#[async_trait]\ntrait Test {\n    // either\n    async fn test<'e>(elided: Elided<'e>) {}\n    // or\n    async fn test(elided: Elided<'_>) {}\n}\n```\n\n<br><br>\n\n# Dyn traits\n\nTraits with async methods can be used as trait objects as long as they meet\nthe usual requirements for dyn -- no methods with type parameters, no self\nby value, no associated types, etc.\n\n```rust\n#[async_trait]\npub trait ObjectSafe {\n    async fn f(&self);\n    async fn g(&mut self);\n}\n\nimpl ObjectSafe for MyType {...}\n\nlet value: MyType = ...;\nlet object = &value as &dyn ObjectSafe;  // make trait object\n```\n\nThe one wrinkle is in traits that provide default implementations of async\nmethods. In order for the default implementation to produce a future that is\nSend, the async_trait macro must emit a bound of `Self: Sync` on trait\nmethods that take `&self` and a bound `Self: Send` on trait methods that\ntake `&mut self`. An example of the former is visible in the expanded code\nin the explanation section above.\n\nIf you make a trait with async methods that have default implementations,\neverything will work except that the trait cannot be used as a trait object.\nCreating a value of type `&dyn Trait` will produce an error that looks like\nthis:\n\n```text\nerror: the trait `Test` cannot be made into an object\n --> src/main.rs:8:5\n  |\n8 |     async fn cannot_dyn(&self) {}\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n```\n\nFor traits that need to be object safe and need to have default\nimplementations for some async methods, there are two resolutions. Either\nyou can add Send and/or Sync as supertraits (Send if there are `&mut self`\nmethods with default implementations, Sync if there are `&self` methods with\ndefault implementations) to constrain all implementors of the trait such that\nthe default implementations are applicable to them:\n\n```rust\n#[async_trait]\npub trait ObjectSafe: Sync {  // added supertrait\n    async fn can_dyn(&self) {}\n}\n\nlet object = &value as &dyn ObjectSafe;\n```\n\nor you can strike the problematic methods from your trait object by\nbounding them with `Self: Sized`:\n\n```rust\n#[async_trait]\npub trait ObjectSafe {\n    async fn cannot_dyn(&self) where Self: Sized {}\n\n    // presumably other methods\n}\n\nlet object = &value as &dyn ObjectSafe;\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "async_trait",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "async_trait"
      },
      "additionalTextEdits": []
    },
    {
      "label": "char",
      "kind": 22,
      "detail": "char",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "char",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "char"
      },
      "additionalTextEdits": []
    },
    {
      "label": "bool",
      "kind": 22,
      "detail": "bool",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "bool",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "bool"
      },
      "additionalTextEdits": []
    },
    {
      "label": "str",
      "kind": 22,
      "detail": "str",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "str",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "str"
      },
      "additionalTextEdits": []
    },
    {
      "label": "isize",
      "kind": 22,
      "detail": "isize",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "isize",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "isize"
      },
      "additionalTextEdits": []
    },
    {
      "label": "i8",
      "kind": 22,
      "detail": "i8",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "i8",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "i8"
      },
      "additionalTextEdits": []
    },
    {
      "label": "i16",
      "kind": 22,
      "detail": "i16",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "i16",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "i16"
      },
      "additionalTextEdits": []
    },
    {
      "label": "i32",
      "kind": 22,
      "detail": "i32",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "i32",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "i32"
      },
      "additionalTextEdits": []
    },
    {
      "label": "i64",
      "kind": 22,
      "detail": "i64",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "i64",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "i64"
      },
      "additionalTextEdits": []
    },
    {
      "label": "i128",
      "kind": 22,
      "detail": "i128",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "i128",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "i128"
      },
      "additionalTextEdits": []
    },
    {
      "label": "usize",
      "kind": 22,
      "detail": "usize",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "usize",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "usize"
      },
      "additionalTextEdits": []
    },
    {
      "label": "u8",
      "kind": 22,
      "detail": "u8",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "u8",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "u8"
      },
      "additionalTextEdits": []
    },
    {
      "label": "u16",
      "kind": 22,
      "detail": "u16",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "u16",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "u16"
      },
      "additionalTextEdits": []
    },
    {
      "label": "u32",
      "kind": 22,
      "detail": "u32",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "u32",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "u32"
      },
      "additionalTextEdits": []
    },
    {
      "label": "u64",
      "kind": 22,
      "detail": "u64",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "u64",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "u64"
      },
      "additionalTextEdits": []
    },
    {
      "label": "u128",
      "kind": 22,
      "detail": "u128",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "u128",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "u128"
      },
      "additionalTextEdits": []
    },
    {
      "label": "f16",
      "kind": 22,
      "detail": "f16",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "f16",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "f16"
      },
      "additionalTextEdits": []
    },
    {
      "label": "f32",
      "kind": 22,
      "detail": "f32",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "f32",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "f32"
      },
      "additionalTextEdits": []
    },
    {
      "label": "f64",
      "kind": 22,
      "detail": "f64",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "f64",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "f64"
      },
      "additionalTextEdits": []
    },
    {
      "label": "f128",
      "kind": 22,
      "detail": "f128",
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "f128",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "f128"
      },
      "additionalTextEdits": []
    },
    {
      "label": "AsMut",
      "kind": 8,
      "documentation": {
        "kind": "markdown",
        "value": "Used to do a cheap mutable-to-mutable reference conversion.\n\nThis trait is similar to [`AsRef`] but used for converting between mutable\nreferences. If you need to do a costly conversion it is better to\nimplement [`From`] with type `&mut T` or write a custom function.\n\n**Note: This trait must not fail**. If the conversion can fail, use a\ndedicated method which returns an [`Option<T>`] or a [`Result<T, E>`].\n\n# Generic Implementations\n\n`AsMut` auto-dereferences if the inner type is a mutable reference\n(e.g.: `foo.as_mut()` will work the same if `foo` has type `&mut Foo` or `&mut &mut Foo`).\n\nNote that due to historic reasons, the above currently does not hold generally for all\n[mutably dereferenceable types], e.g. `foo.as_mut()` will *not* work the same as\n`Box::new(foo).as_mut()`. Instead, many smart pointers provide an `as_mut` implementation which\nsimply returns a reference to the [pointed-to value] (but do not perform a cheap\nreference-to-reference conversion for that value). However, [`AsMut::as_mut`] should not be\nused for the sole purpose of mutable dereferencing; instead ['`Deref` coercion'] can be used:\n\n[mutably dereferenceable types]: core::ops::DerefMut\n[pointed-to value]: core::ops::Deref::Target\n['`Deref` coercion']: core::ops::DerefMut#mutable-deref-coercion\n\n```rust\nlet mut x = Box::new(5i32);\n// Avoid this:\n// let y: &mut i32 = x.as_mut();\n// Better just write:\nlet y: &mut i32 = &mut x;\n```\n\nTypes which implement [`DerefMut`] should consider to add an implementation of `AsMut<T>` as\nfollows:\n\n[`DerefMut`]: core::ops::DerefMut\n\n```rust\nimpl<T> AsMut<T> for SomeType\nwhere\n    <SomeType as Deref>::Target: AsMut<T>,\n{\n    fn as_mut(&mut self) -> &mut T {\n        self.deref_mut().as_mut()\n    }\n}\n```\n\n# Reflexivity\n\nIdeally, `AsMut` would be reflexive, i.e. there would be an `impl<T: ?Sized> AsMut<T> for T`\nwith [`as_mut`] simply returning its argument unchanged.\nSuch a blanket implementation is currently *not* provided due to technical restrictions of\nRust's type system (it would be overlapping with another existing blanket implementation for\n`&mut T where T: AsMut<U>` which allows `AsMut` to auto-dereference, see \"Generic\nImplementations\" above).\n\n[`as_mut`]: AsMut::as_mut\n\nA trivial implementation of `AsMut<T> for T` must be added explicitly for a particular type `T`\nwhere needed or desired. Note, however, that not all types from `std` contain such an\nimplementation, and those cannot be added by external code due to orphan rules.\n\n# Examples\n\nUsing `AsMut` as trait bound for a generic function, we can accept all mutable references that\ncan be converted to type `&mut T`. Unlike [dereference], which has a single [target type],\nthere can be multiple implementations of `AsMut` for a type. In particular, `Vec<T>` implements\nboth `AsMut<Vec<T>>` and `AsMut<[T]>`.\n\nIn the following, the example functions `caesar` and `null_terminate` provide a generic\ninterface which work with any type that can be converted by cheap mutable-to-mutable conversion\ninto a byte slice (`[u8]`) or byte vector (`Vec<u8>`), respectively.\n\n[dereference]: core::ops::DerefMut\n[target type]: core::ops::Deref::Target\n\n```rust\nstruct Document {\n    info: String,\n    content: Vec<u8>,\n}\n\nimpl<T: ?Sized> AsMut<T> for Document\nwhere\n    Vec<u8>: AsMut<T>,\n{\n    fn as_mut(&mut self) -> &mut T {\n        self.content.as_mut()\n    }\n}\n\nfn caesar<T: AsMut<[u8]>>(data: &mut T, key: u8) {\n    for byte in data.as_mut() {\n        *byte = byte.wrapping_add(key);\n    }\n}\n\nfn null_terminate<T: AsMut<Vec<u8>>>(data: &mut T) {\n    // Using a non-generic inner function, which contains most of the\n    // functionality, helps to minimize monomorphization overhead.\n    fn doit(data: &mut Vec<u8>) {\n        let len = data.len();\n        if len == 0 || data[len-1] != 0 {\n            data.push(0);\n        }\n    }\n    doit(data.as_mut());\n}\n\nfn main() {\n    let mut v: Vec<u8> = vec![1, 2, 3];\n    caesar(&mut v, 5);\n    assert_eq!(v, [6, 7, 8]);\n    null_terminate(&mut v);\n    assert_eq!(v, [6, 7, 8, 0]);\n    let mut doc = Document {\n        info: String::from(\"Example\"),\n        content: vec![17, 19, 8],\n    };\n    caesar(&mut doc, 1);\n    assert_eq!(doc.content, [18, 20, 9]);\n    null_terminate(&mut doc);\n    assert_eq!(doc.content, [18, 20, 9, 0]);\n}\n```\n\nNote, however, that APIs don't need to be generic. In many cases taking a `&mut [u8]` or\n`&mut Vec<u8>`, for example, is the better choice (callers need to pass the correct type then)."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "AsMut",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "AsMut"
      },
      "additionalTextEdits": []
    },
    {
      "label": "AsRef",
      "kind": 8,
      "documentation": {
        "kind": "markdown",
        "value": "Used to do a cheap reference-to-reference conversion.\n\nThis trait is similar to [`AsMut`] which is used for converting between mutable references.\nIf you need to do a costly conversion it is better to implement [`From`] with type\n`&T` or write a custom function.\n\n# Relation to `Borrow`\n\n`AsRef` has the same signature as [`Borrow`], but [`Borrow`] is different in a few aspects:\n\n- Unlike `AsRef`, [`Borrow`] has a blanket impl for any `T`, and can be used to accept either\n  a reference or a value. (See also note on `AsRef`'s reflexibility below.)\n- [`Borrow`] also requires that [`Hash`], [`Eq`] and [`Ord`] for a borrowed value are\n  equivalent to those of the owned value. For this reason, if you want to\n  borrow only a single field of a struct you can implement `AsRef`, but not [`Borrow`].\n\n**Note: This trait must not fail**. If the conversion can fail, use a\ndedicated method which returns an [`Option<T>`] or a [`Result<T, E>`].\n\n# Generic Implementations\n\n`AsRef` auto-dereferences if the inner type is a reference or a mutable reference\n(e.g.: `foo.as_ref()` will work the same if `foo` has type `&mut Foo` or `&&mut Foo`).\n\nNote that due to historic reasons, the above currently does not hold generally for all\n[dereferenceable types], e.g. `foo.as_ref()` will *not* work the same as\n`Box::new(foo).as_ref()`. Instead, many smart pointers provide an `as_ref` implementation which\nsimply returns a reference to the [pointed-to value] (but do not perform a cheap\nreference-to-reference conversion for that value). However, [`AsRef::as_ref`] should not be\nused for the sole purpose of dereferencing; instead ['`Deref` coercion'] can be used:\n\n[dereferenceable types]: core::ops::Deref\n[pointed-to value]: core::ops::Deref::Target\n['`Deref` coercion']: core::ops::Deref#deref-coercion\n\n```rust\nlet x = Box::new(5i32);\n// Avoid this:\n// let y: &i32 = x.as_ref();\n// Better just write:\nlet y: &i32 = &x;\n```\n\nTypes which implement [`Deref`] should consider implementing `AsRef<T>` as follows:\n\n[`Deref`]: core::ops::Deref\n\n```rust\nimpl<T> AsRef<T> for SomeType\nwhere\n    T: ?Sized,\n    <SomeType as Deref>::Target: AsRef<T>,\n{\n    fn as_ref(&self) -> &T {\n        self.deref().as_ref()\n    }\n}\n```\n\n# Reflexivity\n\nIdeally, `AsRef` would be reflexive, i.e. there would be an `impl<T: ?Sized> AsRef<T> for T`\nwith [`as_ref`] simply returning its argument unchanged.\nSuch a blanket implementation is currently *not* provided due to technical restrictions of\nRust's type system (it would be overlapping with another existing blanket implementation for\n`&T where T: AsRef<U>` which allows `AsRef` to auto-dereference, see \"Generic Implementations\"\nabove).\n\n[`as_ref`]: AsRef::as_ref\n\nA trivial implementation of `AsRef<T> for T` must be added explicitly for a particular type `T`\nwhere needed or desired. Note, however, that not all types from `std` contain such an\nimplementation, and those cannot be added by external code due to orphan rules.\n\n# Examples\n\nBy using trait bounds we can accept arguments of different types as long as they can be\nconverted to the specified type `T`.\n\nFor example: By creating a generic function that takes an `AsRef<str>` we express that we\nwant to accept all references that can be converted to [`&str`] as an argument.\nSince both [`String`] and [`&str`] implement `AsRef<str>` we can accept both as input argument.\n\n[`&str`]: primitive@str\n[`Borrow`]: crate::borrow::Borrow\n[`Eq`]: crate::cmp::Eq\n[`Ord`]: crate::cmp::Ord\n[`String`]: ../../std/string/struct.String.html\n\n```rust\nfn is_hello<T: AsRef<str>>(s: T) {\n   assert_eq!(\"hello\", s.as_ref());\n}\n\nlet s = \"hello\";\nis_hello(s);\n\nlet s = \"hello\".to_string();\nis_hello(s);\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "AsRef",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "AsRef"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Box",
      "kind": 22,
      "detail": "Box<{unknown}, {unknown}>",
      "documentation": {
        "kind": "markdown",
        "value": "A pointer type that uniquely owns a heap allocation of type `T`.\n\nSee the [module-level documentation](../../std/boxed/index.html) for more."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Box",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Box"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Clone",
      "kind": 8,
      "documentation": {
        "kind": "markdown",
        "value": "A common trait for the ability to explicitly duplicate an object.\n\nDiffers from [`Copy`] in that [`Copy`] is implicit and an inexpensive bit-wise copy, while\n`Clone` is always explicit and may or may not be expensive. In order to enforce\nthese characteristics, Rust does not allow you to reimplement [`Copy`], but you\nmay reimplement `Clone` and run arbitrary code.\n\nSince `Clone` is more general than [`Copy`], you can automatically make anything\n[`Copy`] be `Clone` as well.\n\n## Derivable\n\nThis trait can be used with `#[derive]` if all fields are `Clone`. The `derive`d\nimplementation of [`Clone`] calls [`clone`] on each field.\n\n[`clone`]: Clone::clone\n\nFor a generic struct, `#[derive]` implements `Clone` conditionally by adding bound `Clone` on\ngeneric parameters.\n\n```rust\n// `derive` implements Clone for Reading<T> when T is Clone.\n#[derive(Clone)]\nstruct Reading<T> {\n    frequency: T,\n}\n```\n\n## How can I implement `Clone`?\n\nTypes that are [`Copy`] should have a trivial implementation of `Clone`. More formally:\nif `T: Copy`, `x: T`, and `y: &T`, then `let x = y.clone();` is equivalent to `let x = *y;`.\nManual implementations should be careful to uphold this invariant; however, unsafe code\nmust not rely on it to ensure memory safety.\n\nAn example is a generic struct holding a function pointer. In this case, the\nimplementation of `Clone` cannot be `derive`d, but can be implemented as:\n\n```rust\nstruct Generate<T>(fn() -> T);\n\nimpl<T> Copy for Generate<T> {}\n\nimpl<T> Clone for Generate<T> {\n    fn clone(&self) -> Self {\n        *self\n    }\n}\n```\n\nIf we `derive`:\n\n```rust\n#[derive(Copy, Clone)]\nstruct Generate<T>(fn() -> T);\n```\n\nthe auto-derived implementations will have unnecessary `T: Copy` and `T: Clone` bounds:\n\n```rust\n\n// Automatically derived\nimpl<T: Copy> Copy for Generate<T> { }\n\n// Automatically derived\nimpl<T: Clone> Clone for Generate<T> {\n    fn clone(&self) -> Generate<T> {\n        Generate(Clone::clone(&self.0))\n    }\n}\n```\n\nThe bounds are unnecessary because clearly the function itself should be\ncopy- and cloneable even if its return type is not:\n\n```rust\n#[derive(Copy, Clone)]\nstruct Generate<T>(fn() -> T);\n\nstruct NotCloneable;\n\nfn generate_not_cloneable() -> NotCloneable {\n    NotCloneable\n}\n\nGenerate(generate_not_cloneable).clone(); // error: trait bounds were not satisfied\n// Note: With the manual implementations the above line will compile.\n```\n\n## Additional implementors\n\nIn addition to the [implementors listed below][impls],\nthe following types also implement `Clone`:\n\n* Function item types (i.e., the distinct types defined for each function)\n* Function pointer types (e.g., `fn() -> i32`)\n* Closure types, if they capture no value from the environment\n  or if all such captured values implement `Clone` themselves.\n  Note that variables captured by shared reference always implement `Clone`\n  (even if the referent doesn't),\n  while variables captured by mutable reference never implement `Clone`.\n\n[impls]: #implementors"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Clone",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Clone"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Copy",
      "kind": 8,
      "documentation": {
        "kind": "markdown",
        "value": "Types whose values can be duplicated simply by copying bits.\n\nBy default, variable bindings have 'move semantics.' In other\nwords:\n\n```rust\n#[derive(Debug)]\nstruct Foo;\n\nlet x = Foo;\n\nlet y = x;\n\n// `x` has moved into `y`, and so cannot be used\n\n// println!(\"{x:?}\"); // error: use of moved value\n```\n\nHowever, if a type implements `Copy`, it instead has 'copy semantics':\n\n```rust\n// We can derive a `Copy` implementation. `Clone` is also required, as it's\n// a supertrait of `Copy`.\n#[derive(Debug, Copy, Clone)]\nstruct Foo;\n\nlet x = Foo;\n\nlet y = x;\n\n// `y` is a copy of `x`\n\nprintln!(\"{x:?}\"); // A-OK!\n```\n\nIt's important to note that in these two examples, the only difference is whether you\nare allowed to access `x` after the assignment. Under the hood, both a copy and a move\ncan result in bits being copied in memory, although this is sometimes optimized away.\n\n## How can I implement `Copy`?\n\nThere are two ways to implement `Copy` on your type. The simplest is to use `derive`:\n\n```rust\n#[derive(Copy, Clone)]\nstruct MyStruct;\n```\n\nYou can also implement `Copy` and `Clone` manually:\n\n```rust\nstruct MyStruct;\n\nimpl Copy for MyStruct { }\n\nimpl Clone for MyStruct {\n    fn clone(&self) -> MyStruct {\n        *self\n    }\n}\n```\n\nThere is a small difference between the two. The `derive` strategy will also place a `Copy`\nbound on type parameters:\n\n```rust\n#[derive(Clone)]\nstruct MyStruct<T>(T);\n\nimpl<T: Copy> Copy for MyStruct<T> { }\n```\n\nThis isn't always desired. For example, shared references (`&T`) can be copied regardless of\nwhether `T` is `Copy`. Likewise, a generic struct containing markers such as [`PhantomData`]\ncould potentially be duplicated with a bit-wise copy.\n\n## What's the difference between `Copy` and `Clone`?\n\nCopies happen implicitly, for example as part of an assignment `y = x`. The behavior of\n`Copy` is not overloadable; it is always a simple bit-wise copy.\n\nCloning is an explicit action, `x.clone()`. The implementation of [`Clone`] can\nprovide any type-specific behavior necessary to duplicate values safely. For example,\nthe implementation of [`Clone`] for [`String`] needs to copy the pointed-to string\nbuffer in the heap. A simple bitwise copy of [`String`] values would merely copy the\npointer, leading to a double free down the line. For this reason, [`String`] is [`Clone`]\nbut not `Copy`.\n\n[`Clone`] is a supertrait of `Copy`, so everything which is `Copy` must also implement\n[`Clone`]. If a type is `Copy` then its [`Clone`] implementation only needs to return `*self`\n(see the example above).\n\n## When can my type be `Copy`?\n\nA type can implement `Copy` if all of its components implement `Copy`. For example, this\nstruct can be `Copy`:\n\n```rust\n#[derive(Copy, Clone)]\nstruct Point {\n   x: i32,\n   y: i32,\n}\n```\n\nA struct can be `Copy`, and [`i32`] is `Copy`, therefore `Point` is eligible to be `Copy`.\nBy contrast, consider\n\n```rust\nstruct PointList {\n    points: Vec<Point>,\n}\n```\n\nThe struct `PointList` cannot implement `Copy`, because [`Vec<T>`] is not `Copy`. If we\nattempt to derive a `Copy` implementation, we'll get an error:\n\n```text\nthe trait `Copy` cannot be implemented for this type; field `points` does not implement `Copy`\n```\n\nShared references (`&T`) are also `Copy`, so a type can be `Copy`, even when it holds\nshared references of types `T` that are *not* `Copy`. Consider the following struct,\nwhich can implement `Copy`, because it only holds a *shared reference* to our non-`Copy`\ntype `PointList` from above:\n\n```rust\n#[derive(Copy, Clone)]\nstruct PointListWrapper<'a> {\n    point_list_ref: &'a PointList,\n}\n```\n\n## When *can't* my type be `Copy`?\n\nSome types can't be copied safely. For example, copying `&mut T` would create an aliased\nmutable reference. Copying [`String`] would duplicate responsibility for managing the\n[`String`]'s buffer, leading to a double free.\n\nGeneralizing the latter case, any type implementing [`Drop`] can't be `Copy`, because it's\nmanaging some resource besides its own [`size_of::<T>`] bytes.\n\nIf you try to implement `Copy` on a struct or enum containing non-`Copy` data, you will get\nthe error [E0204].\n\n[E0204]: ../../error_codes/E0204.html\n\n## When *should* my type be `Copy`?\n\nGenerally speaking, if your type _can_ implement `Copy`, it should. Keep in mind, though,\nthat implementing `Copy` is part of the public API of your type. If the type might become\nnon-`Copy` in the future, it could be prudent to omit the `Copy` implementation now, to\navoid a breaking API change.\n\n## Additional implementors\n\nIn addition to the [implementors listed below][impls],\nthe following types also implement `Copy`:\n\n* Function item types (i.e., the distinct types defined for each function)\n* Function pointer types (e.g., `fn() -> i32`)\n* Closure types, if they capture no value from the environment\n  or if all such captured values implement `Copy` themselves.\n  Note that variables captured by shared reference always implement `Copy`\n  (even if the referent doesn't),\n  while variables captured by mutable reference never implement `Copy`.\n\n[`Vec<T>`]: ../../std/vec/struct.Vec.html\n[`String`]: ../../std/string/struct.String.html\n[`size_of::<T>`]: crate::mem::size_of\n[impls]: #implementors"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Copy",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Copy"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Default",
      "kind": 8,
      "documentation": {
        "kind": "markdown",
        "value": "A trait for giving a type a useful default value.\n\nSometimes, you want to fall back to some kind of default value, and\ndon't particularly care what it is. This comes up often with `struct`s\nthat define a set of options:\n\n```rust\nstruct SomeOptions {\n    foo: i32,\n    bar: f32,\n}\n```\n\nHow can we define some default values? You can use `Default`:\n\n```rust\n#[derive(Default)]\nstruct SomeOptions {\n    foo: i32,\n    bar: f32,\n}\n\nfn main() {\n    let options: SomeOptions = Default::default();\n}\n```\n\nNow, you get all of the default values. Rust implements `Default` for various primitives types.\n\nIf you want to override a particular option, but still retain the other defaults:\n\n```rust\nfn main() {\n    let options = SomeOptions { foo: 42, ..Default::default() };\n}\n```\n\n## Derivable\n\nThis trait can be used with `#[derive]` if all of the type's fields implement\n`Default`. When `derive`d, it will use the default value for each field's type.\n\n### `enum`s\n\nWhen using `#[derive(Default)]` on an `enum`, you need to choose which unit variant will be\ndefault. You do this by placing the `#[default]` attribute on the variant.\n\n```rust\n#[derive(Default)]\nenum Kind {\n    #[default]\n    A,\n    B,\n    C,\n}\n```\n\nYou cannot use the `#[default]` attribute on non-unit or non-exhaustive variants.\n\nThe `#[default]` attribute was stabilized in Rust 1.62.0.\n\n## How can I implement `Default`?\n\nProvide an implementation for the `default()` method that returns the value of\nyour type that should be the default:\n\n```rust\nenum Kind {\n    A,\n    B,\n    C,\n}\n\nimpl Default for Kind {\n    fn default() -> Self { Kind::A }\n}\n```\n\n# Examples\n\n```rust\n#[derive(Default)]\nstruct SomeOptions {\n    foo: i32,\n    bar: f32,\n}\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Default",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Default"
      },
      "additionalTextEdits": []
    },
    {
      "label": "DoubleEndedIterator",
      "kind": 8,
      "documentation": {
        "kind": "markdown",
        "value": "An iterator able to yield elements from both ends.\n\nSomething that implements `DoubleEndedIterator` has one extra capability\nover something that implements [`Iterator`]: the ability to also take\n`Item`s from the back, as well as the front.\n\nIt is important to note that both back and forth work on the same range,\nand do not cross: iteration is over when they meet in the middle.\n\nIn a similar fashion to the [`Iterator`] protocol, once a\n`DoubleEndedIterator` returns [`None`] from a [`next_back()`], calling it\nagain may or may not ever return [`Some`] again. [`next()`] and\n[`next_back()`] are interchangeable for this purpose.\n\n[`next_back()`]: DoubleEndedIterator::next_back\n[`next()`]: Iterator::next\n\n# Examples\n\nBasic usage:\n\n```rust\nlet numbers = vec![1, 2, 3, 4, 5, 6];\n\nlet mut iter = numbers.iter();\n\nassert_eq!(Some(&1), iter.next());\nassert_eq!(Some(&6), iter.next_back());\nassert_eq!(Some(&5), iter.next_back());\nassert_eq!(Some(&2), iter.next());\nassert_eq!(Some(&3), iter.next());\nassert_eq!(Some(&4), iter.next());\nassert_eq!(None, iter.next());\nassert_eq!(None, iter.next_back());\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "DoubleEndedIterator",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "DoubleEndedIterator"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Drop",
      "kind": 8,
      "documentation": {
        "kind": "markdown",
        "value": "Custom code within the destructor.\n\nWhen a value is no longer needed, Rust will run a \"destructor\" on that value.\nThe most common way that a value is no longer needed is when it goes out of\nscope. Destructors may still run in other circumstances, but we're going to\nfocus on scope for the examples here. To learn about some of those other cases,\nplease see [the reference] section on destructors.\n\n[the reference]: https://doc.rust-lang.org/reference/destructors.html\n\nThis destructor consists of two components:\n- A call to `Drop::drop` for that value, if this special `Drop` trait is implemented for its type.\n- The automatically generated \"drop glue\" which recursively calls the destructors\n    of all the fields of this value.\n\nAs Rust automatically calls the destructors of all contained fields,\nyou don't have to implement `Drop` in most cases. But there are some cases where\nit is useful, for example for types which directly manage a resource.\nThat resource may be memory, it may be a file descriptor, it may be a network socket.\nOnce a value of that type is no longer going to be used, it should \"clean up\" its\nresource by freeing the memory or closing the file or socket. This is\nthe job of a destructor, and therefore the job of `Drop::drop`.\n\n## Examples\n\nTo see destructors in action, let's take a look at the following program:\n\n```rust\nstruct HasDrop;\n\nimpl Drop for HasDrop {\n    fn drop(&mut self) {\n        println!(\"Dropping HasDrop!\");\n    }\n}\n\nstruct HasTwoDrops {\n    one: HasDrop,\n    two: HasDrop,\n}\n\nimpl Drop for HasTwoDrops {\n    fn drop(&mut self) {\n        println!(\"Dropping HasTwoDrops!\");\n    }\n}\n\nfn main() {\n    let _x = HasTwoDrops { one: HasDrop, two: HasDrop };\n    println!(\"Running!\");\n}\n```\n\nRust will first call `Drop::drop` for `_x` and then for both `_x.one` and `_x.two`,\nmeaning that running this will print\n\n```text\nRunning!\nDropping HasTwoDrops!\nDropping HasDrop!\nDropping HasDrop!\n```\n\nEven if we remove the implementation of `Drop` for `HasTwoDrop`, the destructors of its fields are still called.\nThis would result in\n\n```test\nRunning!\nDropping HasDrop!\nDropping HasDrop!\n```\n\n## You cannot call `Drop::drop` yourself\n\nBecause `Drop::drop` is used to clean up a value, it may be dangerous to use this value after\nthe method has been called. As `Drop::drop` does not take ownership of its input,\nRust prevents misuse by not allowing you to call `Drop::drop` directly.\n\nIn other words, if you tried to explicitly call `Drop::drop` in the above example, you'd get a compiler error.\n\nIf you'd like to explicitly call the destructor of a value, [`mem::drop`] can be used instead.\n\n[`mem::drop`]: drop\n\n## Drop order\n\nWhich of our two `HasDrop` drops first, though? For structs, it's the same\norder that they're declared: first `one`, then `two`. If you'd like to try\nthis yourself, you can modify `HasDrop` above to contain some data, like an\ninteger, and then use it in the `println!` inside of `Drop`. This behavior is\nguaranteed by the language.\n\nUnlike for structs, local variables are dropped in reverse order:\n\n```rust\nstruct Foo;\n\nimpl Drop for Foo {\n    fn drop(&mut self) {\n        println!(\"Dropping Foo!\")\n    }\n}\n\nstruct Bar;\n\nimpl Drop for Bar {\n    fn drop(&mut self) {\n        println!(\"Dropping Bar!\")\n    }\n}\n\nfn main() {\n    let _foo = Foo;\n    let _bar = Bar;\n}\n```\n\nThis will print\n\n```text\nDropping Bar!\nDropping Foo!\n```\n\nPlease see [the reference] for the full rules.\n\n[the reference]: https://doc.rust-lang.org/reference/destructors.html\n\n## `Copy` and `Drop` are exclusive\n\nYou cannot implement both [`Copy`] and `Drop` on the same type. Types that\nare `Copy` get implicitly duplicated by the compiler, making it very\nhard to predict when, and how often destructors will be executed. As such,\nthese types cannot have destructors.\n\n## Drop check\n\nDropping interacts with the borrow checker in subtle ways: when a type `T` is being implicitly\ndropped as some variable of this type goes out of scope, the borrow checker needs to ensure that\ncalling `T`'s destructor at this moment is safe. In particular, it also needs to be safe to\nrecursively drop all the fields of `T`. For example, it is crucial that code like the following\nis being rejected:\n\n```rust\nuse std::cell::Cell;\n\nstruct S<'a>(Cell<Option<&'a S<'a>>>, Box<i32>);\nimpl Drop for S<'_> {\n    fn drop(&mut self) {\n        if let Some(r) = self.0.get() {\n            // Print the contents of the `Box` in `r`.\n            println!(\"{}\", r.1);\n        }\n    }\n}\n\nfn main() {\n    // Set up two `S` that point to each other.\n    let s1 = S(Cell::new(None), Box::new(42));\n    let s2 = S(Cell::new(Some(&s1)), Box::new(42));\n    s1.0.set(Some(&s2));\n    // Now they both get dropped. But whichever is the 2nd one\n    // to be dropped will access the `Box` in the first one,\n    // which is a use-after-free!\n}\n```\n\nThe Nomicon discusses the need for [drop check in more detail][drop check].\n\nTo reject such code, the \"drop check\" analysis determines which types and lifetimes need to\nstill be live when `T` gets dropped. The exact details of this analysis are not yet\nstably guaranteed and **subject to change**. Currently, the analysis works as follows:\n- If `T` has no drop glue, then trivially nothing is required to be live. This is the case if\n  neither `T` nor any of its (recursive) fields have a destructor (`impl Drop`). [`PhantomData`],\n  arrays of length 0 and [`ManuallyDrop`] are considered to never have a destructor, no matter\n  their field type.\n- If `T` has drop glue, then, for all types `U` that are *owned* by any field of `T`,\n  recursively add the types and lifetimes that need to be live when `U` gets dropped. The set of\n  owned types is determined by recursively traversing `T`:\n  - Recursively descend through `PhantomData`, `Box`, tuples, and arrays (excluding arrays of\n    length 0).\n  - Stop at reference and raw pointer types as well as function pointers and function items;\n    they do not own anything.\n  - Stop at non-composite types (type parameters that remain generic in the current context and\n    base types such as integers and `bool`); these types are owned.\n  - When hitting an ADT with `impl Drop`, stop there; this type is owned.\n  - When hitting an ADT without `impl Drop`, recursively descend to its fields. (For an `enum`,\n    consider all fields of all variants.)\n- Furthermore, if `T` implements `Drop`, then all generic (lifetime and type) parameters of `T`\n  must be live.\n\nIn the above example, the last clause implies that `'a` must be live when `S<'a>` is dropped,\nand hence the example is rejected. If we remove the `impl Drop`, the liveness requirement\ndisappears and the example is accepted.\n\nThere exists an unstable way for a type to opt-out of the last clause; this is called \"drop\ncheck eyepatch\" or `may_dangle`. For more details on this nightly-only feature, see the\n[discussion in the Nomicon][nomicon].\n\n[`ManuallyDrop`]: crate::mem::ManuallyDrop\n[`PhantomData`]: crate::marker::PhantomData\n[drop check]: ../../nomicon/dropck.html\n[nomicon]: ../../nomicon/phantom-data.html#an-exception-the-special-case-of-the-standard-library-and-its-unstable-may_dangle"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Drop",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Drop"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Eq (alias ==, !=)",
      "kind": 8,
      "documentation": {
        "kind": "markdown",
        "value": "Trait for comparisons corresponding to [equivalence relations](\nhttps://en.wikipedia.org/wiki/Equivalence_relation).\n\nThe primary difference to [`PartialEq`] is the additional requirement for reflexivity. A type\nthat implements [`PartialEq`] guarantees that for all `a`, `b` and `c`:\n\n- symmetric: `a == b` implies `b == a` and `a != b` implies `!(a == b)`\n- transitive: `a == b` and `b == c` implies `a == c`\n\n`Eq`, which builds on top of [`PartialEq`] also implies:\n\n- reflexive: `a == a`\n\nThis property cannot be checked by the compiler, and therefore `Eq` is a trait without methods.\n\nViolating this property is a logic error. The behavior resulting from a logic error is not\nspecified, but users of the trait must ensure that such logic errors do *not* result in\nundefined behavior. This means that `unsafe` code **must not** rely on the correctness of these\nmethods.\n\nFloating point types such as [`f32`] and [`f64`] implement only [`PartialEq`] but *not* `Eq`\nbecause `NaN` != `NaN`.\n\n## Derivable\n\nThis trait can be used with `#[derive]`. When `derive`d, because `Eq` has no extra methods, it\nis only informing the compiler that this is an equivalence relation rather than a partial\nequivalence relation. Note that the `derive` strategy requires all fields are `Eq`, which isn't\nalways desired.\n\n## How can I implement `Eq`?\n\nIf you cannot use the `derive` strategy, specify that your type implements `Eq`, which has no\nextra methods:\n\n```rust\nenum BookFormat {\n    Paperback,\n    Hardback,\n    Ebook,\n}\n\nstruct Book {\n    isbn: i32,\n    format: BookFormat,\n}\n\nimpl PartialEq for Book {\n    fn eq(&self, other: &Self) -> bool {\n        self.isbn == other.isbn\n    }\n}\n\nimpl Eq for Book {}\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Eq",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Eq"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Err(…)",
      "kind": 20,
      "detail": "Err(E)",
      "documentation": {
        "kind": "markdown",
        "value": "Contains the error value"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Err()",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Err(${1:()})$0"
      },
      "additionalTextEdits": []
    },
    {
      "label": "ExactSizeIterator",
      "kind": 8,
      "documentation": {
        "kind": "markdown",
        "value": "An iterator that knows its exact length.\n\nMany [`Iterator`]s don't know how many times they will iterate, but some do.\nIf an iterator knows how many times it can iterate, providing access to\nthat information can be useful. For example, if you want to iterate\nbackwards, a good start is to know where the end is.\n\nWhen implementing an `ExactSizeIterator`, you must also implement\n[`Iterator`]. When doing so, the implementation of [`Iterator::size_hint`]\n*must* return the exact size of the iterator.\n\nThe [`len`] method has a default implementation, so you usually shouldn't\nimplement it. However, you may be able to provide a more performant\nimplementation than the default, so overriding it in this case makes sense.\n\nNote that this trait is a safe trait and as such does *not* and *cannot*\nguarantee that the returned length is correct. This means that `unsafe`\ncode **must not** rely on the correctness of [`Iterator::size_hint`]. The\nunstable and unsafe [`TrustedLen`](super::marker::TrustedLen) trait gives\nthis additional guarantee.\n\n[`len`]: ExactSizeIterator::len\n\n# When *shouldn't* an adapter be `ExactSizeIterator`?\n\nIf an adapter makes an iterator *longer*, then it's usually incorrect for\nthat adapter to implement `ExactSizeIterator`.  The inner exact-sized\niterator might already be `usize::MAX`-long, and thus the length of the\nlonger adapted iterator would no longer be exactly representable in `usize`.\n\nThis is why [`Chain<A, B>`](crate::iter::Chain) isn't `ExactSizeIterator`,\neven when `A` and `B` are both `ExactSizeIterator`.\n\n# Examples\n\nBasic usage:\n\n```rust\n// a finite range knows exactly how many times it will iterate\nlet five = 0..5;\n\nassert_eq!(5, five.len());\n```\n\nIn the [module-level docs], we implemented an [`Iterator`], `Counter`.\nLet's implement `ExactSizeIterator` for it as well:\n\n[module-level docs]: crate::iter\n\n```rust\nimpl ExactSizeIterator for Counter {\n    // We can easily calculate the remaining number of iterations.\n    fn len(&self) -> usize {\n        5 - self.count\n    }\n}\n\n// And now we can use it!\n\nlet mut counter = Counter::new();\n\nassert_eq!(5, counter.len());\nlet _ = counter.next();\nassert_eq!(4, counter.len());\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "ExactSizeIterator",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "ExactSizeIterator"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Extend",
      "kind": 8,
      "documentation": {
        "kind": "markdown",
        "value": "Extend a collection with the contents of an iterator.\n\nIterators produce a series of values, and collections can also be thought\nof as a series of values. The `Extend` trait bridges this gap, allowing you\nto extend a collection by including the contents of that iterator. When\nextending a collection with an already existing key, that entry is updated\nor, in the case of collections that permit multiple entries with equal\nkeys, that entry is inserted.\n\n# Examples\n\nBasic usage:\n\n```rust\n// You can extend a String with some chars:\nlet mut message = String::from(\"The first three letters are: \");\n\nmessage.extend(&['a', 'b', 'c']);\n\nassert_eq!(\"abc\", &message[29..32]);\n```\n\nImplementing `Extend`:\n\n```rust\n// A sample collection, that's just a wrapper over Vec<T>\n#[derive(Debug)]\nstruct MyCollection(Vec<i32>);\n\n// Let's give it some methods so we can create one and add things\n// to it.\nimpl MyCollection {\n    fn new() -> MyCollection {\n        MyCollection(Vec::new())\n    }\n\n    fn add(&mut self, elem: i32) {\n        self.0.push(elem);\n    }\n}\n\n// since MyCollection has a list of i32s, we implement Extend for i32\nimpl Extend<i32> for MyCollection {\n\n    // This is a bit simpler with the concrete type signature: we can call\n    // extend on anything which can be turned into an Iterator which gives\n    // us i32s. Because we need i32s to put into MyCollection.\n    fn extend<T: IntoIterator<Item=i32>>(&mut self, iter: T) {\n\n        // The implementation is very straightforward: loop through the\n        // iterator, and add() each element to ourselves.\n        for elem in iter {\n            self.add(elem);\n        }\n    }\n}\n\nlet mut c = MyCollection::new();\n\nc.add(5);\nc.add(6);\nc.add(7);\n\n// let's extend our collection with three more numbers\nc.extend(vec![1, 2, 3]);\n\n// we've added these elements onto the end\nassert_eq!(\"MyCollection([5, 6, 7, 1, 2, 3])\", format!(\"{c:?}\"));\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Extend",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Extend"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Fn",
      "kind": 8,
      "documentation": {
        "kind": "markdown",
        "value": "The version of the call operator that takes an immutable receiver.\n\nInstances of `Fn` can be called repeatedly without mutating state.\n\n*This trait (`Fn`) is not to be confused with [function pointers]\n(`fn`).*\n\n`Fn` is implemented automatically by closures which only take immutable\nreferences to captured variables or don't capture anything at all, as well\nas (safe) [function pointers] (with some caveats, see their documentation\nfor more details). Additionally, for any type `F` that implements `Fn`, `&F`\nimplements `Fn`, too.\n\nSince both [`FnMut`] and [`FnOnce`] are supertraits of `Fn`, any\ninstance of `Fn` can be used as a parameter where a [`FnMut`] or [`FnOnce`]\nis expected.\n\nUse `Fn` as a bound when you want to accept a parameter of function-like\ntype and need to call it repeatedly and without mutating state (e.g., when\ncalling it concurrently). If you do not need such strict requirements, use\n[`FnMut`] or [`FnOnce`] as bounds.\n\nSee the [chapter on closures in *The Rust Programming Language*][book] for\nsome more information on this topic.\n\nAlso of note is the special syntax for `Fn` traits (e.g.\n`Fn(usize, bool) -> usize`). Those interested in the technical details of\nthis can refer to [the relevant section in the *Rustonomicon*][nomicon].\n\n[book]: ../../book/ch13-01-closures.html\n[function pointers]: fn\n[nomicon]: ../../nomicon/hrtb.html\n\n# Examples\n\n## Calling a closure\n\n```rust\nlet square = |x| x * x;\nassert_eq!(square(5), 25);\n```\n\n## Using a `Fn` parameter\n\n```rust\nfn call_with_one<F>(func: F) -> usize\n    where F: Fn(usize) -> usize {\n    func(1)\n}\n\nlet double = |x| x * 2;\nassert_eq!(call_with_one(double), 2);\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Fn",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Fn"
      },
      "additionalTextEdits": []
    },
    {
      "label": "FnMut",
      "kind": 8,
      "documentation": {
        "kind": "markdown",
        "value": "The version of the call operator that takes a mutable receiver.\n\nInstances of `FnMut` can be called repeatedly and may mutate state.\n\n`FnMut` is implemented automatically by closures which take mutable\nreferences to captured variables, as well as all types that implement\n[`Fn`], e.g., (safe) [function pointers] (since `FnMut` is a supertrait of\n[`Fn`]). Additionally, for any type `F` that implements `FnMut`, `&mut F`\nimplements `FnMut`, too.\n\nSince [`FnOnce`] is a supertrait of `FnMut`, any instance of `FnMut` can be\nused where a [`FnOnce`] is expected, and since [`Fn`] is a subtrait of\n`FnMut`, any instance of [`Fn`] can be used where `FnMut` is expected.\n\nUse `FnMut` as a bound when you want to accept a parameter of function-like\ntype and need to call it repeatedly, while allowing it to mutate state.\nIf you don't want the parameter to mutate state, use [`Fn`] as a\nbound; if you don't need to call it repeatedly, use [`FnOnce`].\n\nSee the [chapter on closures in *The Rust Programming Language*][book] for\nsome more information on this topic.\n\nAlso of note is the special syntax for `Fn` traits (e.g.\n`Fn(usize, bool) -> usize`). Those interested in the technical details of\nthis can refer to [the relevant section in the *Rustonomicon*][nomicon].\n\n[book]: ../../book/ch13-01-closures.html\n[function pointers]: fn\n[nomicon]: ../../nomicon/hrtb.html\n\n# Examples\n\n## Calling a mutably capturing closure\n\n```rust\nlet mut x = 5;\n{\n    let mut square_x = || x *= x;\n    square_x();\n}\nassert_eq!(x, 25);\n```\n\n## Using a `FnMut` parameter\n\n```rust\nfn do_twice<F>(mut func: F)\n    where F: FnMut()\n{\n    func();\n    func();\n}\n\nlet mut x: usize = 1;\n{\n    let add_two_to_x = || x += 2;\n    do_twice(add_two_to_x);\n}\n\nassert_eq!(x, 5);\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "FnMut",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "FnMut"
      },
      "additionalTextEdits": []
    },
    {
      "label": "FnOnce",
      "kind": 8,
      "documentation": {
        "kind": "markdown",
        "value": "The version of the call operator that takes a by-value receiver.\n\nInstances of `FnOnce` can be called, but might not be callable multiple\ntimes. Because of this, if the only thing known about a type is that it\nimplements `FnOnce`, it can only be called once.\n\n`FnOnce` is implemented automatically by closures that might consume captured\nvariables, as well as all types that implement [`FnMut`], e.g., (safe)\n[function pointers] (since `FnOnce` is a supertrait of [`FnMut`]).\n\nSince both [`Fn`] and [`FnMut`] are subtraits of `FnOnce`, any instance of\n[`Fn`] or [`FnMut`] can be used where a `FnOnce` is expected.\n\nUse `FnOnce` as a bound when you want to accept a parameter of function-like\ntype and only need to call it once. If you need to call the parameter\nrepeatedly, use [`FnMut`] as a bound; if you also need it to not mutate\nstate, use [`Fn`].\n\nSee the [chapter on closures in *The Rust Programming Language*][book] for\nsome more information on this topic.\n\nAlso of note is the special syntax for `Fn` traits (e.g.\n`Fn(usize, bool) -> usize`). Those interested in the technical details of\nthis can refer to [the relevant section in the *Rustonomicon*][nomicon].\n\n[book]: ../../book/ch13-01-closures.html\n[function pointers]: fn\n[nomicon]: ../../nomicon/hrtb.html\n\n# Examples\n\n## Using a `FnOnce` parameter\n\n```rust\nfn consume_with_relish<F>(func: F)\n    where F: FnOnce() -> String\n{\n    // `func` consumes its captured variables, so it cannot be run more\n    // than once.\n    println!(\"Consumed: {}\", func());\n\n    println!(\"Delicious!\");\n\n    // Attempting to invoke `func()` again will throw a `use of moved\n    // value` error for `func`.\n}\n\nlet x = String::from(\"x\");\nlet consume_and_return_x = move || x;\nconsume_with_relish(consume_and_return_x);\n\n// `consume_and_return_x` can no longer be invoked at this point\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "FnOnce",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "FnOnce"
      },
      "additionalTextEdits": []
    },
    {
      "label": "From",
      "kind": 8,
      "documentation": {
        "kind": "markdown",
        "value": "Used to do value-to-value conversions while consuming the input value. It is the reciprocal of\n[`Into`].\n\nOne should always prefer implementing `From` over [`Into`]\nbecause implementing `From` automatically provides one with an implementation of [`Into`]\nthanks to the blanket implementation in the standard library.\n\nOnly implement [`Into`] when targeting a version prior to Rust 1.41 and converting to a type\noutside the current crate.\n`From` was not able to do these types of conversions in earlier versions because of Rust's\norphaning rules.\nSee [`Into`] for more details.\n\nPrefer using [`Into`] over using `From` when specifying trait bounds on a generic function.\nThis way, types that directly implement [`Into`] can be used as arguments as well.\n\nThe `From` trait is also very useful when performing error handling. When constructing a function\nthat is capable of failing, the return type will generally be of the form `Result<T, E>`.\n`From` simplifies error handling by allowing a function to return a single error type\nthat encapsulates multiple error types. See the \"Examples\" section and [the book][book] for more\ndetails.\n\n**Note: This trait must not fail**. The `From` trait is intended for perfect conversions.\nIf the conversion can fail or is not perfect, use [`TryFrom`].\n\n# Generic Implementations\n\n- `From<T> for U` implies [`Into`]`<U> for T`\n- `From` is reflexive, which means that `From<T> for T` is implemented\n\n# When to implement `From`\n\nWhile there's no technical restrictions on which conversions can be done using\na `From` implementation, the general expectation is that the conversions\nshould typically be restricted as follows:\n\n* The conversion is *infallible*: if the conversion can fail, use [`TryFrom`]\n  instead; don't provide a `From` impl that panics.\n\n* The conversion is *lossless*: semantically, it should not lose or discard\n  information. For example, `i32: From<u16>` exists, where the original\n  value can be recovered using `u16: TryFrom<i32>`.  And `String: From<&str>`\n  exists, where you can get something equivalent to the original value via\n  `Deref`.  But `From` cannot be used to convert from `u32` to `u16`, since\n  that cannot succeed in a lossless way.  (There's some wiggle room here for\n  information not considered semantically relevant.  For example,\n  `Box<[T]>: From<Vec<T>>` exists even though it might not preserve capacity,\n  like how two vectors can be equal despite differing capacities.)\n\n* The conversion is *value-preserving*: the conceptual kind and meaning of\n  the resulting value is the same, even though the Rust type and technical\n  representation might be different.  For example `-1_i8 as u8` is *lossless*,\n  since `as` casting back can recover the original value, but that conversion\n  is *not* available via `From` because `-1` and `255` are different conceptual\n  values (despite being identical bit patterns technically).  But\n  `f32: From<i16>` *is* available because `1_i16` and `1.0_f32` are conceptually\n  the same real number (despite having very different bit patterns technically).\n  `String: From<char>` is available because they're both *text*, but\n  `String: From<u32>` is *not* available, since `1` (a number) and `\"1\"`\n  (text) are too different.  (Converting values to text is instead covered\n  by the [`Display`](crate::fmt::Display) trait.)\n\n* The conversion is *obvious*: it's the only reasonable conversion between\n  the two types.  Otherwise it's better to have it be a named method or\n  constructor, like how [`str::as_bytes`] is a method and how integers have\n  methods like [`u32::from_ne_bytes`], [`u32::from_le_bytes`], and\n  [`u32::from_be_bytes`], none of which are `From` implementations.  Whereas\n  there's only one reasonable way to wrap an [`Ipv6Addr`](crate::net::Ipv6Addr)\n  into an [`IpAddr`](crate::net::IpAddr), thus `IpAddr: From<Ipv6Addr>` exists.\n\n# Examples\n\n[`String`] implements `From<&str>`:\n\nAn explicit conversion from a `&str` to a String is done as follows:\n\n```rust\nlet string = \"hello\".to_string();\nlet other_string = String::from(\"hello\");\n\nassert_eq!(string, other_string);\n```\n\nWhile performing error handling it is often useful to implement `From` for your own error type.\nBy converting underlying error types to our own custom error type that encapsulates the\nunderlying error type, we can return a single error type without losing information on the\nunderlying cause. The '?' operator automatically converts the underlying error type to our\ncustom error type with `From::from`.\n\n```rust\nuse std::fs;\nuse std::io;\nuse std::num;\n\nenum CliError {\n    IoError(io::Error),\n    ParseError(num::ParseIntError),\n}\n\nimpl From<io::Error> for CliError {\n    fn from(error: io::Error) -> Self {\n        CliError::IoError(error)\n    }\n}\n\nimpl From<num::ParseIntError> for CliError {\n    fn from(error: num::ParseIntError) -> Self {\n        CliError::ParseError(error)\n    }\n}\n\nfn open_and_parse_file(file_name: &str) -> Result<i32, CliError> {\n    let mut contents = fs::read_to_string(&file_name)?;\n    let num: i32 = contents.trim().parse()?;\n    Ok(num)\n}\n```\n\n[`String`]: ../../std/string/struct.String.html\n[`from`]: From::from\n[book]: ../../book/ch09-00-error-handling.html"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "From",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "From"
      },
      "additionalTextEdits": []
    },
    {
      "label": "FromIterator",
      "kind": 8,
      "documentation": {
        "kind": "markdown",
        "value": "Conversion from an [`Iterator`].\n\nBy implementing `FromIterator` for a type, you define how it will be\ncreated from an iterator. This is common for types which describe a\ncollection of some kind.\n\nIf you want to create a collection from the contents of an iterator, the\n[`Iterator::collect()`] method is preferred. However, when you need to\nspecify the container type, [`FromIterator::from_iter()`] can be more\nreadable than using a turbofish (e.g. `::<Vec<_>>()`). See the\n[`Iterator::collect()`] documentation for more examples of its use.\n\nSee also: [`IntoIterator`].\n\n# Examples\n\nBasic usage:\n\n```rust\nlet five_fives = std::iter::repeat(5).take(5);\n\nlet v = Vec::from_iter(five_fives);\n\nassert_eq!(v, vec![5, 5, 5, 5, 5]);\n```\n\nUsing [`Iterator::collect()`] to implicitly use `FromIterator`:\n\n```rust\nlet five_fives = std::iter::repeat(5).take(5);\n\nlet v: Vec<i32> = five_fives.collect();\n\nassert_eq!(v, vec![5, 5, 5, 5, 5]);\n```\n\nUsing [`FromIterator::from_iter()`] as a more readable alternative to\n[`Iterator::collect()`]:\n\n```rust\nuse std::collections::VecDeque;\nlet first = (0..10).collect::<VecDeque<i32>>();\nlet second = VecDeque::from_iter(0..10);\n\nassert_eq!(first, second);\n```\n\nImplementing `FromIterator` for your type:\n\n```rust\n// A sample collection, that's just a wrapper over Vec<T>\n#[derive(Debug)]\nstruct MyCollection(Vec<i32>);\n\n// Let's give it some methods so we can create one and add things\n// to it.\nimpl MyCollection {\n    fn new() -> MyCollection {\n        MyCollection(Vec::new())\n    }\n\n    fn add(&mut self, elem: i32) {\n        self.0.push(elem);\n    }\n}\n\n// and we'll implement FromIterator\nimpl FromIterator<i32> for MyCollection {\n    fn from_iter<I: IntoIterator<Item=i32>>(iter: I) -> Self {\n        let mut c = MyCollection::new();\n\n        for i in iter {\n            c.add(i);\n        }\n\n        c\n    }\n}\n\n// Now we can make a new iterator...\nlet iter = (0..5).into_iter();\n\n// ... and make a MyCollection out of it\nlet c = MyCollection::from_iter(iter);\n\nassert_eq!(c.0, vec![0, 1, 2, 3, 4]);\n\n// collect works too!\n\nlet iter = (0..5).into_iter();\nlet c: MyCollection = iter.collect();\n\nassert_eq!(c.0, vec![0, 1, 2, 3, 4]);\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "FromIterator",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "FromIterator"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Into",
      "kind": 8,
      "documentation": {
        "kind": "markdown",
        "value": "A value-to-value conversion that consumes the input value. The\nopposite of [`From`].\n\nOne should avoid implementing [`Into`] and implement [`From`] instead.\nImplementing [`From`] automatically provides one with an implementation of [`Into`]\nthanks to the blanket implementation in the standard library.\n\nPrefer using [`Into`] over [`From`] when specifying trait bounds on a generic function\nto ensure that types that only implement [`Into`] can be used as well.\n\n**Note: This trait must not fail**. If the conversion can fail, use [`TryInto`].\n\n# Generic Implementations\n\n- [`From`]`<T> for U` implies `Into<U> for T`\n- [`Into`] is reflexive, which means that `Into<T> for T` is implemented\n\n# Implementing [`Into`] for conversions to external types in old versions of Rust\n\nPrior to Rust 1.41, if the destination type was not part of the current crate\nthen you couldn't implement [`From`] directly.\nFor example, take this code:\n\n```rust\nstruct Wrapper<T>(Vec<T>);\nimpl<T> From<Wrapper<T>> for Vec<T> {\n    fn from(w: Wrapper<T>) -> Vec<T> {\n        w.0\n    }\n}\n```\nThis will fail to compile in older versions of the language because Rust's orphaning rules\nused to be a little bit more strict. To bypass this, you could implement [`Into`] directly:\n\n```rust\nstruct Wrapper<T>(Vec<T>);\nimpl<T> Into<Vec<T>> for Wrapper<T> {\n    fn into(self) -> Vec<T> {\n        self.0\n    }\n}\n```\n\nIt is important to understand that [`Into`] does not provide a [`From`] implementation\n(as [`From`] does with [`Into`]). Therefore, you should always try to implement [`From`]\nand then fall back to [`Into`] if [`From`] can't be implemented.\n\n# Examples\n\n[`String`] implements [`Into`]`<`[`Vec`]`<`[`u8`]`>>`:\n\nIn order to express that we want a generic function to take all arguments that can be\nconverted to a specified type `T`, we can use a trait bound of [`Into`]`<T>`.\nFor example: The function `is_hello` takes all arguments that can be converted into a\n[`Vec`]`<`[`u8`]`>`.\n\n```rust\nfn is_hello<T: Into<Vec<u8>>>(s: T) {\n   let bytes = b\"hello\".to_vec();\n   assert_eq!(bytes, s.into());\n}\n\nlet s = \"hello\".to_string();\nis_hello(s);\n```\n\n[`String`]: ../../std/string/struct.String.html\n[`Vec`]: ../../std/vec/struct.Vec.html"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Into",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Into"
      },
      "additionalTextEdits": []
    },
    {
      "label": "IntoIterator",
      "kind": 8,
      "documentation": {
        "kind": "markdown",
        "value": "Conversion into an [`Iterator`].\n\nBy implementing `IntoIterator` for a type, you define how it will be\nconverted to an iterator. This is common for types which describe a\ncollection of some kind.\n\nOne benefit of implementing `IntoIterator` is that your type will [work\nwith Rust's `for` loop syntax](crate::iter#for-loops-and-intoiterator).\n\nSee also: [`FromIterator`].\n\n# Examples\n\nBasic usage:\n\n```rust\nlet v = [1, 2, 3];\nlet mut iter = v.into_iter();\n\nassert_eq!(Some(1), iter.next());\nassert_eq!(Some(2), iter.next());\nassert_eq!(Some(3), iter.next());\nassert_eq!(None, iter.next());\n```\nImplementing `IntoIterator` for your type:\n\n```rust\n// A sample collection, that's just a wrapper over Vec<T>\n#[derive(Debug)]\nstruct MyCollection(Vec<i32>);\n\n// Let's give it some methods so we can create one and add things\n// to it.\nimpl MyCollection {\n    fn new() -> MyCollection {\n        MyCollection(Vec::new())\n    }\n\n    fn add(&mut self, elem: i32) {\n        self.0.push(elem);\n    }\n}\n\n// and we'll implement IntoIterator\nimpl IntoIterator for MyCollection {\n    type Item = i32;\n    type IntoIter = std::vec::IntoIter<Self::Item>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        self.0.into_iter()\n    }\n}\n\n// Now we can make a new collection...\nlet mut c = MyCollection::new();\n\n// ... add some stuff to it ...\nc.add(0);\nc.add(1);\nc.add(2);\n\n// ... and then turn it into an Iterator:\nfor (i, n) in c.into_iter().enumerate() {\n    assert_eq!(i as i32, n);\n}\n```\n\nIt is common to use `IntoIterator` as a trait bound. This allows\nthe input collection type to change, so long as it is still an\niterator. Additional bounds can be specified by restricting on\n`Item`:\n\n```rust\nfn collect_as_strings<T>(collection: T) -> Vec<String>\nwhere\n    T: IntoIterator,\n    T::Item: std::fmt::Debug,\n{\n    collection\n        .into_iter()\n        .map(|item| format!(\"{item:?}\"))\n        .collect()\n}\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "IntoIterator",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "IntoIterator"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Iterator",
      "kind": 8,
      "documentation": {
        "kind": "markdown",
        "value": "A trait for dealing with iterators.\n\nThis is the main iterator trait. For more about the concept of iterators\ngenerally, please see the [module-level documentation]. In particular, you\nmay want to know how to [implement `Iterator`][impl].\n\n[module-level documentation]: crate::iter\n[impl]: crate::iter#implementing-iterator"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Iterator",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Iterator"
      },
      "additionalTextEdits": []
    },
    {
      "label": "None",
      "kind": 20,
      "detail": "None",
      "documentation": {
        "kind": "markdown",
        "value": "No value."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "None",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "None$0"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Ok(…)",
      "kind": 20,
      "detail": "Ok(T)",
      "documentation": {
        "kind": "markdown",
        "value": "Contains the success value"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Ok()",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Ok(${1:()})$0"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Option",
      "kind": 13,
      "detail": "Option<{unknown}>",
      "documentation": {
        "kind": "markdown",
        "value": "The `Option` type. See [the module level documentation](self) for more."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Option",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Option"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Ord (alias <, >, <=, >=)",
      "kind": 8,
      "documentation": {
        "kind": "markdown",
        "value": "Trait for types that form a [total order](https://en.wikipedia.org/wiki/Total_order).\n\nImplementations must be consistent with the [`PartialOrd`] implementation, and ensure `max`,\n`min`, and `clamp` are consistent with `cmp`:\n\n- `partial_cmp(a, b) == Some(cmp(a, b))`.\n- `max(a, b) == max_by(a, b, cmp)` (ensured by the default implementation).\n- `min(a, b) == min_by(a, b, cmp)` (ensured by the default implementation).\n- For `a.clamp(min, max)`, see the [method docs](#method.clamp) (ensured by the default\n  implementation).\n\nViolating these requirements is a logic error. The behavior resulting from a logic error is not\nspecified, but users of the trait must ensure that such logic errors do *not* result in\nundefined behavior. This means that `unsafe` code **must not** rely on the correctness of these\nmethods.\n\n## Corollaries\n\nFrom the above and the requirements of `PartialOrd`, it follows that for all `a`, `b` and `c`:\n\n- exactly one of `a < b`, `a == b` or `a > b` is true; and\n- `<` is transitive: `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and\n  `>`.\n\nMathematically speaking, the `<` operator defines a strict [weak order]. In cases where `==`\nconforms to mathematical equality, it also defines a strict [total order].\n\n[weak order]: https://en.wikipedia.org/wiki/Weak_ordering\n[total order]: https://en.wikipedia.org/wiki/Total_order\n\n## Derivable\n\nThis trait can be used with `#[derive]`.\n\nWhen `derive`d on structs, it will produce a\n[lexicographic](https://en.wikipedia.org/wiki/Lexicographic_order) ordering based on the\ntop-to-bottom declaration order of the struct's members.\n\nWhen `derive`d on enums, variants are ordered primarily by their discriminants. Secondarily,\nthey are ordered by their fields. By default, the discriminant is smallest for variants at the\ntop, and largest for variants at the bottom. Here's an example:\n\n```rust\n#[derive(PartialEq, Eq, PartialOrd, Ord)]\nenum E {\n    Top,\n    Bottom,\n}\n\nassert!(E::Top < E::Bottom);\n```\n\nHowever, manually setting the discriminants can override this default behavior:\n\n```rust\n#[derive(PartialEq, Eq, PartialOrd, Ord)]\nenum E {\n    Top = 2,\n    Bottom = 1,\n}\n\nassert!(E::Bottom < E::Top);\n```\n\n## Lexicographical comparison\n\nLexicographical comparison is an operation with the following properties:\n - Two sequences are compared element by element.\n - The first mismatching element defines which sequence is lexicographically less or greater\n   than the other.\n - If one sequence is a prefix of another, the shorter sequence is lexicographically less than\n   the other.\n - If two sequences have equivalent elements and are of the same length, then the sequences are\n   lexicographically equal.\n - An empty sequence is lexicographically less than any non-empty sequence.\n - Two empty sequences are lexicographically equal.\n\n## How can I implement `Ord`?\n\n`Ord` requires that the type also be [`PartialOrd`], [`PartialEq`], and [`Eq`].\n\nBecause `Ord` implies a stronger ordering relationship than [`PartialOrd`], and both `Ord` and\n[`PartialOrd`] must agree, you must choose how to implement `Ord` **first**. You can choose to\nderive it, or implement it manually. If you derive it, you should derive all four traits. If you\nimplement it manually, you should manually implement all four traits, based on the\nimplementation of `Ord`.\n\nHere's an example where you want to define the `Character` comparison by `health` and\n`experience` only, disregarding the field `mana`:\n\n```rust\nuse std::cmp::Ordering;\n\nstruct Character {\n    health: u32,\n    experience: u32,\n    mana: f32,\n}\n\nimpl Ord for Character {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        self.experience\n            .cmp(&other.experience)\n            .then(self.health.cmp(&other.health))\n    }\n}\n\nimpl PartialOrd for Character {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\nimpl PartialEq for Character {\n    fn eq(&self, other: &Self) -> bool {\n        self.health == other.health && self.experience == other.experience\n    }\n}\n\nimpl Eq for Character {}\n```\n\nIf all you need is to `slice::sort` a type by a field value, it can be simpler to use\n`slice::sort_by_key`.\n\n## Examples of incorrect `Ord` implementations\n\n```rust\nuse std::cmp::Ordering;\n\n#[derive(Debug)]\nstruct Character {\n    health: f32,\n}\n\nimpl Ord for Character {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        if self.health < other.health {\n            Ordering::Less\n        } else if self.health > other.health {\n            Ordering::Greater\n        } else {\n            Ordering::Equal\n        }\n    }\n}\n\nimpl PartialOrd for Character {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\nimpl PartialEq for Character {\n    fn eq(&self, other: &Self) -> bool {\n        self.health == other.health\n    }\n}\n\nimpl Eq for Character {}\n\nlet a = Character { health: 4.5 };\nlet b = Character { health: f32::NAN };\n\n// Mistake: floating-point values do not form a total order and using the built-in comparison\n// operands to implement `Ord` irregardless of that reality does not change it. Use\n// `f32::total_cmp` if you need a total order for floating-point values.\n\n// Reflexivity requirement of `Ord` is not given.\nassert!(a == a);\nassert!(b != b);\n\n// Antisymmetry requirement of `Ord` is not given. Only one of a < c and c < a is allowed to be\n// true, not both or neither.\nassert_eq!((a < b) as u8 + (b < a) as u8, 0);\n```\n\n```rust\nuse std::cmp::Ordering;\n\n#[derive(Debug)]\nstruct Character {\n    health: u32,\n    experience: u32,\n}\n\nimpl PartialOrd for Character {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\nimpl Ord for Character {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        if self.health < 50 {\n            self.health.cmp(&other.health)\n        } else {\n            self.experience.cmp(&other.experience)\n        }\n    }\n}\n\n// For performance reasons implementing `PartialEq` this way is not the idiomatic way, but it\n// ensures consistent behavior between `PartialEq`, `PartialOrd` and `Ord` in this example.\nimpl PartialEq for Character {\n    fn eq(&self, other: &Self) -> bool {\n        self.cmp(other) == Ordering::Equal\n    }\n}\n\nimpl Eq for Character {}\n\nlet a = Character {\n    health: 3,\n    experience: 5,\n};\nlet b = Character {\n    health: 10,\n    experience: 77,\n};\nlet c = Character {\n    health: 143,\n    experience: 2,\n};\n\n// Mistake: The implementation of `Ord` compares different fields depending on the value of\n// `self.health`, the resulting order is not total.\n\n// Transitivity requirement of `Ord` is not given. If a is smaller than b and b is smaller than\n// c, by transitive property a must also be smaller than c.\nassert!(a < b && b < c && c < a);\n\n// Antisymmetry requirement of `Ord` is not given. Only one of a < c and c < a is allowed to be\n// true, not both or neither.\nassert_eq!((a < c) as u8 + (c < a) as u8, 2);\n```\n\nThe documentation of [`PartialOrd`] contains further examples, for example it's wrong for\n[`PartialOrd`] and [`PartialEq`] to disagree.\n\n[`cmp`]: Ord::cmp"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Ord",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Ord"
      },
      "additionalTextEdits": []
    },
    {
      "label": "PartialEq (alias ==, !=)",
      "kind": 8,
      "documentation": {
        "kind": "markdown",
        "value": "Trait for comparisons using the equality operator.\n\nImplementing this trait for types provides the `==` and `!=` operators for\nthose types.\n\n`x.eq(y)` can also be written `x == y`, and `x.ne(y)` can be written `x != y`.\nWe use the easier-to-read infix notation in the remainder of this documentation.\n\nThis trait allows for comparisons using the equality operator, for types\nthat do not have a full equivalence relation. For example, in floating point\nnumbers `NaN != NaN`, so floating point types implement `PartialEq` but not\n[`trait@Eq`]. Formally speaking, when `Rhs == Self`, this trait corresponds\nto a [partial equivalence relation].\n\n[partial equivalence relation]: https://en.wikipedia.org/wiki/Partial_equivalence_relation\n\nImplementations must ensure that `eq` and `ne` are consistent with each other:\n\n- `a != b` if and only if `!(a == b)`.\n\nThe default implementation of `ne` provides this consistency and is almost\nalways sufficient. It should not be overridden without very good reason.\n\nIf [`PartialOrd`] or [`Ord`] are also implemented for `Self` and `Rhs`, their methods must also\nbe consistent with `PartialEq` (see the documentation of those traits for the exact\nrequirements). It's easy to accidentally make them disagree by deriving some of the traits and\nmanually implementing others.\n\nThe equality relation `==` must satisfy the following conditions\n(for all `a`, `b`, `c` of type `A`, `B`, `C`):\n\n- **Symmetry**: if `A: PartialEq<B>` and `B: PartialEq<A>`, then **`a == b`\n  implies `b == a`**; and\n\n- **Transitivity**: if `A: PartialEq<B>` and `B: PartialEq<C>` and `A:\n  PartialEq<C>`, then **`a == b` and `b == c` implies `a == c`**.\n  This must also work for longer chains, such as when `A: PartialEq<B>`, `B: PartialEq<C>`,\n  `C: PartialEq<D>`, and `A: PartialEq<D>` all exist.\n\nNote that the `B: PartialEq<A>` (symmetric) and `A: PartialEq<C>`\n(transitive) impls are not forced to exist, but these requirements apply\nwhenever they do exist.\n\nViolating these requirements is a logic error. The behavior resulting from a logic error is not\nspecified, but users of the trait must ensure that such logic errors do *not* result in\nundefined behavior. This means that `unsafe` code **must not** rely on the correctness of these\nmethods.\n\n## Cross-crate considerations\n\nUpholding the requirements stated above can become tricky when one crate implements `PartialEq`\nfor a type of another crate (i.e., to allow comparing one of its own types with a type from the\nstandard library). The recommendation is to never implement this trait for a foreign type. In\nother words, such a crate should do `impl PartialEq<ForeignType> for LocalType`, but it should\n*not* do `impl PartialEq<LocalType> for ForeignType`.\n\nThis avoids the problem of transitive chains that criss-cross crate boundaries: for all local\ntypes `T`, you may assume that no other crate will add `impl`s that allow comparing `T == U`. In\nother words, if other crates add `impl`s that allow building longer transitive chains `U1 == ...\n== T == V1 == ...`, then all the types that appear to the right of `T` must be types that the\ncrate defining `T` already knows about. This rules out transitive chains where downstream crates\ncan add new `impl`s that \"stitch together\" comparisons of foreign types in ways that violate\ntransitivity.\n\nNot having such foreign `impl`s also avoids forward compatibility issues where one crate adding\nmore `PartialEq` implementations can cause build failures in downstream crates.\n\n## Derivable\n\nThis trait can be used with `#[derive]`. When `derive`d on structs, two\ninstances are equal if all fields are equal, and not equal if any fields\nare not equal. When `derive`d on enums, two instances are equal if they\nare the same variant and all fields are equal.\n\n## How can I implement `PartialEq`?\n\nAn example implementation for a domain in which two books are considered\nthe same book if their ISBN matches, even if the formats differ:\n\n```rust\nenum BookFormat {\n    Paperback,\n    Hardback,\n    Ebook,\n}\n\nstruct Book {\n    isbn: i32,\n    format: BookFormat,\n}\n\nimpl PartialEq for Book {\n    fn eq(&self, other: &Self) -> bool {\n        self.isbn == other.isbn\n    }\n}\n\nlet b1 = Book { isbn: 3, format: BookFormat::Paperback };\nlet b2 = Book { isbn: 3, format: BookFormat::Ebook };\nlet b3 = Book { isbn: 10, format: BookFormat::Paperback };\n\nassert!(b1 == b2);\nassert!(b1 != b3);\n```\n\n## How can I compare two different types?\n\nThe type you can compare with is controlled by `PartialEq`'s type parameter.\nFor example, let's tweak our previous code a bit:\n\n```rust\n// The derive implements <BookFormat> == <BookFormat> comparisons\n#[derive(PartialEq)]\nenum BookFormat {\n    Paperback,\n    Hardback,\n    Ebook,\n}\n\nstruct Book {\n    isbn: i32,\n    format: BookFormat,\n}\n\n// Implement <Book> == <BookFormat> comparisons\nimpl PartialEq<BookFormat> for Book {\n    fn eq(&self, other: &BookFormat) -> bool {\n        self.format == *other\n    }\n}\n\n// Implement <BookFormat> == <Book> comparisons\nimpl PartialEq<Book> for BookFormat {\n    fn eq(&self, other: &Book) -> bool {\n        *self == other.format\n    }\n}\n\nlet b1 = Book { isbn: 3, format: BookFormat::Paperback };\n\nassert!(b1 == BookFormat::Paperback);\nassert!(BookFormat::Ebook != b1);\n```\n\nBy changing `impl PartialEq for Book` to `impl PartialEq<BookFormat> for Book`,\nwe allow `BookFormat`s to be compared with `Book`s.\n\nA comparison like the one above, which ignores some fields of the struct,\ncan be dangerous. It can easily lead to an unintended violation of the\nrequirements for a partial equivalence relation. For example, if we kept\nthe above implementation of `PartialEq<Book>` for `BookFormat` and added an\nimplementation of `PartialEq<Book>` for `Book` (either via a `#[derive]` or\nvia the manual implementation from the first example) then the result would\nviolate transitivity:\n\n```rust\n#[derive(PartialEq)]\nenum BookFormat {\n    Paperback,\n    Hardback,\n    Ebook,\n}\n\n#[derive(PartialEq)]\nstruct Book {\n    isbn: i32,\n    format: BookFormat,\n}\n\nimpl PartialEq<BookFormat> for Book {\n    fn eq(&self, other: &BookFormat) -> bool {\n        self.format == *other\n    }\n}\n\nimpl PartialEq<Book> for BookFormat {\n    fn eq(&self, other: &Book) -> bool {\n        *self == other.format\n    }\n}\n\nfn main() {\n    let b1 = Book { isbn: 1, format: BookFormat::Paperback };\n    let b2 = Book { isbn: 2, format: BookFormat::Paperback };\n\n    assert!(b1 == BookFormat::Paperback);\n    assert!(BookFormat::Paperback == b2);\n\n    // The following should hold by transitivity but doesn't.\n    assert!(b1 == b2); // <-- PANICS\n}\n```\n\n# Examples\n\n```rust\nlet x: u32 = 0;\nlet y: u32 = 1;\n\nassert_eq!(x == y, false);\nassert_eq!(x.eq(&y), false);\n```\n\n[`eq`]: PartialEq::eq\n[`ne`]: PartialEq::ne"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "PartialEq",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "PartialEq"
      },
      "additionalTextEdits": []
    },
    {
      "label": "PartialOrd (alias >, <, <=, >=)",
      "kind": 8,
      "documentation": {
        "kind": "markdown",
        "value": "Trait for types that form a [partial order](https://en.wikipedia.org/wiki/Partial_order).\n\nThe `lt`, `le`, `gt`, and `ge` methods of this trait can be called using the `<`, `<=`, `>`, and\n`>=` operators, respectively.\n\nThis trait should **only** contain the comparison logic for a type **if one plans on only\nimplementing `PartialOrd` but not [`Ord`]**. Otherwise the comparison logic should be in [`Ord`]\nand this trait implemented with `Some(self.cmp(other))`.\n\nThe methods of this trait must be consistent with each other and with those of [`PartialEq`].\nThe following conditions must hold:\n\n1. `a == b` if and only if `partial_cmp(a, b) == Some(Equal)`.\n2. `a < b` if and only if `partial_cmp(a, b) == Some(Less)`\n3. `a > b` if and only if `partial_cmp(a, b) == Some(Greater)`\n4. `a <= b` if and only if `a < b || a == b`\n5. `a >= b` if and only if `a > b || a == b`\n6. `a != b` if and only if `!(a == b)`.\n\nConditions 2–5 above are ensured by the default implementation. Condition 6 is already ensured\nby [`PartialEq`].\n\nIf [`Ord`] is also implemented for `Self` and `Rhs`, it must also be consistent with\n`partial_cmp` (see the documentation of that trait for the exact requirements). It's easy to\naccidentally make them disagree by deriving some of the traits and manually implementing others.\n\nThe comparison relations must satisfy the following conditions (for all `a`, `b`, `c` of type\n`A`, `B`, `C`):\n\n- **Transitivity**: if `A: PartialOrd<B>` and `B: PartialOrd<C>` and `A: PartialOrd<C>`, then `a\n  < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`. This must also\n  work for longer chains, such as when `A: PartialOrd<B>`, `B: PartialOrd<C>`, `C:\n  PartialOrd<D>`, and `A: PartialOrd<D>` all exist.\n- **Duality**: if `A: PartialOrd<B>` and `B: PartialOrd<A>`, then `a < b` if and only if `b >\n  a`.\n\nNote that the `B: PartialOrd<A>` (dual) and `A: PartialOrd<C>` (transitive) impls are not forced\nto exist, but these requirements apply whenever they do exist.\n\nViolating these requirements is a logic error. The behavior resulting from a logic error is not\nspecified, but users of the trait must ensure that such logic errors do *not* result in\nundefined behavior. This means that `unsafe` code **must not** rely on the correctness of these\nmethods.\n\n## Cross-crate considerations\n\nUpholding the requirements stated above can become tricky when one crate implements `PartialOrd`\nfor a type of another crate (i.e., to allow comparing one of its own types with a type from the\nstandard library). The recommendation is to never implement this trait for a foreign type. In\nother words, such a crate should do `impl PartialOrd<ForeignType> for LocalType`, but it should\n*not* do `impl PartialOrd<LocalType> for ForeignType`.\n\nThis avoids the problem of transitive chains that criss-cross crate boundaries: for all local\ntypes `T`, you may assume that no other crate will add `impl`s that allow comparing `T < U`. In\nother words, if other crates add `impl`s that allow building longer transitive chains `U1 < ...\n< T < V1 < ...`, then all the types that appear to the right of `T` must be types that the crate\ndefining `T` already knows about. This rules out transitive chains where downstream crates can\nadd new `impl`s that \"stitch together\" comparisons of foreign types in ways that violate\ntransitivity.\n\nNot having such foreign `impl`s also avoids forward compatibility issues where one crate adding\nmore `PartialOrd` implementations can cause build failures in downstream crates.\n\n## Corollaries\n\nThe following corollaries follow from the above requirements:\n\n- irreflexivity of `<` and `>`: `!(a < a)`, `!(a > a)`\n- transitivity of `>`: if `a > b` and `b > c` then `a > c`\n- duality of `partial_cmp`: `partial_cmp(a, b) == partial_cmp(b, a).map(Ordering::reverse)`\n\n## Strict and non-strict partial orders\n\nThe `<` and `>` operators behave according to a *strict* partial order. However, `<=` and `>=`\ndo **not** behave according to a *non-strict* partial order. That is because mathematically, a\nnon-strict partial order would require reflexivity, i.e. `a <= a` would need to be true for\nevery `a`. This isn't always the case for types that implement `PartialOrd`, for example:\n\n```rust\nlet a = f64::sqrt(-1.0);\nassert_eq!(a <= a, false);\n```\n\n## Derivable\n\nThis trait can be used with `#[derive]`.\n\nWhen `derive`d on structs, it will produce a\n[lexicographic](https://en.wikipedia.org/wiki/Lexicographic_order) ordering based on the\ntop-to-bottom declaration order of the struct's members.\n\nWhen `derive`d on enums, variants are primarily ordered by their discriminants. Secondarily,\nthey are ordered by their fields. By default, the discriminant is smallest for variants at the\ntop, and largest for variants at the bottom. Here's an example:\n\n```rust\n#[derive(PartialEq, PartialOrd)]\nenum E {\n    Top,\n    Bottom,\n}\n\nassert!(E::Top < E::Bottom);\n```\n\nHowever, manually setting the discriminants can override this default behavior:\n\n```rust\n#[derive(PartialEq, PartialOrd)]\nenum E {\n    Top = 2,\n    Bottom = 1,\n}\n\nassert!(E::Bottom < E::Top);\n```\n\n## How can I implement `PartialOrd`?\n\n`PartialOrd` only requires implementation of the [`partial_cmp`] method, with the others\ngenerated from default implementations.\n\nHowever it remains possible to implement the others separately for types which do not have a\ntotal order. For example, for floating point numbers, `NaN < 0 == false` and `NaN >= 0 == false`\n(cf. IEEE 754-2008 section 5.11).\n\n`PartialOrd` requires your type to be [`PartialEq`].\n\nIf your type is [`Ord`], you can implement [`partial_cmp`] by using [`cmp`]:\n\n```rust\nuse std::cmp::Ordering;\n\nstruct Person {\n    id: u32,\n    name: String,\n    height: u32,\n}\n\nimpl PartialOrd for Person {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\nimpl Ord for Person {\n    fn cmp(&self, other: &Self) -> Ordering {\n        self.height.cmp(&other.height)\n    }\n}\n\nimpl PartialEq for Person {\n    fn eq(&self, other: &Self) -> bool {\n        self.height == other.height\n    }\n}\n\nimpl Eq for Person {}\n```\n\nYou may also find it useful to use [`partial_cmp`] on your type's fields. Here is an example of\n`Person` types who have a floating-point `height` field that is the only field to be used for\nsorting:\n\n```rust\nuse std::cmp::Ordering;\n\nstruct Person {\n    id: u32,\n    name: String,\n    height: f64,\n}\n\nimpl PartialOrd for Person {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        self.height.partial_cmp(&other.height)\n    }\n}\n\nimpl PartialEq for Person {\n    fn eq(&self, other: &Self) -> bool {\n        self.height == other.height\n    }\n}\n```\n\n## Examples of incorrect `PartialOrd` implementations\n\n```rust\nuse std::cmp::Ordering;\n\n#[derive(PartialEq, Debug)]\nstruct Character {\n    health: u32,\n    experience: u32,\n}\n\nimpl PartialOrd for Character {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.health.cmp(&other.health))\n    }\n}\n\nlet a = Character {\n    health: 10,\n    experience: 5,\n};\nlet b = Character {\n    health: 10,\n    experience: 77,\n};\n\n// Mistake: `PartialEq` and `PartialOrd` disagree with each other.\n\nassert_eq!(a.partial_cmp(&b).unwrap(), Ordering::Equal); // a == b according to `PartialOrd`.\nassert_ne!(a, b); // a != b according to `PartialEq`.\n```\n\n# Examples\n\n```rust\nlet x: u32 = 0;\nlet y: u32 = 1;\n\nassert_eq!(x < y, true);\nassert_eq!(x.lt(&y), true);\n```\n\n[`partial_cmp`]: PartialOrd::partial_cmp\n[`cmp`]: Ord::cmp"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "PartialOrd",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "PartialOrd"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Result",
      "kind": 13,
      "detail": "Result<{unknown}, {unknown}>",
      "documentation": {
        "kind": "markdown",
        "value": "`Result` is a type that represents either success ([`Ok`]) or failure ([`Err`]).\n\nSee the [module documentation](self) for details."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Result",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Result"
      },
      "additionalTextEdits": []
    },
    {
      "label": "RustcDecodable",
      "kind": 18,
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "RustcDecodable",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "RustcDecodable"
      },
      "additionalTextEdits": []
    },
    {
      "label": "RustcEncodable",
      "kind": 18,
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "RustcEncodable",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "RustcEncodable"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Some(…)",
      "kind": 20,
      "detail": "Some(T)",
      "documentation": {
        "kind": "markdown",
        "value": "Some value of type `T`."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Some()",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Some(${1:()})$0"
      },
      "additionalTextEdits": []
    },
    {
      "label": "String",
      "kind": 22,
      "detail": "String",
      "documentation": {
        "kind": "markdown",
        "value": "A UTF-8–encoded, growable string.\n\n`String` is the most common string type. It has ownership over the contents\nof the string, stored in a heap-allocated buffer (see [Representation](#representation)).\nIt is closely related to its borrowed counterpart, the primitive [`str`].\n\n# Examples\n\nYou can create a `String` from [a literal string][`&str`] with [`String::from`]:\n\n[`String::from`]: From::from\n\n```rust\nlet hello = String::from(\"Hello, world!\");\n```\n\nYou can append a [`char`] to a `String` with the [`push`] method, and\nappend a [`&str`] with the [`push_str`] method:\n\n```rust\nlet mut hello = String::from(\"Hello, \");\n\nhello.push('w');\nhello.push_str(\"orld!\");\n```\n\n[`push`]: String::push\n[`push_str`]: String::push_str\n\nIf you have a vector of UTF-8 bytes, you can create a `String` from it with\nthe [`from_utf8`] method:\n\n```rust\n// some bytes, in a vector\nlet sparkle_heart = vec![240, 159, 146, 150];\n\n// We know these bytes are valid, so we'll use `unwrap()`.\nlet sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\n\nassert_eq!(\"💖\", sparkle_heart);\n```\n\n[`from_utf8`]: String::from_utf8\n\n# UTF-8\n\n`String`s are always valid UTF-8. If you need a non-UTF-8 string, consider\n[`OsString`]. It is similar, but without the UTF-8 constraint. Because UTF-8\nis a variable width encoding, `String`s are typically smaller than an array of\nthe same `chars`:\n\n```rust\nuse std::mem;\n\n// `s` is ASCII which represents each `char` as one byte\nlet s = \"hello\";\nassert_eq!(s.len(), 5);\n\n// A `char` array with the same contents would be longer because\n// every `char` is four bytes\nlet s = ['h', 'e', 'l', 'l', 'o'];\nlet size: usize = s.into_iter().map(|c| mem::size_of_val(&c)).sum();\nassert_eq!(size, 20);\n\n// However, for non-ASCII strings, the difference will be smaller\n// and sometimes they are the same\nlet s = \"💖💖💖💖💖\";\nassert_eq!(s.len(), 20);\n\nlet s = ['💖', '💖', '💖', '💖', '💖'];\nlet size: usize = s.into_iter().map(|c| mem::size_of_val(&c)).sum();\nassert_eq!(size, 20);\n```\n\nThis raises interesting questions as to how `s[i]` should work.\nWhat should `i` be here? Several options include byte indices and\n`char` indices but, because of UTF-8 encoding, only byte indices\nwould provide constant time indexing. Getting the `i`th `char`, for\nexample, is available using [`chars`]:\n\n```rust\nlet s = \"hello\";\nlet third_character = s.chars().nth(2);\nassert_eq!(third_character, Some('l'));\n\nlet s = \"💖💖💖💖💖\";\nlet third_character = s.chars().nth(2);\nassert_eq!(third_character, Some('💖'));\n```\n\nNext, what should `s[i]` return? Because indexing returns a reference\nto underlying data it could be `&u8`, `&[u8]`, or something else similar.\nSince we're only providing one index, `&u8` makes the most sense but that\nmight not be what the user expects and can be explicitly achieved with\n[`as_bytes()`]:\n\n```rust\n// The first byte is 104 - the byte value of `'h'`\nlet s = \"hello\";\nassert_eq!(s.as_bytes()[0], 104);\n// or\nassert_eq!(s.as_bytes()[0], b'h');\n\n// The first byte is 240 which isn't obviously useful\nlet s = \"💖💖💖💖💖\";\nassert_eq!(s.as_bytes()[0], 240);\n```\n\nDue to these ambiguities/restrictions, indexing with a `usize` is simply\nforbidden:\n\n```rust\nlet s = \"hello\";\n\n// The following will not compile!\nprintln!(\"The first letter of s is {}\", s[0]);\n```\n\nIt is more clear, however, how `&s[i..j]` should work (that is,\nindexing with a range). It should accept byte indices (to be constant-time)\nand return a `&str` which is UTF-8 encoded. This is also called \"string slicing\".\nNote this will panic if the byte indices provided are not character\nboundaries - see [`is_char_boundary`] for more details. See the implementations\nfor [`SliceIndex<str>`] for more details on string slicing. For a non-panicking\nversion of string slicing, see [`get`].\n\n[`OsString`]: ../../std/ffi/struct.OsString.html \"ffi::OsString\"\n[`SliceIndex<str>`]: core::slice::SliceIndex\n[`as_bytes()`]: str::as_bytes\n[`get`]: str::get\n[`is_char_boundary`]: str::is_char_boundary\n\nThe [`bytes`] and [`chars`] methods return iterators over the bytes and\ncodepoints of the string, respectively. To iterate over codepoints along\nwith byte indices, use [`char_indices`].\n\n[`bytes`]: str::bytes\n[`chars`]: str::chars\n[`char_indices`]: str::char_indices\n\n# Deref\n\n`String` implements <code>[Deref]<Target = [str]></code>, and so inherits all of [`str`]'s\nmethods. In addition, this means that you can pass a `String` to a\nfunction which takes a [`&str`] by using an ampersand (`&`):\n\n```rust\nfn takes_str(s: &str) { }\n\nlet s = String::from(\"Hello\");\n\ntakes_str(&s);\n```\n\nThis will create a [`&str`] from the `String` and pass it in. This\nconversion is very inexpensive, and so generally, functions will accept\n[`&str`]s as arguments unless they need a `String` for some specific\nreason.\n\nIn certain cases Rust doesn't have enough information to make this\nconversion, known as [`Deref`] coercion. In the following example a string\nslice [`&'a str`][`&str`] implements the trait `TraitExample`, and the function\n`example_func` takes anything that implements the trait. In this case Rust\nwould need to make two implicit conversions, which Rust doesn't have the\nmeans to do. For that reason, the following example will not compile.\n\n```rust\ntrait TraitExample {}\n\nimpl<'a> TraitExample for &'a str {}\n\nfn example_func<A: TraitExample>(example_arg: A) {}\n\nlet example_string = String::from(\"example_string\");\nexample_func(&example_string);\n```\n\nThere are two options that would work instead. The first would be to\nchange the line `example_func(&example_string);` to\n`example_func(example_string.as_str());`, using the method [`as_str()`]\nto explicitly extract the string slice containing the string. The second\nway changes `example_func(&example_string);` to\n`example_func(&*example_string);`. In this case we are dereferencing a\n`String` to a [`str`], then referencing the [`str`] back to\n[`&str`]. The second way is more idiomatic, however both work to do the\nconversion explicitly rather than relying on the implicit conversion.\n\n# Representation\n\nA `String` is made up of three components: a pointer to some bytes, a\nlength, and a capacity. The pointer points to the internal buffer which `String`\nuses to store its data. The length is the number of bytes currently stored\nin the buffer, and the capacity is the size of the buffer in bytes. As such,\nthe length will always be less than or equal to the capacity.\n\nThis buffer is always stored on the heap.\n\nYou can look at these with the [`as_ptr`], [`len`], and [`capacity`]\nmethods:\n\n```rust\nuse std::mem;\n\nlet story = String::from(\"Once upon a time...\");\n\n// Prevent automatically dropping the String's data\nlet mut story = mem::ManuallyDrop::new(story);\n\nlet ptr = story.as_mut_ptr();\nlet len = story.len();\nlet capacity = story.capacity();\n\n// story has nineteen bytes\nassert_eq!(19, len);\n\n// We can re-build a String out of ptr, len, and capacity. This is all\n// unsafe because we are responsible for making sure the components are\n// valid:\nlet s = unsafe { String::from_raw_parts(ptr, len, capacity) } ;\n\nassert_eq!(String::from(\"Once upon a time...\"), s);\n```\n\n[`as_ptr`]: str::as_ptr\n[`len`]: String::len\n[`capacity`]: String::capacity\n\nIf a `String` has enough capacity, adding elements to it will not\nre-allocate. For example, consider this program:\n\n```rust\nlet mut s = String::new();\n\nprintln!(\"{}\", s.capacity());\n\nfor _ in 0..5 {\n    s.push_str(\"hello\");\n    println!(\"{}\", s.capacity());\n}\n```\n\nThis will output the following:\n\n```text\n0\n8\n16\n16\n32\n32\n```\n\nAt first, we have no memory allocated at all, but as we append to the\nstring, it increases its capacity appropriately. If we instead use the\n[`with_capacity`] method to allocate the correct capacity initially:\n\n```rust\nlet mut s = String::with_capacity(25);\n\nprintln!(\"{}\", s.capacity());\n\nfor _ in 0..5 {\n    s.push_str(\"hello\");\n    println!(\"{}\", s.capacity());\n}\n```\n\n[`with_capacity`]: String::with_capacity\n\nWe end up with a different output:\n\n```text\n25\n25\n25\n25\n25\n25\n```\n\nHere, there's no need to allocate more memory inside the loop.\n\n[str]: prim@str \"str\"\n[`str`]: prim@str \"str\"\n[`&str`]: prim@str \"&str\"\n[Deref]: core::ops::Deref \"ops::Deref\"\n[`Deref`]: core::ops::Deref \"ops::Deref\"\n[`as_str()`]: String::as_str"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "String",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "String"
      },
      "additionalTextEdits": []
    },
    {
      "label": "ToOwned",
      "kind": 8,
      "documentation": {
        "kind": "markdown",
        "value": "A generalization of `Clone` to borrowed data.\n\nSome types make it possible to go from borrowed to owned, usually by\nimplementing the `Clone` trait. But `Clone` works only for going from `&T`\nto `T`. The `ToOwned` trait generalizes `Clone` to construct owned data\nfrom any borrow of a given type."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "ToOwned",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "ToOwned"
      },
      "additionalTextEdits": []
    },
    {
      "label": "ToString",
      "kind": 8,
      "documentation": {
        "kind": "markdown",
        "value": "A trait for converting a value to a `String`.\n\nThis trait is automatically implemented for any type which implements the\n[`Display`] trait. As such, `ToString` shouldn't be implemented directly:\n[`Display`] should be implemented instead, and you get the `ToString`\nimplementation for free.\n\n[`Display`]: fmt::Display"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "ToString",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "ToString"
      },
      "additionalTextEdits": []
    },
    {
      "label": "TryFrom",
      "kind": 8,
      "documentation": {
        "kind": "markdown",
        "value": "Simple and safe type conversions that may fail in a controlled\nway under some circumstances. It is the reciprocal of [`TryInto`].\n\nThis is useful when you are doing a type conversion that may\ntrivially succeed but may also need special handling.\nFor example, there is no way to convert an [`i64`] into an [`i32`]\nusing the [`From`] trait, because an [`i64`] may contain a value\nthat an [`i32`] cannot represent and so the conversion would lose data.\nThis might be handled by truncating the [`i64`] to an [`i32`] or by\nsimply returning [`i32::MAX`], or by some other method.  The [`From`]\ntrait is intended for perfect conversions, so the `TryFrom` trait\ninforms the programmer when a type conversion could go bad and lets\nthem decide how to handle it.\n\n# Generic Implementations\n\n- `TryFrom<T> for U` implies [`TryInto`]`<U> for T`\n- [`try_from`] is reflexive, which means that `TryFrom<T> for T`\nis implemented and cannot fail -- the associated `Error` type for\ncalling `T::try_from()` on a value of type `T` is [`Infallible`].\nWhen the [`!`] type is stabilized [`Infallible`] and [`!`] will be\nequivalent.\n\n`TryFrom<T>` can be implemented as follows:\n\n```rust\nstruct GreaterThanZero(i32);\n\nimpl TryFrom<i32> for GreaterThanZero {\n    type Error = &'static str;\n\n    fn try_from(value: i32) -> Result<Self, Self::Error> {\n        if value <= 0 {\n            Err(\"GreaterThanZero only accepts values greater than zero!\")\n        } else {\n            Ok(GreaterThanZero(value))\n        }\n    }\n}\n```\n\n# Examples\n\nAs described, [`i32`] implements `TryFrom<`[`i64`]`>`:\n\n```rust\nlet big_number = 1_000_000_000_000i64;\n// Silently truncates `big_number`, requires detecting\n// and handling the truncation after the fact.\nlet smaller_number = big_number as i32;\nassert_eq!(smaller_number, -727379968);\n\n// Returns an error because `big_number` is too big to\n// fit in an `i32`.\nlet try_smaller_number = i32::try_from(big_number);\nassert!(try_smaller_number.is_err());\n\n// Returns `Ok(3)`.\nlet try_successful_smaller_number = i32::try_from(3);\nassert!(try_successful_smaller_number.is_ok());\n```\n\n[`try_from`]: TryFrom::try_from"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "TryFrom",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "TryFrom"
      },
      "additionalTextEdits": []
    },
    {
      "label": "TryInto",
      "kind": 8,
      "documentation": {
        "kind": "markdown",
        "value": "An attempted conversion that consumes `self`, which may or may not be\nexpensive.\n\nLibrary authors should usually not directly implement this trait,\nbut should prefer implementing the [`TryFrom`] trait, which offers\ngreater flexibility and provides an equivalent `TryInto`\nimplementation for free, thanks to a blanket implementation in the\nstandard library. For more information on this, see the\ndocumentation for [`Into`].\n\n# Implementing `TryInto`\n\nThis suffers the same restrictions and reasoning as implementing\n[`Into`], see there for details."
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "TryInto",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "TryInto"
      },
      "additionalTextEdits": []
    },
    {
      "label": "Vec",
      "kind": 22,
      "detail": "Vec<{unknown}, {unknown}>",
      "documentation": {
        "kind": "markdown",
        "value": "A contiguous growable array type, written as `Vec<T>`, short for 'vector'.\n\n# Examples\n\n```rust\nlet mut vec = Vec::new();\nvec.push(1);\nvec.push(2);\n\nassert_eq!(vec.len(), 2);\nassert_eq!(vec[0], 1);\n\nassert_eq!(vec.pop(), Some(2));\nassert_eq!(vec.len(), 1);\n\nvec[0] = 7;\nassert_eq!(vec[0], 7);\n\nvec.extend([1, 2, 3]);\n\nfor x in &vec {\n    println!(\"{x}\");\n}\nassert_eq!(vec, [7, 1, 2, 3]);\n```\n\nThe [`vec!`] macro is provided for convenient initialization:\n\n```rust\nlet mut vec1 = vec![1, 2, 3];\nvec1.push(4);\nlet vec2 = Vec::from([1, 2, 3, 4]);\nassert_eq!(vec1, vec2);\n```\n\nIt can also initialize each element of a `Vec<T>` with a given value.\nThis may be more efficient than performing allocation and initialization\nin separate steps, especially when initializing a vector of zeros:\n\n```rust\nlet vec = vec![0; 5];\nassert_eq!(vec, [0, 0, 0, 0, 0]);\n\n// The following is equivalent, but potentially slower:\nlet mut vec = Vec::with_capacity(5);\nvec.resize(5, 0);\nassert_eq!(vec, [0, 0, 0, 0, 0]);\n```\n\nFor more information, see\n[Capacity and Reallocation](#capacity-and-reallocation).\n\nUse a `Vec<T>` as an efficient stack:\n\n```rust\nlet mut stack = Vec::new();\n\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\nwhile let Some(top) = stack.pop() {\n    // Prints 3, 2, 1\n    println!(\"{top}\");\n}\n```\n\n# Indexing\n\nThe `Vec` type allows access to values by index, because it implements the\n[`Index`] trait. An example will be more explicit:\n\n```rust\nlet v = vec![0, 2, 4, 6];\nprintln!(\"{}\", v[1]); // it will display '2'\n```\n\nHowever be careful: if you try to access an index which isn't in the `Vec`,\nyour software will panic! You cannot do this:\n\n```rust\nlet v = vec![0, 2, 4, 6];\nprintln!(\"{}\", v[6]); // it will panic!\n```\n\nUse [`get`] and [`get_mut`] if you want to check whether the index is in\nthe `Vec`.\n\n# Slicing\n\nA `Vec` can be mutable. On the other hand, slices are read-only objects.\nTo get a [slice][prim@slice], use [`&`]. Example:\n\n```rust\nfn read_slice(slice: &[usize]) {\n    // ...\n}\n\nlet v = vec![0, 1];\nread_slice(&v);\n\n// ... and that's all!\n// you can also do it like this:\nlet u: &[usize] = &v;\n// or like this:\nlet u: &[_] = &v;\n```\n\nIn Rust, it's more common to pass slices as arguments rather than vectors\nwhen you just want to provide read access. The same goes for [`String`] and\n[`&str`].\n\n# Capacity and reallocation\n\nThe capacity of a vector is the amount of space allocated for any future\nelements that will be added onto the vector. This is not to be confused with\nthe *length* of a vector, which specifies the number of actual elements\nwithin the vector. If a vector's length exceeds its capacity, its capacity\nwill automatically be increased, but its elements will have to be\nreallocated.\n\nFor example, a vector with capacity 10 and length 0 would be an empty vector\nwith space for 10 more elements. Pushing 10 or fewer elements onto the\nvector will not change its capacity or cause reallocation to occur. However,\nif the vector's length is increased to 11, it will have to reallocate, which\ncan be slow. For this reason, it is recommended to use [`Vec::with_capacity`]\nwhenever possible to specify how big the vector is expected to get.\n\n# Guarantees\n\nDue to its incredibly fundamental nature, `Vec` makes a lot of guarantees\nabout its design. This ensures that it's as low-overhead as possible in\nthe general case, and can be correctly manipulated in primitive ways\nby unsafe code. Note that these guarantees refer to an unqualified `Vec<T>`.\nIf additional type parameters are added (e.g., to support custom allocators),\noverriding their defaults may change the behavior.\n\nMost fundamentally, `Vec` is and always will be a (pointer, capacity, length)\ntriplet. No more, no less. The order of these fields is completely\nunspecified, and you should use the appropriate methods to modify these.\nThe pointer will never be null, so this type is null-pointer-optimized.\n\nHowever, the pointer might not actually point to allocated memory. In particular,\nif you construct a `Vec` with capacity 0 via [`Vec::new`], [`vec![]`][`vec!`],\n[`Vec::with_capacity(0)`][`Vec::with_capacity`], or by calling [`shrink_to_fit`]\non an empty Vec, it will not allocate memory. Similarly, if you store zero-sized\ntypes inside a `Vec`, it will not allocate space for them. *Note that in this case\nthe `Vec` might not report a [`capacity`] of 0*. `Vec` will allocate if and only\nif <code>[mem::size_of::\\<T>]\\() * [capacity]\\() > 0</code>. In general, `Vec`'s allocation\ndetails are very subtle --- if you intend to allocate memory using a `Vec`\nand use it for something else (either to pass to unsafe code, or to build your\nown memory-backed collection), be sure to deallocate this memory by using\n`from_raw_parts` to recover the `Vec` and then dropping it.\n\nIf a `Vec` *has* allocated memory, then the memory it points to is on the heap\n(as defined by the allocator Rust is configured to use by default), and its\npointer points to [`len`] initialized, contiguous elements in order (what\nyou would see if you coerced it to a slice), followed by <code>[capacity] - [len]</code>\nlogically uninitialized, contiguous elements.\n\nA vector containing the elements `'a'` and `'b'` with capacity 4 can be\nvisualized as below. The top part is the `Vec` struct, it contains a\npointer to the head of the allocation in the heap, length and capacity.\nThe bottom part is the allocation on the heap, a contiguous memory block.\n\n```text\n            ptr      len  capacity\n       +--------+--------+--------+\n       | 0x0123 |      2 |      4 |\n       +--------+--------+--------+\n            |\n            v\nHeap   +--------+--------+--------+--------+\n       |    'a' |    'b' | uninit | uninit |\n       +--------+--------+--------+--------+\n```\n\n- **uninit** represents memory that is not initialized, see [`MaybeUninit`].\n- Note: the ABI is not stable and `Vec` makes no guarantees about its memory\n  layout (including the order of fields).\n\n`Vec` will never perform a \"small optimization\" where elements are actually\nstored on the stack for two reasons:\n\n* It would make it more difficult for unsafe code to correctly manipulate\n  a `Vec`. The contents of a `Vec` wouldn't have a stable address if it were\n  only moved, and it would be more difficult to determine if a `Vec` had\n  actually allocated memory.\n\n* It would penalize the general case, incurring an additional branch\n  on every access.\n\n`Vec` will never automatically shrink itself, even if completely empty. This\nensures no unnecessary allocations or deallocations occur. Emptying a `Vec`\nand then filling it back up to the same [`len`] should incur no calls to\nthe allocator. If you wish to free up unused memory, use\n[`shrink_to_fit`] or [`shrink_to`].\n\n[`push`] and [`insert`] will never (re)allocate if the reported capacity is\nsufficient. [`push`] and [`insert`] *will* (re)allocate if\n<code>[len] == [capacity]</code>. That is, the reported capacity is completely\naccurate, and can be relied on. It can even be used to manually free the memory\nallocated by a `Vec` if desired. Bulk insertion methods *may* reallocate, even\nwhen not necessary.\n\n`Vec` does not guarantee any particular growth strategy when reallocating\nwhen full, nor when [`reserve`] is called. The current strategy is basic\nand it may prove desirable to use a non-constant growth factor. Whatever\nstrategy is used will of course guarantee *O*(1) amortized [`push`].\n\n`vec![x; n]`, `vec![a, b, c, d]`, and\n[`Vec::with_capacity(n)`][`Vec::with_capacity`], will all produce a `Vec`\nwith at least the requested capacity. If <code>[len] == [capacity]</code>,\n(as is the case for the [`vec!`] macro), then a `Vec<T>` can be converted to\nand from a [`Box<[T]>`][owned slice] without reallocating or moving the elements.\n\n`Vec` will not specifically overwrite any data that is removed from it,\nbut also won't specifically preserve it. Its uninitialized memory is\nscratch space that it may use however it wants. It will generally just do\nwhatever is most efficient or otherwise easy to implement. Do not rely on\nremoved data to be erased for security purposes. Even if you drop a `Vec`, its\nbuffer may simply be reused by another allocation. Even if you zero a `Vec`'s memory\nfirst, that might not actually happen because the optimizer does not consider\nthis a side-effect that must be preserved. There is one case which we will\nnot break, however: using `unsafe` code to write to the excess capacity,\nand then increasing the length to match, is always valid.\n\nCurrently, `Vec` does not guarantee the order in which elements are dropped.\nThe order has changed in the past and may change again.\n\n[`get`]: slice::get\n[`get_mut`]: slice::get_mut\n[`String`]: crate::string::String\n[`&str`]: type@str\n[`shrink_to_fit`]: Vec::shrink_to_fit\n[`shrink_to`]: Vec::shrink_to\n[capacity]: Vec::capacity\n[`capacity`]: Vec::capacity\n[mem::size_of::\\<T>]: core::mem::size_of\n[len]: Vec::len\n[`len`]: Vec::len\n[`push`]: Vec::push\n[`insert`]: Vec::insert\n[`reserve`]: Vec::reserve\n[`MaybeUninit`]: core::mem::MaybeUninit\n[owned slice]: Box"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "Vec",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "Vec"
      },
      "additionalTextEdits": []
    },
    {
      "label": "align_of()",
      "kind": 3,
      "detail": "const fn() -> usize",
      "documentation": {
        "kind": "markdown",
        "value": "Returns the [ABI]-required minimum alignment of a type in bytes.\n\nEvery reference to a value of the type `T` must be a multiple of this number.\n\nThis is the alignment used for struct fields. It may be smaller than the preferred alignment.\n\n[ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n\n# Examples\n\n```rust\nuse std::mem;\n\nassert_eq!(4, mem::align_of::<i32>());\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "align_of",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "align_of()$0"
      },
      "additionalTextEdits": []
    },
    {
      "label": "align_of_val(…)",
      "kind": 3,
      "detail": "const fn(&T) -> usize",
      "documentation": {
        "kind": "markdown",
        "value": "Returns the [ABI]-required minimum alignment of the type of the value that `val` points to in\nbytes.\n\nEvery reference to a value of the type `T` must be a multiple of this number.\n\n[ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n\n# Examples\n\n```rust\nuse std::mem;\n\nassert_eq!(4, mem::align_of_val(&5i32));\n```"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "align_of_val",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "align_of_val(${1:val})$0"
      },
      "additionalTextEdits": []
    },
    {
      "label": "alloc_error_handler",
      "kind": 18,
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "alloc_error_handler",
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "alloc_error_handler"
      },
      "additionalTextEdits": []
    },
    {
      "label": "drop(…)",
      "kind": 3,
      "detail": "fn(T)",
      "documentation": {
        "kind": "markdown",
        "value": "Disposes of a value.\n\nThis does so by calling the argument's implementation of [`Drop`][drop].\n\nThis effectively does nothing for types which implement `Copy`, e.g.\nintegers. Such values are copied and _then_ moved into the function, so the\nvalue persists after this function call.\n\nThis function is not magic; it is literally defined as\n\n```rust\npub fn drop<T>(_x: T) {}\n```\n\nBecause `_x` is moved into the function, it is automatically dropped before\nthe function returns.\n\n[drop]: Drop\n\n# Examples\n\nBasic usage:\n\n```rust\nlet v = vec![1, 2, 3];\n\ndrop(v); // explicitly drop the vector\n```\n\nSince [`RefCell`] enforces the borrow rules at runtime, `drop` can\nrelease a [`RefCell`] borrow:\n\n```rust\nuse std::cell::RefCell;\n\nlet x = RefCell::new(1);\n\nlet mut mutable_borrow = x.borrow_mut();\n*mutable_borrow = 1;\n\ndrop(mutable_borrow); // relinquish the mutable borrow on this slot\n\nlet borrow = x.borrow();\nprintln!(\"{}\", *borrow);\n```\n\nIntegers and other types implementing [`Copy`] are unaffected by `drop`.\n\n```rust\n#[derive(Copy, Clone)]\nstruct Foo(u8);\n\nlet x = 1;\nlet y = Foo(2);\ndrop(x); // a copy of `x` is moved and dropped\ndrop(y); // a copy of `y` is moved and dropped\n\nprintln!(\"x: {}, y: {}\", x, y.0); // still available\n```\n\n[`RefCell`]: crate::cell::RefCell"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "drop",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "drop(${1:x});$0"
      },
      "additionalTextEdits": []
    },
    {
      "label": "size_of()",
      "kind": 3,
      "detail": "const fn() -> usize",
      "documentation": {
        "kind": "markdown",
        "value": "Returns the size of a type in bytes.\n\nMore specifically, this is the offset in bytes between successive elements\nin an array with that item type including alignment padding. Thus, for any\ntype `T` and length `n`, `[T; n]` has a size of `n * size_of::<T>()`.\n\nIn general, the size of a type is not stable across compilations, but\nspecific types such as primitives are.\n\nThe following table gives the size for primitives.\n\nType | `size_of::<Type>()`\n---- | ---------------\n() | 0\nbool | 1\nu8 | 1\nu16 | 2\nu32 | 4\nu64 | 8\nu128 | 16\ni8 | 1\ni16 | 2\ni32 | 4\ni64 | 8\ni128 | 16\nf32 | 4\nf64 | 8\nchar | 4\n\nFurthermore, `usize` and `isize` have the same size.\n\nThe types [`*const T`], `&T`, [`Box<T>`], [`Option<&T>`], and `Option<Box<T>>` all have\nthe same size. If `T` is `Sized`, all of those types have the same size as `usize`.\n\nThe mutability of a pointer does not change its size. As such, `&T` and `&mut T`\nhave the same size. Likewise for `*const T` and `*mut T`.\n\n# Size of `#[repr(C)]` items\n\nThe `C` representation for items has a defined layout. With this layout,\nthe size of items is also stable as long as all fields have a stable size.\n\n## Size of Structs\n\nFor `struct`s, the size is determined by the following algorithm.\n\nFor each field in the struct ordered by declaration order:\n\n1. Add the size of the field.\n2. Round up the current size to the nearest multiple of the next field's [alignment].\n\nFinally, round the size of the struct to the nearest multiple of its [alignment].\nThe alignment of the struct is usually the largest alignment of all its\nfields; this can be changed with the use of `repr(align(N))`.\n\nUnlike `C`, zero sized structs are not rounded up to one byte in size.\n\n## Size of Enums\n\nEnums that carry no data other than the discriminant have the same size as C enums\non the platform they are compiled for.\n\n## Size of Unions\n\nThe size of a union is the size of its largest field.\n\nUnlike `C`, zero sized unions are not rounded up to one byte in size.\n\n# Examples\n\n```rust\nuse std::mem;\n\n// Some primitives\nassert_eq!(4, mem::size_of::<i32>());\nassert_eq!(8, mem::size_of::<f64>());\nassert_eq!(0, mem::size_of::<()>());\n\n// Some arrays\nassert_eq!(8, mem::size_of::<[i32; 2]>());\nassert_eq!(12, mem::size_of::<[i32; 3]>());\nassert_eq!(0, mem::size_of::<[i32; 0]>());\n\n\n// Pointer size equality\nassert_eq!(mem::size_of::<&i32>(), mem::size_of::<*const i32>());\nassert_eq!(mem::size_of::<&i32>(), mem::size_of::<Box<i32>>());\nassert_eq!(mem::size_of::<&i32>(), mem::size_of::<Option<&i32>>());\nassert_eq!(mem::size_of::<Box<i32>>(), mem::size_of::<Option<Box<i32>>>());\n```\n\nUsing `#[repr(C)]`.\n\n```rust\nuse std::mem;\n\n#[repr(C)]\nstruct FieldStruct {\n    first: u8,\n    second: u16,\n    third: u8\n}\n\n// The size of the first field is 1, so add 1 to the size. Size is 1.\n// The alignment of the second field is 2, so add 1 to the size for padding. Size is 2.\n// The size of the second field is 2, so add 2 to the size. Size is 4.\n// The alignment of the third field is 1, so add 0 to the size for padding. Size is 4.\n// The size of the third field is 1, so add 1 to the size. Size is 5.\n// Finally, the alignment of the struct is 2 (because the largest alignment amongst its\n// fields is 2), so add 1 to the size for padding. Size is 6.\nassert_eq!(6, mem::size_of::<FieldStruct>());\n\n#[repr(C)]\nstruct TupleStruct(u8, u16, u8);\n\n// Tuple structs follow the same rules.\nassert_eq!(6, mem::size_of::<TupleStruct>());\n\n// Note that reordering the fields can lower the size. We can remove both padding bytes\n// by putting `third` before `second`.\n#[repr(C)]\nstruct FieldStructOptimized {\n    first: u8,\n    third: u8,\n    second: u16\n}\n\nassert_eq!(4, mem::size_of::<FieldStructOptimized>());\n\n// Union size is the size of the largest field.\n#[repr(C)]\nunion ExampleUnion {\n    smaller: u8,\n    larger: u16\n}\n\nassert_eq!(2, mem::size_of::<ExampleUnion>());\n```\n\n[alignment]: align_of\n[`*const T`]: primitive@pointer\n[`Box<T>`]: ../../std/boxed/struct.Box.html\n[`Option<&T>`]: crate::option::Option"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "size_of",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "size_of()$0"
      },
      "additionalTextEdits": []
    },
    {
      "label": "size_of_val(…)",
      "kind": 3,
      "detail": "const fn(&T) -> usize",
      "documentation": {
        "kind": "markdown",
        "value": "Returns the size of the pointed-to value in bytes.\n\nThis is usually the same as [`size_of::<T>()`]. However, when `T` *has* no\nstatically-known size, e.g., a slice [`[T]`][slice] or a [trait object],\nthen `size_of_val` can be used to get the dynamically-known size.\n\n[trait object]: ../../book/ch17-02-trait-objects.html\n\n# Examples\n\n```rust\nuse std::mem;\n\nassert_eq!(4, mem::size_of_val(&5i32));\n\nlet x: [u8; 13] = [0; 13];\nlet y: &[u8] = &x;\nassert_eq!(13, mem::size_of_val(y));\n```\n\n[`size_of::<T>()`]: size_of"
      },
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "size_of_val",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "size_of_val(${1:val})$0"
      },
      "additionalTextEdits": []
    },
    {
      "label": "unsafe",
      "kind": 14,
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "unsafe",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "unsafe {\n    $0\n}"
      },
      "additionalTextEdits": []
    },
    {
      "label": "match",
      "kind": 14,
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "match",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "match $1 {\n    $0\n}"
      },
      "additionalTextEdits": []
    },
    {
      "label": "while",
      "kind": 14,
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "while",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "while $1 {\n    $0\n}"
      },
      "additionalTextEdits": []
    },
    {
      "label": "while let",
      "kind": 14,
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "while let",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "while let $1 = $2 {\n    $0\n}"
      },
      "additionalTextEdits": []
    },
    {
      "label": "loop",
      "kind": 14,
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "loop",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "loop {\n    $0\n}"
      },
      "additionalTextEdits": []
    },
    {
      "label": "if",
      "kind": 14,
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "if",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "if $1 {\n    $0\n}"
      },
      "additionalTextEdits": []
    },
    {
      "label": "if let",
      "kind": 14,
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "if let",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "if let $1 = $2 {\n    $0\n}"
      },
      "additionalTextEdits": []
    },
    {
      "label": "for",
      "kind": 14,
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "for",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "for $1 in $2 {\n    $0\n}"
      },
      "additionalTextEdits": []
    },
    {
      "label": "true",
      "kind": 14,
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "true",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "true"
      },
      "additionalTextEdits": []
    },
    {
      "label": "false",
      "kind": 14,
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "false",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "false"
      },
      "additionalTextEdits": []
    },
    {
      "label": "return",
      "kind": 14,
      "deprecated": false,
      "sortText": "7fffffff",
      "filterText": "return",
      "insertTextFormat": 2,
      "textEdit": {
        "range": {
          "start": {
            "line": 221,
            "character": 8
          },
          "end": {
            "line": 221,
            "character": 13
          }
        },
        "newText": "return $0"
      },
      "additionalTextEdits": []
    }
  ]
}
